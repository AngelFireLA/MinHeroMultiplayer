import { Elf32, Elf64 } from './elf.ts';
type Unpacked<T> = T extends (infer U)[] ? U : T;
/**
 * Patch object.
 */
export declare abstract class Patch<T extends Elf32 | Elf64> {
    /**
     * ELF object.
     */
    protected _elf: T;
    /**
     * Patch constructor.
     *
     * @param elf ELF object.
     */
    constructor(elf: T);
    /**
     * Get shdr for address.
     *
     * @param addr The address.
     * @returns The shdr or null.
     */
    protected _getShdrForAddress(addr: number | bigint): Unpacked<T["sectionHeaders"]> | null;
    /**
     * The shdr for address or throw.
     *
     * @param addr The address.
     * @returns The shdr.
     */
    protected _theShdrForAddress(addr: number | bigint): Unpacked<T["sectionHeaders"]>;
    /**
     * Fuzzy find in code.
     *
     * @param find Fuzzy find.
     * @yields The shdr and index in shdr.
     */
    protected _findFuzzyCode(find: number[]): Generator<[Unpacked<T["sectionHeaders"]>, number, Uint8Array], void, unknown>;
    /**
     * Get ebx for code at address.
     *
     * @param addr The address.
     * @returns The value of ebd or null if value not found.
     */
    protected _findEbx(addr: number): number | null;
    /**
     * Read C-String from address.
     *
     * @param addr String address.
     * @returns The C-String or null if invalid.
     */
    protected _readCstr(addr: number | bigint): string | null;
    /**
     * Check patch.
     *
     * @returns True if valid patch, else false.
     */
    abstract check(): boolean;
    /**
     * Apply patch.
     */
    abstract patch(): void;
}
export {};
