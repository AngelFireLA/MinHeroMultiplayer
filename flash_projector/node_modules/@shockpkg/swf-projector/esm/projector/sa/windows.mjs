import { stat, readFile, writeFile, mkdir } from 'node:fs/promises';
import { basename, dirname } from 'node:path';
import { ArchiveDir, PathType, createArchiveByFileExtensionOrThrow } from '@shockpkg/archive-files';
import { windowsProjectorPatch } from "../../util/windows.mjs";
import { ProjectorSa } from "../sa.mjs";
import { concat } from "../../util/internal/data.mjs";

/**
 * ProjectorSaWindows object.
 */
export class ProjectorSaWindows extends ProjectorSa {
  /**
   * Icon data.
   */
  iconData = null;

  /**
   * Icon file.
   */
  iconFile = null;

  /**
   * Version strings.
   */
  versionStrings = null;

  /**
   * Remove the code signature.
   */
  removeCodeSignature = false;

  /**
   * Attempt to patch the window title with a custom title.
   * Set to string to automatically patch the binary if possible.
   */
  patchWindowTitle = null;

  /**
   * Disable the out-of-date check introduced in version 30.
   * Important since version 35 where there are 90 and 180 day defaults.
   */
  patchOutOfDateDisable = false;

  /**
   * ProjectorSaWindows constructor.
   *
   * @param path Output path.
   */
  constructor(path) {
    super(path);
  }

  /**
   * @inheritdoc
   */
  get extension() {
    return '.exe';
  }

  /**
   * Get icon data if any specified, from data or file.
   *
   * @returns Icon data or null.
   */
  async getIconData() {
    const {
      iconData,
      iconFile
    } = this;
    if (iconData) {
      return typeof iconData === 'function' ? iconData() : iconData;
    }
    if (iconFile) {
      const d = await readFile(iconFile);
      return new Uint8Array(d.buffer, d.byteOffset, d.byteLength);
    }
    return null;
  }

  /**
   * @inheritdoc
   */
  async _writePlayer(player) {
    const {
      path,
      extension
    } = this;
    const extLower = extension.toLowerCase();
    let archive;
    let isPlayer;
    let st = player.toLowerCase().endsWith(extLower) ? await stat(player) : null;
    if (st?.isFile()) {
      const name = basename(player);
      archive = new ArchiveDir(dirname(player));
      archive.subpaths = [name];
      // eslint-disable-next-line jsdoc/require-jsdoc
      isPlayer = path => path === name;
    } else {
      st ??= await stat(player);
      archive = st.isDirectory() ? new ArchiveDir(player) : createArchiveByFileExtensionOrThrow(player, {
        nobrowse: this.nobrowse
      });
      // eslint-disable-next-line jsdoc/require-jsdoc
      isPlayer = path => path.toLowerCase().endsWith(extLower);
    }
    const patches = await this._getPatches();

    /**
     * Extract entry, and also apply patches if any.
     *
     * @param entry Archive entry.
     * @param dest Output path.
     */
    const extract = async (entry, dest) => {
      if (entry.type === PathType.FILE) {
        let data = null;
        for (const patch of patches) {
          // eslint-disable-next-line unicorn/prefer-regexp-test
          if (patch.match(entry.volumePath)) {
            if (!data) {
              // eslint-disable-next-line no-await-in-loop
              const d = await entry.read();
              if (!d) {
                throw new Error(`Failed to read: ${entry.volumePath}`);
              }
              data = new Uint8Array(d.buffer, d.byteOffset, d.byteLength);
            }
            // eslint-disable-next-line no-await-in-loop
            data = await patch.modify(data);
          }
        }
        if (data) {
          await mkdir(dirname(dest), {
            recursive: true
          });
          await writeFile(dest, data);
          await entry.setAttributes(dest, null, {
            ignoreTimes: true
          });
          return;
        }
      }
      await entry.extract(dest);
    };
    let playerPath = '';
    await archive.read(async entry => {
      const {
        volumePath,
        type
      } = entry;

      // Only looking for regular files, no resource forks.
      if (type !== PathType.FILE) {
        return true;
      }

      // Ignore files that are not the player file.
      if (!isPlayer(volumePath)) {
        return true;
      }
      if (playerPath) {
        throw new Error(`Found multiple players in: ${player}`);
      }
      playerPath = volumePath;
      await extract(entry, path);
      return true;
    });
    if (!playerPath) {
      throw new Error(`Failed to locate player in: ${player}`);
    }
    await Promise.all(patches.map(async p => p.after()));
  }

  /**
   * Get patches to apply.
   *
   * @returns Patches list.
   */
  async _getPatches() {
    return (await Promise.all([this._getPatchBinary(), this._getPatchMovie()])).filter(Boolean);
  }

  /**
   * Get patch for binary.
   *
   * @returns Patch spec.
   */
  async _getPatchBinary() {
    const {
      versionStrings,
      removeCodeSignature,
      patchWindowTitle,
      patchOutOfDateDisable
    } = this;
    const iconData = await this.getIconData();
    if (!(iconData || versionStrings || removeCodeSignature || patchWindowTitle !== null || patchOutOfDateDisable)) {
      return null;
    }
    const patch = {
      /**
       * @inheritdoc
       */
      match: file => true,
      /**
       * @inheritdoc
       */
      modify: data => windowsProjectorPatch(data, {
        iconData,
        versionStrings,
        removeCodeSignature,
        patchWindowTitle,
        patchOutOfDateDisable
      }),
      /**
       * @inheritdoc
       */
      after: () => {}
    };
    return patch;
  }

  /**
   * Get patch for movie.
   *
   * @returns Patch spec.
   */
  async _getPatchMovie() {
    const movieData = await this.getMovieData();
    if (!movieData) {
      return null;
    }
    const patch = {
      /**
       * @inheritdoc
       */
      match: file => true,
      /**
       * @inheritdoc
       */
      modify: data => concat([data, this._encodeMovieData(movieData, 'dms')]),
      /**
       * @inheritdoc
       */
      after: () => {}
    };
    return patch;
  }
}
//# sourceMappingURL=windows.mjs.map