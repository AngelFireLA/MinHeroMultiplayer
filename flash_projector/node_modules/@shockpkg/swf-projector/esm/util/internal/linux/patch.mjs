import { findFuzzy } from "../patch.mjs";
import { PATCH_I386 } from "./asm.mjs";
import { EM_386 } from "./elf.mjs";
/**
 * Patch object.
 */
export class Patch {
  /**
   * ELF object.
   */

  /**
   * Patch constructor.
   *
   * @param elf ELF object.
   */
  constructor(elf) {
    this._elf = elf;
  }

  /**
   * Get shdr for address.
   *
   * @param addr The address.
   * @returns The shdr or null.
   */
  _getShdrForAddress(addr) {
    for (const shdr of this._elf.sectionHeaders) {
      const {
        shAddr
      } = shdr;
      if (addr >= shAddr && addr < shAddr + shdr.shSize) {
        return shdr;
      }
    }
    return null;
  }

  /**
   * The shdr for address or throw.
   *
   * @param addr The address.
   * @returns The shdr.
   */
  _theShdrForAddress(addr) {
    const shdr = this._getShdrForAddress(addr);
    if (!shdr) {
      throw new Error(`No section at address: ${addr.toString()}`);
    }
    return shdr;
  }

  /**
   * Fuzzy find in code.
   *
   * @param find Fuzzy find.
   * @yields The shdr and index in shdr.
   */
  *_findFuzzyCode(find) {
    const shdr = this._getShdrForAddress(this._elf.elfHeader.eEntry);
    if (!shdr) {
      return;
    }
    const d = new Uint8Array(shdr.data);
    for (const i of findFuzzy(d, find)) {
      yield [shdr, i, d];
    }
  }

  /**
   * Get ebx for code at address.
   *
   * @param addr The address.
   * @returns The value of ebd or null if value not found.
   */
  _findEbx(addr) {
    if (this._elf.bits !== 32 || this._elf.elfHeader.eMachine !== EM_386) {
      throw new Error('Unsupported architecture');
    }
    const shdr = this._theShdrForAddress(addr);
    const d = new Uint8Array(shdr.data);
    const v = new DataView(shdr.data);
    const before = addr - shdr.shAddr;
    for (const i of findFuzzy(d, PATCH_I386['ebx'], 0, before, true)) {
      return shdr.shAddr + i + 5 + v.getUint32(i + 7, true);
    }
    return null;
  }

  /**
   * Read C-String from address.
   *
   * @param addr String address.
   * @returns The C-String or null if invalid.
   */
  _readCstr(addr) {
    const shdr = this._getShdrForAddress(addr);
    if (!shdr) {
      return null;
    }
    const d = new Uint8Array(shdr.data);
    const s = Number(addr) - Number(shdr.shAddr);
    const e = d.length;
    for (let i = s; i < e; i++) {
      if (!d[i]) {
        // eslint-disable-next-line unicorn/prefer-code-point
        return String.fromCharCode(...d.subarray(s, i));
      }
    }
    return null;
  }

  /**
   * Check patch.
   *
   * @returns True if valid patch, else false.
   */

  /**
   * Apply patch.
   */
}
//# sourceMappingURL=patch.mjs.map