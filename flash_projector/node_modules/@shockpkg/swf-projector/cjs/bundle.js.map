{"version":3,"file":"bundle.js","names":["_nodeFs","require","_promises","_nodeStream","_promises2","_nodePath","_archiveFiles","_queue","userExec","Bundle","excludes","_isOpen","_closeQueue","Queue","constructor","path","flat","isOpen","isExcludedFile","name","exclude","test","open","Error","_checkOutput","clear","_open","close","_assertIsOpen","_close","write","func","call","resourcePath","destination","pathJoin","dirname","projector","resourceExists","fsLstatExists","copyResource","source","options","stat","lstat","isSymbolicLink","copyResourceSymlink","isFile","copyResourceFile","isDirectory","copyResourceDirectory","createResourceDirectory","_expandResourceOptionsCopy","noRecurse","opts","fsWalk","basename","streamResourceFile","createReadStream","createResourceSymlink","readlink","dest","_assertNotResourceExists","merge","mkdir","recursive","atime","mtime","abs","resolve","push","_setResourceAttributes","bind","length","createResourceFile","data","Readable","read","target","t","Buffer","from","buffer","byteOffset","byteLength","symlink","pipeline","createWriteStream","p","n","readdir","Promise","all","map","r","st","atimeCopy","mtimeCopy","executable","executableCopy","_getResourceModeExecutable","mode","fsLchmod","_setResourceModeExecutable","chmod","fsLutimes","utimes","run","ignoreDirectory","_getProjectorPath","_getProjectorPathNested","exports"],"sources":["../src/bundle.ts"],"sourcesContent":["import {createReadStream, createWriteStream} from 'node:fs';\nimport {\n\tchmod,\n\tlstat,\n\tmkdir,\n\treaddir,\n\treadlink,\n\tstat,\n\tsymlink,\n\tutimes\n} from 'node:fs/promises';\nimport {Readable} from 'node:stream';\nimport {pipeline} from 'node:stream/promises';\nimport {join as pathJoin, dirname, basename, resolve} from 'node:path';\n\nimport {\n\tfsLchmod,\n\tfsLutimes,\n\tfsWalk,\n\tfsLstatExists\n} from '@shockpkg/archive-files';\n\nimport {Queue} from './queue.ts';\nimport {Projector} from './projector.ts';\n\nconst userExec = 0b001000000;\n\n/**\n * Options for adding resources.\n */\nexport interface IBundleResourceOptions {\n\t/**\n\t * Access time.\n\t */\n\tatime?: null | Date;\n\n\t/**\n\t * Copy source atime if not set.\n\t */\n\tatimeCopy?: null | boolean;\n\n\t/**\n\t * Modification time.\n\t */\n\tmtime?: null | Date;\n\n\t/**\n\t * Copy source mtime if not set.\n\t */\n\tmtimeCopy?: null | boolean;\n\n\t/**\n\t * Mark files and symlinks as executable.\n\t */\n\texecutable?: null | boolean;\n\n\t/**\n\t * Copy source executable if not set.\n\t */\n\texecutableCopy?: null | boolean;\n\n\t/**\n\t * Optionally merge directory contents.\n\t */\n\tmerge?: null | boolean;\n\n\t/**\n\t * Skip recursive directory copy.\n\t */\n\tnoRecurse?: null | boolean;\n}\n\n/**\n * Bundle object.\n */\nexport abstract class Bundle {\n\t/**\n\t * File and directory names to exclude when adding a directory.\n\t */\n\t// eslint-disable-next-line unicorn/better-regex\n\tpublic excludes = [/^\\./, /^ehthumbs\\.db$/i, /^Thumbs\\.db$/i];\n\n\t/**\n\t * Bundle main executable path.\n\t */\n\tpublic readonly path: string;\n\n\t/**\n\t * Flat bundle.\n\t */\n\tpublic readonly flat: boolean;\n\n\t/**\n\t * Projector instance.\n\t */\n\tpublic abstract readonly projector: Projector;\n\n\t/**\n\t * Open flag.\n\t */\n\tprotected _isOpen = false;\n\n\t/**\n\t * Close callbacks priority queue.\n\t */\n\tprotected _closeQueue = new Queue();\n\n\t/**\n\t * Bundle constructor.\n\t *\n\t * @param path Output path for the main executable.\n\t * @param flat Flat bundle.\n\t */\n\tconstructor(path: string, flat = false) {\n\t\tthis.path = path;\n\t\tthis.flat = flat;\n\t}\n\n\t/**\n\t * Check if output open.\n\t *\n\t * @returns Returns true if open, else false.\n\t */\n\tpublic get isOpen() {\n\t\treturn this._isOpen;\n\t}\n\n\t/**\n\t * Check if name is excluded file.\n\t *\n\t * @param name File name.\n\t * @returns Returns true if excluded, else false.\n\t */\n\tpublic isExcludedFile(name: string) {\n\t\tfor (const exclude of this.excludes) {\n\t\t\tif (exclude.test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Open output.\n\t */\n\tpublic async open() {\n\t\tif (this._isOpen) {\n\t\t\tthrow new Error('Already open');\n\t\t}\n\t\tawait this._checkOutput();\n\n\t\tthis._closeQueue.clear();\n\t\tawait this._open();\n\n\t\tthis._isOpen = true;\n\t}\n\n\t/**\n\t * Close output.\n\t */\n\tpublic async close() {\n\t\tthis._assertIsOpen();\n\n\t\ttry {\n\t\t\tawait this._close();\n\t\t} finally {\n\t\t\tthis._closeQueue.clear();\n\t\t}\n\n\t\tthis._isOpen = false;\n\t}\n\n\t/**\n\t * Write out the bundle.\n\t * Has a callback to write out the resources.\n\t *\n\t * @param func Async function.\n\t * @returns Return value of the async function.\n\t */\n\tpublic async write<T>(func: ((self: this) => Promise<T>) | null = null) {\n\t\tawait this.open();\n\t\ttry {\n\t\t\treturn func ? await func.call(this, this) : null;\n\t\t} finally {\n\t\t\tawait this.close();\n\t\t}\n\t}\n\n\t/**\n\t * Get path for resource.\n\t *\n\t * @param destination Resource destination.\n\t * @returns Destination path.\n\t */\n\tpublic resourcePath(destination: string) {\n\t\treturn pathJoin(dirname(this.projector.path), destination);\n\t}\n\n\t/**\n\t * Check if path for resource exists.\n\t *\n\t * @param destination Resource destination.\n\t * @returns True if destination exists, else false.\n\t */\n\tpublic async resourceExists(destination: string) {\n\t\treturn !!(await fsLstatExists(this.resourcePath(destination)));\n\t}\n\n\t/**\n\t * Copy resource, detecting source type automatically.\n\t *\n\t * @param destination Resource destination.\n\t * @param source Source directory.\n\t * @param options Resource options.\n\t */\n\tpublic async copyResource(\n\t\tdestination: string,\n\t\tsource: string,\n\t\toptions: Readonly<IBundleResourceOptions> | null = null\n\t) {\n\t\tthis._assertIsOpen();\n\n\t\tconst stat = await lstat(source);\n\t\tswitch (true) {\n\t\t\tcase stat.isSymbolicLink(): {\n\t\t\t\tawait this.copyResourceSymlink(destination, source, options);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase stat.isFile(): {\n\t\t\t\tawait this.copyResourceFile(destination, source, options);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase stat.isDirectory(): {\n\t\t\t\tawait this.copyResourceDirectory(destination, source, options);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error(`Unsupported resource type: ${source}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Copy directory as resource, recursive copy.\n\t *\n\t * @param destination Resource destination.\n\t * @param source Source directory.\n\t * @param options Resource options.\n\t */\n\tpublic async copyResourceDirectory(\n\t\tdestination: string,\n\t\tsource: string,\n\t\toptions: Readonly<IBundleResourceOptions> | null = null\n\t) {\n\t\tthis._assertIsOpen();\n\n\t\t// Create directory.\n\t\tawait this.createResourceDirectory(\n\t\t\tdestination,\n\t\t\toptions\n\t\t\t\t? await this._expandResourceOptionsCopy(options, async () =>\n\t\t\t\t\t\tstat(source)\n\t\t\t\t\t)\n\t\t\t\t: options\n\t\t);\n\n\t\t// If not recursive do not walk contents.\n\t\tif (options && options.noRecurse) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Any directories we add should not be recursive.\n\t\tconst opts = {\n\t\t\t...options,\n\t\t\tnoRecurse: true\n\t\t};\n\t\tawait fsWalk(source, async (path, stat) => {\n\t\t\t// If this name is excluded, skip without descending.\n\t\t\tif (this.isExcludedFile(basename(path))) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tawait this.copyResource(\n\t\t\t\tpathJoin(destination, path),\n\t\t\t\tpathJoin(source, path),\n\t\t\t\topts\n\t\t\t);\n\t\t\treturn true;\n\t\t});\n\t}\n\n\t/**\n\t * Copy file as resource.\n\t *\n\t * @param destination Resource destination.\n\t * @param source Source file.\n\t * @param options Resource options.\n\t */\n\tpublic async copyResourceFile(\n\t\tdestination: string,\n\t\tsource: string,\n\t\toptions: Readonly<IBundleResourceOptions> | null = null\n\t) {\n\t\tthis._assertIsOpen();\n\n\t\tawait this.streamResourceFile(\n\t\t\tdestination,\n\t\t\tcreateReadStream(source),\n\t\t\toptions\n\t\t\t\t? await this._expandResourceOptionsCopy(options, async () =>\n\t\t\t\t\t\tstat(source)\n\t\t\t\t\t)\n\t\t\t\t: options\n\t\t);\n\t}\n\n\t/**\n\t * Copy symlink as resource.\n\t *\n\t * @param destination Resource destination.\n\t * @param source Source symlink.\n\t * @param options Resource options.\n\t */\n\tpublic async copyResourceSymlink(\n\t\tdestination: string,\n\t\tsource: string,\n\t\toptions: Readonly<IBundleResourceOptions> | null = null\n\t) {\n\t\tthis._assertIsOpen();\n\n\t\tawait this.createResourceSymlink(\n\t\t\tdestination,\n\t\t\tawait readlink(source),\n\t\t\toptions\n\t\t\t\t? await this._expandResourceOptionsCopy(options, async () =>\n\t\t\t\t\t\tlstat(source)\n\t\t\t\t\t)\n\t\t\t\t: options\n\t\t);\n\t}\n\n\t/**\n\t * Create a resource directory.\n\t *\n\t * @param destination Resource destination.\n\t * @param options Resource options.\n\t */\n\tpublic async createResourceDirectory(\n\t\tdestination: string,\n\t\toptions: Readonly<IBundleResourceOptions> | null = null\n\t) {\n\t\tthis._assertIsOpen();\n\n\t\tconst dest = await this._assertNotResourceExists(\n\t\t\tdestination,\n\t\t\t!!(options && options.merge)\n\t\t);\n\t\tawait mkdir(dest, {recursive: true});\n\n\t\t// If either is set, queue up change times when closing.\n\t\tif (options && (options.atime || options.mtime)) {\n\t\t\t// Get absolute path, use length for the priority.\n\t\t\t// Also copy the options object which the owner could change.\n\t\t\tconst abs = resolve(dest);\n\t\t\tthis._closeQueue.push(\n\t\t\t\tthis._setResourceAttributes.bind(this, abs, {...options}),\n\t\t\t\tabs.length\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Create a resource file.\n\t *\n\t * @param destination Resource destination.\n\t * @param data Resource data.\n\t * @param options Resource options.\n\t */\n\tpublic async createResourceFile(\n\t\tdestination: string,\n\t\tdata: Readonly<Uint8Array> | string,\n\t\toptions: Readonly<IBundleResourceOptions> | null = null\n\t) {\n\t\tthis._assertIsOpen();\n\n\t\tawait this.streamResourceFile(\n\t\t\tdestination,\n\t\t\tnew Readable({\n\t\t\t\t/**\n\t\t\t\t * Read method.\n\t\t\t\t */\n\t\t\t\tread() {\n\t\t\t\t\tthis.push(data);\n\t\t\t\t\tthis.push(null);\n\t\t\t\t}\n\t\t\t}),\n\t\t\toptions\n\t\t);\n\t}\n\n\t/**\n\t * Create a resource symlink.\n\t *\n\t * @param destination Resource destination.\n\t * @param target Symlink target.\n\t * @param options Resource options.\n\t */\n\tpublic async createResourceSymlink(\n\t\tdestination: string,\n\t\ttarget: Readonly<Uint8Array> | string,\n\t\toptions: Readonly<IBundleResourceOptions> | null = null\n\t) {\n\t\tthis._assertIsOpen();\n\n\t\tconst dest = await this._assertNotResourceExists(destination);\n\t\tawait mkdir(dirname(dest), {recursive: true});\n\t\tconst t =\n\t\t\ttypeof target === 'string'\n\t\t\t\t? target\n\t\t\t\t: Buffer.from(\n\t\t\t\t\t\ttarget.buffer,\n\t\t\t\t\t\ttarget.byteOffset,\n\t\t\t\t\t\ttarget.byteLength\n\t\t\t\t\t);\n\t\tawait symlink(t, dest);\n\n\t\tif (options) {\n\t\t\tawait this._setResourceAttributes(dest, options);\n\t\t}\n\t}\n\n\t/**\n\t * Stream readable source to resource file.\n\t *\n\t * @param destination Resource destination.\n\t * @param data Resource stream.\n\t * @param options Resource options.\n\t */\n\tpublic async streamResourceFile(\n\t\tdestination: string,\n\t\tdata: Readable,\n\t\toptions: Readonly<IBundleResourceOptions> | null = null\n\t) {\n\t\tthis._assertIsOpen();\n\n\t\tconst dest = await this._assertNotResourceExists(destination);\n\t\tawait mkdir(dirname(dest), {recursive: true});\n\t\tawait pipeline(data, createWriteStream(dest));\n\n\t\tif (options) {\n\t\t\tawait this._setResourceAttributes(dest, options);\n\t\t}\n\t}\n\n\t/**\n\t * Check that output path is valid, else throws.\n\t */\n\tprotected async _checkOutput() {\n\t\tif (this.flat) {\n\t\t\tconst p = dirname(this.path);\n\t\t\tif (await fsLstatExists(p)) {\n\t\t\t\tfor (const n of await readdir(p)) {\n\t\t\t\t\tif (!this.isExcludedFile(n)) {\n\t\t\t\t\t\tthrow new Error(`Output path not empty: ${p}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tawait Promise.all(\n\t\t\t[this.path, this.resourcePath('')].map(async p => {\n\t\t\t\tif (await fsLstatExists(p)) {\n\t\t\t\t\tthrow new Error(`Output path already exists: ${p}`);\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * Expand resource options copy properties with stat object from source.\n\t *\n\t * @param options Options object.\n\t * @param stat Stat function.\n\t * @returns Options copy with any values populated.\n\t */\n\tprotected async _expandResourceOptionsCopy(\n\t\toptions: Readonly<IBundleResourceOptions>,\n\t\tstat: () => Promise<{\n\t\t\tatime: Date;\n\t\t\tmtime: Date;\n\t\t\tmode: number;\n\t\t}>\n\t) {\n\t\tconst r = {...options} as IBundleResourceOptions;\n\t\tlet st;\n\t\tif (!r.atime && r.atimeCopy) {\n\t\t\tst = await stat();\n\t\t\tr.atime = st.atime;\n\t\t}\n\t\tif (!r.mtime && r.mtimeCopy) {\n\t\t\tst ??= await stat();\n\t\t\tr.mtime = st.mtime;\n\t\t}\n\t\tif (typeof r.executable !== 'boolean' && r.executableCopy) {\n\t\t\tst ??= await stat();\n\t\t\tr.executable = this._getResourceModeExecutable(st.mode);\n\t\t}\n\t\treturn r;\n\t}\n\n\t/**\n\t * Set resource attributes from options object.\n\t *\n\t * @param path File path.\n\t * @param options Options object.\n\t */\n\tprotected async _setResourceAttributes(\n\t\tpath: string,\n\t\toptions: Readonly<IBundleResourceOptions>\n\t) {\n\t\tconst {atime, mtime, executable} = options;\n\t\tconst st = await lstat(path);\n\n\t\t// Maybe set executable if not a directory.\n\t\tif (typeof executable === 'boolean' && !st.isDirectory()) {\n\t\t\t// eslint-disable-next-line unicorn/prefer-ternary\n\t\t\tif (st.isSymbolicLink()) {\n\t\t\t\tawait fsLchmod(\n\t\t\t\t\tpath,\n\t\t\t\t\tthis._setResourceModeExecutable(\n\t\t\t\t\t\t// Workaround for a legacy Node issue.\n\t\t\t\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t\t\t\tst.mode & 0b111111111,\n\t\t\t\t\t\texecutable\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tawait chmod(\n\t\t\t\t\tpath,\n\t\t\t\t\tthis._setResourceModeExecutable(st.mode, executable)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Maybe change times if either is set.\n\t\tif (atime || mtime) {\n\t\t\t// eslint-disable-next-line unicorn/prefer-ternary\n\t\t\tif (st.isSymbolicLink()) {\n\t\t\t\tawait fsLutimes(path, atime || st.atime, mtime || st.mtime);\n\t\t\t} else {\n\t\t\t\tawait utimes(path, atime || st.atime, mtime || st.mtime);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get file mode executable.\n\t *\n\t * @param mode Current mode.\n\t * @returns Is executable.\n\t */\n\tprotected _getResourceModeExecutable(mode: number) {\n\t\t// eslint-disable-next-line no-bitwise\n\t\treturn !!(mode & userExec);\n\t}\n\n\t/**\n\t * Set file mode executable.\n\t *\n\t * @param mode Current mode.\n\t * @param executable Is executable.\n\t * @returns File mode.\n\t */\n\tprotected _setResourceModeExecutable(mode: number, executable: boolean) {\n\t\t// eslint-disable-next-line no-bitwise\n\t\treturn (executable ? mode | userExec : mode & ~userExec) >>> 0;\n\t}\n\n\t/**\n\t * Open output.\n\t */\n\tprotected async _open() {\n\t\tawait this.projector.write();\n\t}\n\n\t/**\n\t * Close output.\n\t */\n\tprotected async _close() {\n\t\tawait this._closeQueue.run();\n\t}\n\n\t/**\n\t * Assert bundle is open.\n\t */\n\tprotected _assertIsOpen() {\n\t\tif (!this._isOpen) {\n\t\t\tthrow new Error('Not open');\n\t\t}\n\t}\n\n\t/**\n\t * Assert resource does not exist, returning destination path.\n\t *\n\t * @param destination Resource destination.\n\t * @param ignoreDirectory Ignore directories.\n\t * @returns Destination path.\n\t */\n\tprotected async _assertNotResourceExists(\n\t\tdestination: string,\n\t\tignoreDirectory = false\n\t) {\n\t\tconst dest = this.resourcePath(destination);\n\t\tconst st = await fsLstatExists(dest);\n\t\tif (st && (!ignoreDirectory || !st.isDirectory())) {\n\t\t\tthrow new Error(`Resource path exists: ${dest}`);\n\t\t}\n\t\treturn dest;\n\t}\n\n\t/**\n\t * Get the projector path.\n\t *\n\t * @returns This path or the nested path.\n\t */\n\tprotected _getProjectorPath() {\n\t\treturn this.flat ? this.path : this._getProjectorPathNested();\n\t}\n\n\t/**\n\t * Get nested projector path.\n\t *\n\t * @returns Output path.\n\t */\n\tprotected abstract _getProjectorPathNested(): string;\n\n\t/**\n\t * Create projector instance for the bundle.\n\t *\n\t * @returns Projector instance.\n\t */\n\tprotected abstract _createProjector(): Projector;\n}\n"],"mappings":"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","ignoreList":[]}