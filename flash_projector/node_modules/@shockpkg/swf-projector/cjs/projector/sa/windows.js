"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ProjectorSaWindows = void 0;
var _promises = require("node:fs/promises");
var _nodePath = require("node:path");
var _archiveFiles = require("@shockpkg/archive-files");
var _windows = require("../../util/windows.js");
var _sa = require("../sa.js");
var _data = require("../../util/internal/data.js");
/**
 * ProjectorSaWindows object.
 */
class ProjectorSaWindows extends _sa.ProjectorSa {
  /**
   * Icon data.
   */
  iconData = null;

  /**
   * Icon file.
   */
  iconFile = null;

  /**
   * Version strings.
   */
  versionStrings = null;

  /**
   * Remove the code signature.
   */
  removeCodeSignature = false;

  /**
   * Attempt to patch the window title with a custom title.
   * Set to string to automatically patch the binary if possible.
   */
  patchWindowTitle = null;

  /**
   * Disable the out-of-date check introduced in version 30.
   * Important since version 35 where there are 90 and 180 day defaults.
   */
  patchOutOfDateDisable = false;

  /**
   * ProjectorSaWindows constructor.
   *
   * @param path Output path.
   */
  constructor(path) {
    super(path);
  }

  /**
   * @inheritdoc
   */
  get extension() {
    return '.exe';
  }

  /**
   * Get icon data if any specified, from data or file.
   *
   * @returns Icon data or null.
   */
  async getIconData() {
    const {
      iconData,
      iconFile
    } = this;
    if (iconData) {
      return typeof iconData === 'function' ? iconData() : iconData;
    }
    if (iconFile) {
      const d = await (0, _promises.readFile)(iconFile);
      return new Uint8Array(d.buffer, d.byteOffset, d.byteLength);
    }
    return null;
  }

  /**
   * @inheritdoc
   */
  async _writePlayer(player) {
    const {
      path,
      extension
    } = this;
    const extLower = extension.toLowerCase();
    let archive;
    let isPlayer;
    let st = player.toLowerCase().endsWith(extLower) ? await (0, _promises.stat)(player) : null;
    if (st?.isFile()) {
      const name = (0, _nodePath.basename)(player);
      archive = new _archiveFiles.ArchiveDir((0, _nodePath.dirname)(player));
      archive.subpaths = [name];
      // eslint-disable-next-line jsdoc/require-jsdoc
      isPlayer = path => path === name;
    } else {
      st ??= await (0, _promises.stat)(player);
      archive = st.isDirectory() ? new _archiveFiles.ArchiveDir(player) : (0, _archiveFiles.createArchiveByFileExtensionOrThrow)(player, {
        nobrowse: this.nobrowse
      });
      // eslint-disable-next-line jsdoc/require-jsdoc
      isPlayer = path => path.toLowerCase().endsWith(extLower);
    }
    const patches = await this._getPatches();

    /**
     * Extract entry, and also apply patches if any.
     *
     * @param entry Archive entry.
     * @param dest Output path.
     */
    const extract = async (entry, dest) => {
      if (entry.type === _archiveFiles.PathType.FILE) {
        let data = null;
        for (const patch of patches) {
          // eslint-disable-next-line unicorn/prefer-regexp-test
          if (patch.match(entry.volumePath)) {
            if (!data) {
              // eslint-disable-next-line no-await-in-loop
              const d = await entry.read();
              if (!d) {
                throw new Error(`Failed to read: ${entry.volumePath}`);
              }
              data = new Uint8Array(d.buffer, d.byteOffset, d.byteLength);
            }
            // eslint-disable-next-line no-await-in-loop
            data = await patch.modify(data);
          }
        }
        if (data) {
          await (0, _promises.mkdir)((0, _nodePath.dirname)(dest), {
            recursive: true
          });
          await (0, _promises.writeFile)(dest, data);
          await entry.setAttributes(dest, null, {
            ignoreTimes: true
          });
          return;
        }
      }
      await entry.extract(dest);
    };
    let playerPath = '';
    await archive.read(async entry => {
      const {
        volumePath,
        type
      } = entry;

      // Only looking for regular files, no resource forks.
      if (type !== _archiveFiles.PathType.FILE) {
        return true;
      }

      // Ignore files that are not the player file.
      if (!isPlayer(volumePath)) {
        return true;
      }
      if (playerPath) {
        throw new Error(`Found multiple players in: ${player}`);
      }
      playerPath = volumePath;
      await extract(entry, path);
      return true;
    });
    if (!playerPath) {
      throw new Error(`Failed to locate player in: ${player}`);
    }
    await Promise.all(patches.map(async p => p.after()));
  }

  /**
   * Get patches to apply.
   *
   * @returns Patches list.
   */
  async _getPatches() {
    return (await Promise.all([this._getPatchBinary(), this._getPatchMovie()])).filter(Boolean);
  }

  /**
   * Get patch for binary.
   *
   * @returns Patch spec.
   */
  async _getPatchBinary() {
    const {
      versionStrings,
      removeCodeSignature,
      patchWindowTitle,
      patchOutOfDateDisable
    } = this;
    const iconData = await this.getIconData();
    if (!(iconData || versionStrings || removeCodeSignature || patchWindowTitle !== null || patchOutOfDateDisable)) {
      return null;
    }
    const patch = {
      /**
       * @inheritdoc
       */
      match: file => true,
      /**
       * @inheritdoc
       */
      modify: data => (0, _windows.windowsProjectorPatch)(data, {
        iconData,
        versionStrings,
        removeCodeSignature,
        patchWindowTitle,
        patchOutOfDateDisable
      }),
      /**
       * @inheritdoc
       */
      after: () => {}
    };
    return patch;
  }

  /**
   * Get patch for movie.
   *
   * @returns Patch spec.
   */
  async _getPatchMovie() {
    const movieData = await this.getMovieData();
    if (!movieData) {
      return null;
    }
    const patch = {
      /**
       * @inheritdoc
       */
      match: file => true,
      /**
       * @inheritdoc
       */
      modify: data => (0, _data.concat)([data, this._encodeMovieData(movieData, 'dms')]),
      /**
       * @inheritdoc
       */
      after: () => {}
    };
    return patch;
  }
}
exports.ProjectorSaWindows = ProjectorSaWindows;
//# sourceMappingURL=windows.js.map