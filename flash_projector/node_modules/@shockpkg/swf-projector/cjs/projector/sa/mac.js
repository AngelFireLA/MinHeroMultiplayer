"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ProjectorSaMac = void 0;
var _promises = require("node:fs/promises");
var _nodePath = require("node:path");
var _archiveFiles = require("@shockpkg/archive-files");
var _plistDom = require("@shockpkg/plist-dom");
var _util = require("../../util.js");
var _mac = require("../../util/mac.js");
var _sa = require("../sa.js");
/**
 * ProjectorSaMac object.
 */
class ProjectorSaMac extends _sa.ProjectorSa {
  /**
   * Binary name, also renames rsrc and icns.
   */
  binaryName = null;

  /**
   * Icon data.
   */
  iconData = null;

  /**
   * Icon file.
   */
  iconFile = null;

  /**
   * Info.plist data.
   * Currently only supports XML plist.
   */
  infoPlistData = null;

  /**
   * Info.plist file.
   * Currently only supports XML plist.
   */
  infoPlistFile = null;

  /**
   * PkgInfo data.
   */
  pkgInfoData = null;

  /**
   * PkgInfo file.
   */
  pkgInfoFile = null;

  /**
   * Update the bundle name in Info.plist.
   * Possible values:
   * - false: Leave untouched.
   * - true: Output name.
   * - null: Remove value.
   * - string: Custom value.
   */
  bundleName = false;

  /**
   * Remove the file associations in Info.plist.
   */
  removeFileAssociations = false;

  /**
   * Remove InfoPlist.strings localization files if present.
   */
  removeInfoPlistStrings = false;

  /**
   * Remove the code signature.
   * Modern projectors are codesigned so that any changes breaks it.
   * No signature is better than a broken one.
   */
  removeCodeSignature = false;

  /**
   * Attempt to patch the window title with a custom title.
   * Currently supports versions 11+.
   */
  patchWindowTitle = null;

  /**
   * ProjectorSaMac constructor.
   *
   * @param path Output path.
   */
  constructor(path) {
    super(path);
  }

  /**
   * @inheritdoc
   */
  get extension() {
    return '.app';
  }

  /**
   * Get app icon name, custom.
   *
   * @returns File name.
   */
  get appIconName() {
    const n = this.binaryName;
    return n ? `${n}.icns` : null;
  }

  /**
   * Get app rsrc name, custom.
   *
   * @returns File name.
   */
  get appRsrcName() {
    const n = this.binaryName;
    return n ? `${n}.rsrc` : null;
  }

  /**
   * Get app movie path.
   *
   * @returns File path.
   */
  get appPathMovie() {
    return 'Contents/Resources/movie.swf';
  }

  /**
   * Get app Info.plist path.
   *
   * @returns File path.
   */
  get appPathInfoPlist() {
    return 'Contents/Info.plist';
  }

  /**
   * Get app PkgInfo path.
   *
   * @returns File path.
   */
  get appPathPkgInfo() {
    return 'Contents/PkgInfo';
  }

  /**
   * Get the movie path.
   *
   * @returns Icon path.
   */
  get moviePath() {
    return (0, _nodePath.join)(this.path, this.appPathMovie);
  }

  /**
   * Get the Info.plist path.
   *
   * @returns Icon path.
   */
  get infoPlistPath() {
    return (0, _nodePath.join)(this.path, this.appPathInfoPlist);
  }

  /**
   * Get the PkgInfo path.
   *
   * @returns Icon path.
   */
  get pkgInfoPath() {
    return (0, _nodePath.join)(this.path, this.appPathPkgInfo);
  }

  /**
   * Get the binary path.
   *
   * @param binaryName Binary name.
   * @returns Binary path.
   */
  getBinaryPath(binaryName) {
    return (0, _nodePath.join)(this.path, 'Contents/MacOS', binaryName);
  }

  /**
   * Get the rsrc path.
   *
   * @param name The name.
   * @param addExt Add extension.
   * @returns Rsrc path.
   */
  getRsrcPath(name, addExt = false) {
    name += addExt ? '.rsrc' : '';
    return (0, _nodePath.join)(this.path, 'Contents/Resources', name);
  }

  /**
   * Get the icon path.
   *
   * @param iconName Icon name.
   * @returns Icon path.
   */
  getIconPath(iconName) {
    return (0, _nodePath.join)(this.path, 'Contents/Resources', iconName);
  }

  /**
   * Get icon data if any specified, from data or file.
   *
   * @returns Icon data or null.
   */
  async getIconData() {
    const {
      iconData,
      iconFile
    } = this;
    if (iconData) {
      return typeof iconData === 'function' ? iconData() : iconData;
    }
    if (iconFile) {
      const d = await (0, _promises.readFile)(iconFile);
      return new Uint8Array(d.buffer, d.byteOffset, d.byteLength);
    }
    return null;
  }

  /**
   * Get Info.plist data if any specified, from data or file.
   *
   * @returns Info.plist data or null.
   */
  async getInfoPlistData() {
    const {
      infoPlistData,
      infoPlistFile
    } = this;
    if (infoPlistData) {
      switch (typeof infoPlistData) {
        case 'function':
          {
            const d = await infoPlistData();
            return typeof d === 'string' ? d : new TextDecoder().decode(d);
          }
        case 'string':
          {
            return infoPlistData;
          }
        default:
          {
            // Fall through.
          }
      }
      return new TextDecoder().decode(infoPlistData);
    }
    if (infoPlistFile) {
      return (0, _promises.readFile)(infoPlistFile, 'utf8');
    }
    return null;
  }

  /**
   * Get PkgInfo data if any specified, from data or file.
   *
   * @returns PkgInfo data or null.
   */
  async getPkgInfoData() {
    const {
      pkgInfoData,
      pkgInfoFile
    } = this;
    if (pkgInfoData) {
      switch (typeof pkgInfoData) {
        case 'function':
          {
            return pkgInfoData();
          }
        case 'string':
          {
            return new TextEncoder().encode(pkgInfoData);
          }
        default:
          {
            // Fall through.
          }
      }
      return pkgInfoData;
    }
    if (pkgInfoFile) {
      const d = await (0, _promises.readFile)(pkgInfoFile);
      return new Uint8Array(d.buffer, d.byteOffset, d.byteLength);
    }
    return null;
  }

  /**
   * Get configured bundle name, or null to remove.
   *
   * @returns New name or null.
   */
  getBundleName() {
    const {
      bundleName
    } = this;
    return bundleName === true ? (0, _util.trimExtension)((0, _nodePath.basename)(this.path), this.extension, true) : bundleName;
  }

  /**
   * @inheritdoc
   */
  async _writePlayer(player) {
    const {
      path,
      extension
    } = this;
    const extLower = extension.toLowerCase();
    let archive;
    let isPlayer;
    let st = player.toLowerCase().endsWith(extLower) ? await (0, _promises.stat)(player) : null;
    if (st?.isDirectory()) {
      const name = (0, _nodePath.basename)(player);
      archive = new _archiveFiles.ArchiveDir((0, _nodePath.dirname)(player));
      archive.subpaths = [name];
      // eslint-disable-next-line jsdoc/require-jsdoc
      isPlayer = path => path === name;
    } else {
      st ??= await (0, _promises.stat)(player);
      archive = st.isDirectory() ? new _archiveFiles.ArchiveDir(player) : (0, _archiveFiles.createArchiveByFileExtensionOrThrow)(player, {
        nobrowse: this.nobrowse
      });
      // eslint-disable-next-line jsdoc/require-jsdoc
      isPlayer = path => path.toLowerCase().endsWith(extLower);
    }
    const filters = await this._getFilters();
    const patches = await this._getPatches();

    /**
     * Extract entry, and also apply patches if any.
     *
     * @param entry Archive entry.
     * @param dest Output path.
     */
    const extract = async (entry, dest) => {
      for (const filter of filters) {
        // eslint-disable-next-line unicorn/prefer-regexp-test
        if (filter.match(entry.volumePath)) {
          return;
        }
      }
      if (entry.type === _archiveFiles.PathType.FILE) {
        let data = null;
        for (const patch of patches) {
          // eslint-disable-next-line unicorn/prefer-regexp-test
          if (patch.match(entry.volumePath)) {
            if (!data) {
              // eslint-disable-next-line no-await-in-loop
              const d = await entry.read();
              if (!d) {
                throw new Error(`Failed to read: ${entry.volumePath}`);
              }
              data = new Uint8Array(d.buffer, d.byteOffset, d.byteLength);
            }
            // eslint-disable-next-line no-await-in-loop
            data = await patch.modify(data);
          }
        }
        if (data) {
          await (0, _promises.mkdir)((0, _nodePath.dirname)(dest), {
            recursive: true
          });
          await (0, _promises.writeFile)(dest, data);
          await entry.setAttributes(dest, null, {
            ignoreTimes: true
          });
          return;
        }
      }
      await entry.extract(dest);
    };
    let playerPath = '';
    await archive.read(async entry => {
      const {
        volumePath,
        type
      } = entry;

      // No resource forks expected.
      if (type === _archiveFiles.PathType.RESOURCE_FORK) {
        return true;
      }

      // Look for the player.
      if (isPlayer(volumePath)) {
        if (playerPath) {
          throw new Error(`Found multiple players in: ${player}`);
        }
        playerPath = volumePath;
      }

      // Check if this is the player.
      if (volumePath !== playerPath && !volumePath.startsWith(`${playerPath}/`)) {
        return true;
      }
      const dest = path + volumePath.slice(playerPath.length);
      await extract(entry, dest);
      return true;
    });
    if (!playerPath) {
      throw new Error(`Failed to locate player in: ${player}`);
    }
    await Promise.all(patches.map(async p => p.after()));
  }

  /**
   * Write out the projector movie file.
   */
  async _writeMovie() {
    const movieData = await this.getMovieData();
    if (!movieData) {
      return;
    }
    await (0, _promises.writeFile)(this.moviePath, movieData);
  }

  /**
   * Get filters to apply.
   *
   * @returns Filter list.
   */
  async _getFilters() {
    return (await Promise.all([this._getFilterInfoPlistStrings(), this._getFilterCodeSignature()])).filter(Boolean);
  }

  /**
   * Get filter for InfoPlist.strings.
   *
   * @returns Filter spec.
   */
  async _getFilterInfoPlistStrings() {
    const {
      removeInfoPlistStrings
    } = this;
    if (!removeInfoPlistStrings) {
      return null;
    }
    const filter = {
      // eslint-disable-next-line jsdoc/require-jsdoc, unicorn/better-regex
      match: file => /\.lproj\/InfoPlist\.strings$/i.test(file)
    };
    return filter;
  }

  /**
   * Get filter for code signature paths.
   *
   * @returns Filter spec.
   */
  async _getFilterCodeSignature() {
    const {
      removeCodeSignature
    } = this;
    if (!removeCodeSignature) {
      return null;
    }
    const filter = {
      // eslint-disable-next-line jsdoc/require-jsdoc
      match: file =>
      // eslint-disable-next-line unicorn/better-regex
      /\/(_CodeSignature|CodeResources)(\/|$)/i.test(file)
    };
    return filter;
  }

  /**
   * Get patches to apply.
   *
   * @returns Patches list.
   */
  async _getPatches() {
    return (await Promise.all([this._getPatchBinary(), this._getPatchPkgInfo(), this._getPatchInfoPlist(), this._getPatchMovie()])).filter(Boolean);
  }

  /**
   * Get patch for PkgInfo.
   *
   * @returns Patch spec.
   */
  async _getPatchPkgInfo() {
    const infoData = await this.getPkgInfoData();
    if (!infoData) {
      return null;
    }
    let count = 0;
    const patch = {
      /**
       * @inheritdoc
       */
      // eslint-disable-next-line unicorn/better-regex
      match: file => /^[^/]+\/Contents\/PkgInfo$/i.test(file),
      /**
       * @inheritdoc
       */
      modify: data => {
        count++;
        return infoData;
      },
      /**
       * @inheritdoc
       */
      after: async () => {
        // Player could omit this file, just write in that case.
        if (!count) {
          const {
            pkgInfoPath
          } = this;
          await (0, _promises.mkdir)((0, _nodePath.dirname)(pkgInfoPath), {
            recursive: true
          });
          await (0, _promises.writeFile)(pkgInfoPath, infoData);
        }
      }
    };
    return patch;
  }

  /**
   * Get patch for binary.
   *
   * @returns Patch spec.
   */
  async _getPatchBinary() {
    const {
      removeCodeSignature,
      patchWindowTitle
    } = this;
    if (!(removeCodeSignature || patchWindowTitle !== null)) {
      return null;
    }
    let count = 0;
    const patch = {
      /**
       * @inheritdoc
       */
      match: file =>
      // eslint-disable-next-line unicorn/better-regex
      /^[^/]+\/Contents\/MacOS\/[^/]+$/i.test(file),
      /**
       * @inheritdoc
       */
      modify: data => {
        data = (0, _mac.macProjectorMachoPatch)(data, {
          removeCodeSignature,
          patchWindowTitle
        });
        count++;
        return data;
      },
      /**
       * @inheritdoc
       */
      after: () => {
        if (!count) {
          throw new Error('Failed to locate binary for patching');
        }
      }
    };
    return patch;
  }

  /**
   * Get patch for Info.plist and dependancies.
   *
   * @returns Patch spec.
   */
  async _getPatchInfoPlist() {
    const {
      binaryName,
      appIconName,
      removeFileAssociations,
      appPathInfoPlist,
      appRsrcName
    } = this;
    const bundleName = this.getBundleName();
    const customPlist = await this.getInfoPlistData();
    const iconData = await this.getIconData();
    const modifyPlist = !!(customPlist !== null || appIconName || binaryName || bundleName !== false || removeFileAssociations);
    if (!modifyPlist && !iconData) {
      return null;
    }
    let count = 0;
    let xmlOld = '';
    const lower = modifyPlist ? appPathInfoPlist.toLowerCase() : '';
    const patch = {
      /**
       * @inheritdoc
       */
      match: file => modifyPlist && file.slice(file.indexOf('/') + 1).toLowerCase() === lower,
      /**
       * @inheritdoc
       */
      modify: data => {
        // Use a custom plist or the existing one.
        xmlOld = new TextDecoder().decode(data);
        const plist = new _plistDom.Plist();
        plist.fromXml(customPlist || xmlOld);
        const dict = plist.getValue().castAs(_plistDom.ValueDict);
        if (appIconName) {
          dict.set('CFBundleIconFile', new _plistDom.ValueString(appIconName));
        }
        if (binaryName) {
          dict.set('CFBundleExecutable', new _plistDom.ValueString(binaryName));
        }
        if (bundleName !== false) {
          const key = 'CFBundleName';
          if (bundleName === null) {
            dict.delete(key);
          } else {
            dict.set(key, new _plistDom.ValueString(bundleName));
          }
        }
        if (removeFileAssociations) {
          dict.delete('CFBundleDocumentTypes');
        }
        data = new TextEncoder().encode(plist.toXml());
        count++;
        return data;
      },
      /**
       * @inheritdoc
       */
      after: async () => {
        if (modifyPlist && !count) {
          throw new Error(`Failed to locate for update: ${appPathInfoPlist}`);
        }
        let oldDictValue = null;

        // eslint-disable-next-line jsdoc/require-jsdoc
        const oldDict = async () => {
          if (!oldDictValue) {
            const plist = new _plistDom.Plist();
            plist.fromXml(xmlOld ?? (await (0, _promises.readFile)(this.infoPlistPath, 'utf8')));
            oldDictValue = plist.getValue().castAs(_plistDom.ValueDict);
          }
          return oldDictValue;
        };
        const tasks = [];
        if (binaryName) {
          const binaryOld = (await oldDict()).getValue('CFBundleExecutable').castAs(_plistDom.ValueString).value;
          const binaryPathOld = this.getBinaryPath(binaryOld);
          const binaryPathNew = this.getBinaryPath(binaryName);
          tasks.push(async () => (0, _promises.rename)(binaryPathOld, binaryPathNew));
          const rsrcPathOld = this.getRsrcPath(binaryOld, true);
          if (!appRsrcName) {
            throw new Error('Internal error');
          }
          const rsrcPathNew = this.getRsrcPath(appRsrcName);
          tasks.push(async () => (0, _promises.rename)(rsrcPathOld, rsrcPathNew).catch(err => {
            // The rsrc file does not exist in 35+.
            if (!err || err.code !== 'ENOENT') {
              throw err;
            }
          }));
        }
        if (appIconName || iconData) {
          const oldIconName = (await oldDict()).getValue('CFBundleIconFile').castAs(_plistDom.ValueString).value;
          let iconPathOld = this.getIconPath(oldIconName);

          // Implicit extension (old projectors).
          if (!oldIconName.includes('.')) {
            iconPathOld += '.icns';
          }
          if (appIconName) {
            const iconPathNew = this.getIconPath(appIconName);
            tasks.push(async () => (0, _promises.rename)(iconPathOld, iconPathNew).then(async () => {
              if (iconData) {
                await (0, _promises.writeFile)(iconPathNew, iconData);
              }
            }));
          } else if (iconData) {
            tasks.push(async () => (0, _promises.writeFile)(iconPathOld, iconData));
          }
        }
        await Promise.all(tasks.map(async f => f()));
      }
    };
    return patch;
  }

  /**
   * Get patch for movie.
   *
   * @returns Patch spec.
   */
  async _getPatchMovie() {
    const movieData = await this.getMovieData();
    if (!movieData) {
      return null;
    }
    const patch = {
      /**
       * @inheritdoc
       */
      match: file => false,
      /**
       * @inheritdoc
       */
      modify: data => data,
      /**
       * @inheritdoc
       */
      after: async () => {
        await (0, _promises.writeFile)(this.moviePath, movieData);
      }
    };
    return patch;
  }
}
exports.ProjectorSaMac = ProjectorSaMac;
//# sourceMappingURL=mac.js.map