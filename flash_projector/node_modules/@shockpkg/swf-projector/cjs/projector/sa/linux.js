"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ProjectorSaLinux = void 0;
var _promises = require("node:fs/promises");
var _nodePath = require("node:path");
var _archiveFiles = require("@shockpkg/archive-files");
var _linux = require("../../util/linux.js");
var _elf = require("../../util/internal/linux/elf.js");
var _sa = require("../sa.js");
var _data = require("../../util/internal/data.js");
/**
 * ProjectorSaLinux object.
 */
class ProjectorSaLinux extends _sa.ProjectorSa {
  /**
   * Attempt to patch the window title with a custom title.
   * Set to a string to automatically patch the binary if possible.
   */
  patchWindowTitle = null;

  /**
   * Attempt to patch out application menu.
   * Set to true to automatically patch the code if possible.
   */
  patchMenuRemove = false;

  /**
   * Attempt to patch the projector path reading code.
   * Necessary to work around broken projector path resolving code.
   * Set to true to automatically patch the code if possible.
   */
  patchProjectorPath = false;

  /**
   * Attempt to patch the broken 64-bit projector offset reading code.
   * Necessary to work around broken projector logic in standalone players.
   * Set to true to automatically patch the code if possible.
   */
  patchProjectorOffset = false;

  /**
   * ProjectorSaLinux constructor.
   *
   * @param path Output path.
   */
  constructor(path) {
    super(path);
  }

  /**
   * @inheritdoc
   */
  get extension() {
    return '';
  }

  /**
   * Get projector archive names, case insensitive.
   *
   * @returns List of names known to be used in projectors.
   */
  getProjectorArchiveNames() {
    return ['flashplayer', 'flashplayerdebugger', 'gflashplayer'];
  }

  /**
   * @inheritdoc
   */
  async _writePlayer(player) {
    const {
      path
    } = this;
    let isElf = false;
    const st = await (0, _promises.stat)(player);
    const isDir = st.isDirectory();
    if (!isDir && st.size >= 4) {
      const d = new ArrayBuffer(4);
      const f = await (0, _promises.open)(player, 'r');
      try {
        await f.read(new Uint8Array(d), 0, 4, 0);
      } finally {
        await f.close();
      }
      isElf = new DataView(d).getUint32(0, false) === 0x7f454c46;
    }
    let archive;
    let isPlayer;
    if (isElf) {
      const name = (0, _nodePath.basename)(player);
      archive = new _archiveFiles.ArchiveDir((0, _nodePath.dirname)(player));
      archive.subpaths = [name];
      // eslint-disable-next-line jsdoc/require-jsdoc
      isPlayer = (path, mode) => path === name;
    } else {
      archive = isDir ? new _archiveFiles.ArchiveDir(player) : (0, _archiveFiles.createArchiveByFileExtensionOrThrow)(player, {
        nobrowse: this.nobrowse
      });
      const names = new Set();
      for (const n of this.getProjectorArchiveNames()) {
        names.add(n.toLowerCase());
      }
      // eslint-disable-next-line jsdoc/require-jsdoc
      isPlayer = (path, mode) =>
      // The file should be user executable, if mode is available.
      // eslint-disable-next-line no-bitwise
      (mode === null || !!(mode & 0b001000000)) && names.has(path.slice(path.lastIndexOf('/') + 1).toLowerCase());
    }
    const patches = await this._getPatches();

    /**
     * Extract entry, and also apply patches if any.
     *
     * @param entry Archive entry.
     * @param dest Output path.
     */
    const extract = async (entry, dest) => {
      if (entry.type === _archiveFiles.PathType.FILE) {
        let data = null;
        for (const patch of patches) {
          // eslint-disable-next-line unicorn/prefer-regexp-test
          if (patch.match(entry.volumePath)) {
            if (!data) {
              // eslint-disable-next-line no-await-in-loop
              const d = await entry.read();
              if (!d) {
                throw new Error(`Failed to read: ${entry.volumePath}`);
              }
              data = new Uint8Array(d.buffer, d.byteOffset, d.byteLength);
            }
            // eslint-disable-next-line no-await-in-loop
            data = await patch.modify(data);
          }
        }
        if (data) {
          await (0, _promises.mkdir)((0, _nodePath.dirname)(dest), {
            recursive: true
          });
          await (0, _promises.writeFile)(dest, data);
          await entry.setAttributes(dest, null, {
            ignoreTimes: true
          });
          return;
        }
      }
      await entry.extract(dest);
    };
    let playerPath = '';
    await archive.read(async entry => {
      const {
        volumePath,
        type,
        mode
      } = entry;

      // Only looking for regular files, no resource forks.
      if (type !== _archiveFiles.PathType.FILE) {
        return true;
      }

      // Ignore files that are not the player file.
      if (!isPlayer(volumePath, mode)) {
        return true;
      }
      if (playerPath) {
        throw new Error(`Found multiple players in: ${player}`);
      }
      playerPath = volumePath;
      await extract(entry, path);
      return true;
    });
    if (!playerPath) {
      throw new Error(`Failed to locate player in: ${player}`);
    }
    await Promise.all(patches.map(async p => p.after()));
  }

  /**
   * Get patches to apply.
   *
   * @returns Patches list.
   */
  async _getPatches() {
    return (await Promise.all([this._getPatchBinary(), this._getPatchMovie()])).filter(Boolean);
  }

  /**
   * Get patch for binary.
   *
   * @returns Patch spec.
   */
  async _getPatchBinary() {
    const {
      patchWindowTitle,
      patchMenuRemove,
      patchProjectorPath,
      patchProjectorOffset
    } = this;
    if (!(patchWindowTitle !== null || patchMenuRemove || patchProjectorPath || patchProjectorOffset)) {
      return null;
    }
    const patch = {
      /**
       * @inheritdoc
       */
      match: file => true,
      /**
       * @inheritdoc
       */
      modify: data => (0, _linux.linuxProjectorPatch)(data, {
        patchWindowTitle,
        patchMenuRemove,
        patchProjectorPath,
        patchProjectorOffset
      }),
      /**
       * @inheritdoc
       */
      after: () => {}
    };
    return patch;
  }

  /**
   * Get patch for movie.
   *
   * @returns Patch spec.
   */
  async _getPatchMovie() {
    const movieData = await this.getMovieData();
    if (!movieData) {
      return null;
    }
    const patch = {
      /**
       * @inheritdoc
       */
      match: file => true,
      /**
       * @inheritdoc
       */
      modify: data => {
        const v = new DataView(data.buffer, data.byteOffset, data.byteLength);
        return (0, _data.concat)([data, this._encodeMovieData(movieData, v.getUint16(18, true) === _elf.EM_X86_64 ? 'lid' : 'smd')]);
      },
      /**
       * @inheritdoc
       */
      after: () => {}
    };
    return patch;
  }
}
exports.ProjectorSaLinux = ProjectorSaLinux;
//# sourceMappingURL=linux.js.map