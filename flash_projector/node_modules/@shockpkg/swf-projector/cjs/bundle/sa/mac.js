"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BundleSaMac = void 0;
var _promises = require("node:fs/promises");
var _nodePath = require("node:path");
var _archiveFiles = require("@shockpkg/archive-files");
var _plistDom = require("@shockpkg/plist-dom");
var _util = require("../../util.js");
var _mac = require("../../util/mac.js");
var _mac2 = require("../../projector/sa/mac.js");
var _sa = require("../sa.js");
/**
 * BundleSaMac object.
 */
class BundleSaMac extends _sa.BundleSa {
  /**
   * ProjectorSaMac instance.
   */

  /**
   * BundleSaMac constructor.
   *
   * @param path Output path for the main application.
   * @param flat Flat bundle.
   */
  constructor(path, flat = false) {
    super(path, flat);
    this.projector = this._createProjector();
  }

  /**
   * @inheritdoc
   */
  get extension() {
    return '.app';
  }

  /**
   * Get the launcher name.
   *
   * @returns Launcher name.
   */
  _getLauncherName() {
    return (0, _util.trimExtension)((0, _nodePath.basename)(this.path), this.extension, true);
  }

  /**
   * @inheritdoc
   */
  _getProjectorPathNested() {
    const projName = `${this._getLauncherName()}${this.extension}`;
    return (0, _nodePath.join)(this.path, 'Contents', 'Resources', projName);
  }

  /**
   * @inheritdoc
   */
  _createProjector() {
    return new _mac2.ProjectorSaMac(this._getProjectorPath());
  }

  /**
   * @inheritdoc
   */
  async _writeLauncher() {
    const {
      path,
      projector
    } = this;

    // Create paths to things to create.
    const appContents = (0, _nodePath.join)(path, 'Contents');
    const appMacOS = (0, _nodePath.join)(appContents, 'MacOS');
    const appResources = (0, _nodePath.join)(appContents, 'Resources');
    const appInfoPlist = (0, _nodePath.join)(appContents, 'Info.plist');
    const appPkgInfo = (0, _nodePath.join)(appContents, 'PkgInfo');

    // Read the projector Info.plist.
    const plist = new _plistDom.Plist();
    plist.fromXml(await (0, _promises.readFile)(projector.infoPlistPath, 'utf8'));
    const dict = plist.getValue().castAs(_plistDom.ValueDict);

    // Get the binary path and read the types.
    const projBinaryName = dict.getValue('CFBundleExecutable').castAs(_plistDom.ValueString).value;
    const projBinaryPath = projector.getBinaryPath(projBinaryName);
    const projBinaryTypes = await (0, _mac.machoTypesFile)(projBinaryPath);

    // Get the icon path.
    const projIconName = dict.getValue('CFBundleIconFile').castAs(_plistDom.ValueString).value;
    const projIconPath = projector.getIconPath(projIconName);

    // Get the PkgInfo path.
    const projPkgInfoPath = projector.pkgInfoPath;

    // Create the launcher binary with the same types and mode.
    const launcherName = this._getLauncherName();
    const launcherPath = (0, _nodePath.join)(appMacOS, launcherName);
    await (0, _promises.mkdir)((0, _nodePath.dirname)(launcherPath), {
      recursive: true
    });
    await (0, _promises.writeFile)(launcherPath, await (0, _mac.machoAppLauncher)(projBinaryTypes), {
      mode: (await (0, _promises.stat)(projBinaryPath)).mode
    });

    // Copy the projector icon if present.
    const pathIcon = (0, _nodePath.join)(appResources, projIconName);
    if (await (0, _archiveFiles.fsLstatExists)(projIconPath)) {
      await (0, _promises.copyFile)(projIconPath, pathIcon);
    }

    // Copy PkgInfo if present.
    if (await (0, _archiveFiles.fsLstatExists)(projPkgInfoPath)) {
      await (0, _promises.copyFile)(projPkgInfoPath, appPkgInfo);
    }

    // Update the executable name in the plist for the launcher.
    dict.set('CFBundleExecutable', new _plistDom.ValueString(launcherName));

    // Write the updated Info.plist.
    await (0, _promises.mkdir)((0, _nodePath.dirname)(appInfoPlist), {
      recursive: true
    });
    await (0, _promises.writeFile)(appInfoPlist, plist.toXml(), 'utf8');
  }
}
exports.BundleSaMac = BundleSaMac;
//# sourceMappingURL=mac.js.map