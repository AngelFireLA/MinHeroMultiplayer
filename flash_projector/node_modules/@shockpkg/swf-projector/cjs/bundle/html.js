"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BundleHtml = void 0;
var _nodePath = require("node:path");
var _promises = require("node:fs/promises");
var _bundle = require("../bundle.js");
var _html = require("../projector/html.js");
var _util = require("../util.js");
/**
 * BundleHtml object.
 */
class BundleHtml extends _bundle.Bundle {
  /**
   * ProjectorHtml instance.
   */

  /**
   * BundleHtml constructor.
   *
   * @param path Output path.
   * @param flat Flat bundle.
   */
  constructor(path, flat = false) {
    super(path, flat);
    this.projector = this._createProjector();
  }

  /**
   * Main application file extension.
   *
   * @returns File extension.
   */
  get extension() {
    const a = (0, _nodePath.basename)(this.path).split('.');
    const ext = a.length > 1 ? a.pop() : '';
    if (!ext) {
      throw new Error('Failed to extract extension');
    }
    return `.${ext}`;
  }

  /**
   * Get the nested subdirectory.
   *
   * @returns Directory name.
   */
  get subdir() {
    return (0, _util.trimExtension)((0, _nodePath.basename)(this.path), this.extension);
  }

  /**
   * Get the nested index.
   *
   * @returns File name.
   */
  get index() {
    return `index${this.extension}`;
  }

  /**
   * Get launcher HTML code.
   *
   * @returns HTML code.
   */
  getLauncher() {
    const {
      projector,
      subdir,
      index
    } = this;
    const {
      lang,
      title
    } = projector;
    const path = `${subdir}/${index}`;
    const url = path.split(/[/\\]/).map(encodeURIComponent).join('/');
    const hAttr = lang === null ? '' : ` lang="${(0, _util.htmlEncode)(lang, true)}"`;
    return ['<!DOCTYPE html>', `<html${hAttr}>`, ' <head>', '  <meta charset="UTF-8">', '  <meta http-equiv="X-UA-Compatible" content="IE=Edge">', `  <meta http-equiv="refresh" content="0; url=${(0, _util.htmlEncode)(url, true)}">`, ...(title === null ? [] : [`  <title>${(0, _util.htmlEncode)(title)}</title>`]), ' </head>', ' <body></body>', '</html>', ''].map(s => s.replace(/^\s+/, s => '\t'.repeat(s.length))).join('\n');
  }

  /**
   * @inheritdoc
   */
  async _close() {
    if (!this.flat) {
      await this._writeLauncher();
    }
    await super._close();
  }

  /**
   * @inheritdoc
   */
  _getProjectorPathNested() {
    return (0, _nodePath.join)((0, _nodePath.dirname)(this.path), this.subdir, this.index);
  }

  /**
   * Create projector instance for the bundle.
   *
   * @returns Projector instance.
   */
  _createProjector() {
    return new _html.ProjectorHtml(this._getProjectorPath());
  }

  /**
   * Write the launcher file.
   */
  async _writeLauncher() {
    const {
      path
    } = this;
    await (0, _promises.mkdir)((0, _nodePath.dirname)(path), {
      recursive: true
    });
    await (0, _promises.writeFile)(path, this.getLauncher());
  }
}
exports.BundleHtml = BundleHtml;
//# sourceMappingURL=html.js.map