"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.windowsLauncher = windowsLauncher;
exports.windowsProjectorPatch = windowsProjectorPatch;
var _portableExecutableSignature = require("portable-executable-signature");
var _resedit = require("@shockpkg/resedit");
var _util = require("../util.js");
var _data = require("./internal/data.js");
var _patch = require("./internal/patch.js");
var _constants = require("./internal/windows/constants.js");
var _exe = require("./internal/windows/exe.js");
var _ood = require("./internal/windows/ood32.js");
var _ood2 = require("./internal/windows/ood64.js");
var _rsrc = require("./internal/windows/rsrc.js");
var _title = require("./internal/windows/title.js");
/**
 * Windows projector patch.
 */

/**
 * Apply patches to projector.
 *
 * @param data Projector data.
 * @param options Patch options.
 * @returns Patched projector.
 */
function windowsProjectorPatch(data, options) {
  const {
    iconData,
    versionStrings,
    removeCodeSignature,
    patchWindowTitle,
    patchOutOfDateDisable
  } = options;

  // Remove signature, possibly preserved for later.
  const signature = removeCodeSignature ? null : (0, _portableExecutableSignature.signatureGet)(data);
  let d = (0, _portableExecutableSignature.signatureSet)(data, null, true, true);

  // Parse the EXE once, if needed.
  let exe = null;

  // Patch the out-of-date check.
  if (patchOutOfDateDisable) {
    exe = exe || _resedit.NtExecutable.from(d);

    // Narrow the search to just the code section and patch.
    const code = (0, _exe.exeCodeSection)(exe);
    const {
      data
    } = code;
    (0, _patch.patchOnce)(new Uint8Array(data), exe.newHeader.is32bit() ? _ood.ood32 : _ood2.ood64, 'Out Of Date Disable');
    code.data = data;
  }

  // Do patches that require changing size.
  if (iconData || versionStrings || patchWindowTitle) {
    exe = exe || _resedit.NtExecutable.from(d);

    // Remove reloc so rsrc can safely be resized.
    const relocRestore = (0, _exe.exeRemoveReloc)(exe);

    // Remove rsrc to modify and so sections can be added.
    (0, _exe.exeAssertLastSection)(exe, _constants.IDD_RESOURCE, '.rsrc');
    const rsrc = _resedit.NtExecutableResource.from(exe);
    exe.setSectionByEntry(_constants.IDD_RESOURCE, null);
    if (iconData) {
      (0, _rsrc.rsrcPatchIcon)(rsrc, iconData);
    }
    if (versionStrings) {
      (0, _rsrc.rsrcPatchVersion)(rsrc, versionStrings);
    }

    // If patching title and cannot be done by resource changes.
    let sdTitle = null;
    if (typeof patchWindowTitle === 'string' && !(0, _title.patchWindowTitleRsrc)(rsrc, patchWindowTitle)) {
      const l = patchWindowTitle.length;
      sdTitle = new ArrayBuffer((0, _data.align)((l + 1) * 2, 16));
      const v = new DataView(sdTitle);
      for (let i = 0; i < l; i++) {
        // eslint-disable-next-line unicorn/prefer-code-point
        v.setUint16(i * 2, patchWindowTitle.charCodeAt(i), true);
      }
    }

    // Assemble new data section if any.
    if (sdTitle) {
      // PE library lacks a way to add an arbitrary section.
      // Using the reserved index temporarily, then clearing it.
      const entry = _constants.IDD_RESERVED;
      exe.setSectionByEntry(entry, {
        info: {
          name: '.shockd',
          virtualSize: sdTitle.byteLength,
          virtualAddress: 0,
          sizeOfRawData: sdTitle.byteLength,
          pointerToRawData: 0,
          pointerToRelocations: 0,
          pointerToLineNumbers: 0,
          numberOfRelocations: 0,
          numberOfLineNumbers: 0,
          characteristics:
          // eslint-disable-next-line no-bitwise
          _constants.IMAGE_SCN_CNT_INITIALIZED_DATA | _constants.IMAGE_SCN_MEM_READ
        },
        data: sdTitle
      });
      const s = exe.getSectionByEntry(entry);
      exe.newHeader.optionalHeaderDataDirectory.set(entry, {
        virtualAddress: 0,
        size: 0
      });
      if (!s) {
        throw new Error('Internal error');
      }

      // Patch title if in the data.
      if (sdTitle) {
        (0, _title.patchWindowTitleData)(exe, s.info.virtualAddress);
      }
    }

    // Add rsrc back.
    rsrc.outputResource(exe, false, true);

    // Add reloc back.
    relocRestore();

    // Update sizes.
    (0, _exe.exeUpdateSizes)(exe);
  }

  // If the EXE was parsed generate new data from it.
  if (exe) {
    d = exe.generate();
  }

  // Add back signature if one preserved.
  if (signature) {
    d = (0, _portableExecutableSignature.signatureSet)(d, signature, true, true);
  }
  return new Uint8Array(d);
}

/**
 * Get Windows launcher for the specified type.
 *
 * @param type Executable type.
 * @param resources Data to optionally copy resources from.
 * @returns Launcher data.
 */
async function windowsLauncher(type, resources = null) {
  let data;
  switch (type) {
    case 'i686':
      {
        data = await (0, _util.launcher)('windows-i686');
        break;
      }
    case 'x86_64':
      {
        data = await (0, _util.launcher)('windows-x86_64');
        break;
      }
    default:
      {
        throw new Error(`Invalid type: ${type}`);
      }
  }

  // Check if copying resources.
  if (!resources) {
    return data;
  }

  // Read resources from file.
  const rsrc = _resedit.NtExecutableResource.from(_resedit.NtExecutable.from(await resources(), {
    ignoreCert: true
  }));

  // Find the first icon group for each language.
  const resIconGroups = new Map();
  for (const iconGroup of _resedit.Resource.IconGroupEntry.fromEntries(rsrc.entries)) {
    const known = resIconGroups.get(iconGroup.lang) || null;
    if (!known || iconGroup.id < known.id) {
      resIconGroups.set(iconGroup.lang, iconGroup);
    }
  }

  // List the groups and icons to be kept.
  const iconGroups = new Set();
  const iconDatas = new Set();
  for (const [, group] of resIconGroups) {
    iconGroups.add(group.id);
    for (const icon of group.icons) {
      iconDatas.add(icon.iconID);
    }
  }

  // Filter out the resources to keep.
  const typeVersionInfo = 16;
  const typeIcon = 3;
  const typeIconGroup = 14;
  rsrc.entries = rsrc.entries.filter(entry => entry.type === typeVersionInfo || entry.type === typeIcon && iconDatas.has(entry.id) || entry.type === typeIconGroup && iconGroups.has(entry.id));

  // Remove signature if present.
  const signedData = (0, _portableExecutableSignature.signatureGet)(data);
  let exeData = (0, _portableExecutableSignature.signatureSet)(data, null, true, true);

  // Parse launcher.
  const exe = _resedit.NtExecutable.from(exeData);

  // Remove reloc so rsrc can safely be resized.
  const relocRestore = (0, _exe.exeRemoveReloc)(exe);

  // Apply resources to launcher.
  rsrc.outputResource(exe, false, true);

  // Add reloc back.
  relocRestore();

  // Update sizes.
  (0, _exe.exeUpdateSizes)(exe);

  // Generated the updated launcher.
  exeData = exe.generate();

  // Add back signature if one present.
  if (signedData) {
    exeData = (0, _portableExecutableSignature.signatureSet)(exeData, signedData, true, true);
  }
  return new Uint8Array(exeData);
}
//# sourceMappingURL=windows.js.map