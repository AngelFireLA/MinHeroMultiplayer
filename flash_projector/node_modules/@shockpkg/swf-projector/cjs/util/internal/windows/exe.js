"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.exeAssertLastSection = exeAssertLastSection;
exports.exeCodeSection = exeCodeSection;
exports.exeRemoveReloc = exeRemoveReloc;
exports.exeSectionByAddress = exeSectionByAddress;
exports.exeUpdateSizes = exeUpdateSizes;
var _data = require("../data.js");
var _constants = require("./constants.js");
/**
 * Get the EXE section that includes an address.
 *
 * @param exe NtExecutable instance.
 * @param address The address.
 * @returns The section or null if section not found.
 */
function exeSectionByAddress(exe, address) {
  for (const {
    info,
    data
  } of exe.getAllSections()) {
    const {
      virtualAddress,
      virtualSize
    } = info;
    if (address >= virtualAddress && address < virtualAddress + virtualSize) {
      return {
        info: info,
        data
      };
    }
  }
  return null;
}

/**
 * Get the EXE code section.
 *
 * @param exe NtExecutable instance.
 * @returns The section.
 */
function exeCodeSection(exe) {
  const s = exeSectionByAddress(exe, exe.newHeader.optionalHeader.baseOfCode);
  if (!s || !s.data) {
    throw new Error(`Invalid PE code section`);
  }
  return {
    info: s.info,
    data: s.data
  };
}

/**
 * Assert the given section is last section.
 *
 * @param exe NtExecutable instance.
 * @param index ImageDirectory index.
 * @param name Friendly name for messages.
 */
function exeAssertLastSection(exe, index, name) {
  const section = exe.getSectionByEntry(index);
  if (!section) {
    throw new Error(`Missing section: ${index}:${name}`);
  }
  const allSections = exe.getAllSections();
  let last = allSections[0].info;
  for (const {
    info
  } of allSections) {
    if (info.pointerToRawData > last.pointerToRawData) {
      last = info;
    }
  }
  const {
    info
  } = section;
  if (info.pointerToRawData < last.pointerToRawData) {
    throw new Error(`Not the last section: ${index}:${name}`);
  }
}

/**
 * Removes the reloc section if exists, fails if not the last section.
 *
 * @param exe NtExecutable instance.
 * @returns Restore function.
 */
function exeRemoveReloc(exe) {
  const section = exe.getSectionByEntry(_constants.IDD_BASE_RELOCATION);
  if (!section) {
    return () => {};
  }
  const {
    size
  } = exe.newHeader.optionalHeaderDataDirectory.get(_constants.IDD_BASE_RELOCATION);
  exeAssertLastSection(exe, _constants.IDD_BASE_RELOCATION, '.reloc');
  exe.setSectionByEntry(_constants.IDD_BASE_RELOCATION, null);
  return () => {
    exe.setSectionByEntry(_constants.IDD_BASE_RELOCATION, section);
    const {
      virtualAddress
    } = exe.newHeader.optionalHeaderDataDirectory.get(_constants.IDD_BASE_RELOCATION);
    exe.newHeader.optionalHeaderDataDirectory.set(_constants.IDD_BASE_RELOCATION, {
      virtualAddress,
      size
    });
  };
}

/**
 * Update the sizes in EXE headers.
 *
 * @param exe NtExecutable instance.
 */
function exeUpdateSizes(exe) {
  const {
    optionalHeader
  } = exe.newHeader;
  const {
    fileAlignment
  } = optionalHeader;
  let sizeOfCode = 0;
  let sizeOfInitializedData = 0;
  let sizeOfUninitializedData = 0;
  for (const {
    info: {
      characteristics,
      sizeOfRawData,
      virtualSize
    }
  } of exe.getAllSections()) {
    // eslint-disable-next-line no-bitwise
    if (characteristics & _constants.IMAGE_SCN_CNT_CODE) {
      sizeOfCode += sizeOfRawData;
    }
    // eslint-disable-next-line no-bitwise
    if (characteristics & _constants.IMAGE_SCN_CNT_INITIALIZED_DATA) {
      sizeOfInitializedData += Math.max(sizeOfRawData, (0, _data.align)(virtualSize, fileAlignment));
    }
    // eslint-disable-next-line no-bitwise
    if (characteristics & _constants.IMAGE_SCN_CNT_UNINITIALIZED_DATA) {
      sizeOfUninitializedData += (0, _data.align)(virtualSize, fileAlignment);
    }
  }
  optionalHeader.sizeOfCode = sizeOfCode;
  optionalHeader.sizeOfInitializedData = sizeOfInitializedData;
  optionalHeader.sizeOfUninitializedData = sizeOfUninitializedData;
}
//# sourceMappingURL=exe.js.map