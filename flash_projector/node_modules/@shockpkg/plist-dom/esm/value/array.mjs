import { INDENT_STRING, NEWLINE_STRING } from "../options.mjs";
import { assertXmlTagName, xmlElementChildElements } from "../util.mjs";
import { Value } from "../value.mjs";
import { ValueBoolean } from "./boolean.mjs";
import { ValueData } from "./data.mjs";
import { ValueDict } from "./dict.mjs";
import { ValueInteger } from "./integer.mjs";
import { ValueReal } from "./real.mjs";
import { ValueString } from "./string.mjs";
let childTagNames;

/**
 * ValueArray object.
 */
export class ValueArray extends Value {
  /**
   * Value type.
   */
  static TYPE = 'array';

  /**
   * Tag names.
   */
  static TAG_NAMES = ['array'];

  /**
   * Child tag names.
   *
   * @returns Child tag names map.
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static get CHILD_TAG_NAMES() {
    if (!childTagNames) {
      childTagNames = new Map();
      for (const ValueType of [ValueArray, ValueBoolean, ValueData, ValueDict, ValueInteger, ValueReal, ValueString]) {
        for (const t of ValueType.TAG_NAMES) {
          childTagNames.set(t, ValueType);
        }
      }
    }
    return childTagNames;
  }

  /**
   * Value value.
   */
  value = [];

  /**
   * ValueArray constructor.
   *
   * @param value The value.
   */
  constructor(value = []) {
    super();
    this.value = value;
  }

  /**
   * Array length.
   *
   * @returns The length.
   */
  get length() {
    return this.value.length;
  }

  /**
   * Get value at index or null if out of bounds.
   *
   * @param index Array index.
   * @returns The value or null.
   */
  get(index) {
    const {
      value
    } = this;
    return index < this.length ? value[index] : null;
  }

  /**
   * Get value at index or throw.
   *
   * @param index Array index.
   * @returns The value.
   */
  getValue(index) {
    const r = this.get(index);
    if (!r) {
      throw new Error(`Index out of bounds: ${index}`);
    }
    return r;
  }

  /**
   * Set value at index.
   *
   * @param index Array index.
   * @param value Value object.
   */
  set(index, value) {
    this.value[index] = value;
  }

  /**
   * Push values onto array.
   *
   * @param values Value objects.
   */
  push(...values) {
    this.value.push(...values);
  }

  /**
   * Pop value off array or null.
   *
   * @returns Value object or null.
   */
  pop() {
    return this.value.pop() || null;
  }

  /**
   * Pop value off array or throw.
   *
   * @returns Value object or null.
   */
  popValue() {
    const r = this.pop();
    if (!r) {
      throw new Error('Cannot pop empty array');
    }
    return r;
  }

  /**
   * Shift value off array or null.
   *
   * @returns Value object or null.
   */
  shift() {
    return this.value.shift() || null;
  }

  /**
   * Pop value off array or throw.
   *
   * @returns Value object or null.
   */
  shiftValue() {
    const r = this.shift();
    if (!r) {
      throw new Error('Cannot shift empty array');
    }
    return r;
  }

  /**
   * @inheritdoc
   */
  fromXmlElement(element) {
    assertXmlTagName(element, 'array');
    const children = xmlElementChildElements(element);
    this.value = children.map(el => this.childFromXmlElement(el));
  }

  /**
   * Decode child element from XML element.
   *
   * @param element XML element.
   * @returns Value element.
   */
  childFromXmlElement(element) {
    const {
      tagName
    } = element;
    const {
      CHILD_TAG_NAMES
    } = this.constructor;
    const Value = CHILD_TAG_NAMES.get(tagName) || null;
    if (!Value) {
      throw new Error(`Unknown element type: ${tagName}`);
    }
    const r = new Value();
    r.fromXmlElement(element);
    return r;
  }

  /**
   * @inheritdoc
   */
  toXml(options = null, depth = 0) {
    const n = options?.newlineString ?? NEWLINE_STRING;
    const p = (options?.indentString ?? INDENT_STRING).repeat(depth);
    const v = this.value;
    if (!v.length) {
      return `${p}<array/>`;
    }
    let r = `${p}<array>`;
    for (const el of v) {
      r += `${n}${el.toXml(options, depth + 1)}`;
    }
    r += `${n}${p}</array>`;
    return r;
  }
}
//# sourceMappingURL=array.mjs.map