import { INDENT_STRING, NEWLINE_STRING } from "../options.mjs";
import { assertXmlTagName, xmlElementChildElements, xmlElementText } from "../util.mjs";
import { Value } from "../value.mjs";
import { ValueArray } from "./array.mjs";
import { ValueBoolean } from "./boolean.mjs";
import { ValueData } from "./data.mjs";
import { ValueInteger } from "./integer.mjs";
import { ValueReal } from "./real.mjs";
import { ValueString } from "./string.mjs";
let childTagNames;

/**
 * ValueDict object.
 */
export class ValueDict extends Value {
  /**
   * Value type.
   */
  static TYPE = 'dict';

  /**
   * Tag names.
   */
  static TAG_NAMES = ['dict'];

  /**
   * Child tag names.
   *
   * @returns Child tag names map.
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static get CHILD_TAG_NAMES() {
    if (!childTagNames) {
      childTagNames = new Map();
      for (const ValueType of [ValueArray, ValueBoolean, ValueData, ValueDict, ValueInteger, ValueReal, ValueString]) {
        for (const t of ValueType.TAG_NAMES) {
          childTagNames.set(t, ValueType);
        }
      }
    }
    return childTagNames;
  }

  /**
   * Value value.
   */
  value = new Map();

  /**
   * ValueDict constructor.
   *
   * @param value The value.
   */
  constructor(value = new Map()) {
    super();
    this.value = value;
  }

  /**
   * Dictionary size.
   *
   * @returns The size.
   */
  get size() {
    return this.value.size;
  }

  /**
   * Check if key exists.
   *
   * @param key Dictionary key.
   * @returns The value or null.
   */
  has(key) {
    return this.value.has(key);
  }

  /**
   * Get value for key or null if does not exist.
   *
   * @param key Dictionary key.
   * @returns The value or null.
   */
  get(key) {
    return this.value.get(key) || null;
  }

  /**
   * Get value for key or throw.
   *
   * @param key Dictionary key.
   * @returns The value.
   */
  getValue(key) {
    const r = this.get(key);
    if (!r) {
      throw new Error(`Key is null: ${key}`);
    }
    return r;
  }

  /**
   * Set value for key.
   *
   * @param key Dictionary key.
   * @param value Value object.
   */
  set(key, value) {
    this.value.set(key, value);
  }

  /**
   * Delete value for key.
   *
   * @param key Dictionary key.
   */
  delete(key) {
    this.value.delete(key);
  }

  /**
   * Clear dictionary.
   */
  clear() {
    this.value.clear();
  }

  /**
   * @inheritdoc
   */
  fromXmlElement(element) {
    assertXmlTagName(element, 'dict');
    const children = xmlElementChildElements(element);
    const l = children.length;
    if (l % 2) {
      throw new Error(`Uneven number of child elements: ${l}`);
    }
    const v = new Map();
    for (let i = 0; i < l; i += 2) {
      const eK = children[i];
      const eV = children[i + 1];
      assertXmlTagName(eK, 'key');
      const key = xmlElementText(eK)?.nodeValue || '';
      const value = this.childFromXmlElement(eV);
      v.set(key, value);
    }
    this.value = v;
  }

  /**
   * Decode child element from XML element.
   *
   * @param element XML element.
   * @returns Value element.
   */
  childFromXmlElement(element) {
    const {
      tagName
    } = element;
    const {
      CHILD_TAG_NAMES
    } = this.constructor;
    const Value = CHILD_TAG_NAMES.get(tagName) || null;
    if (!Value) {
      throw new Error(`Unknown element type: ${tagName}`);
    }
    const r = new Value();
    r.fromXmlElement(element);
    return r;
  }

  /**
   * @inheritdoc
   */
  toXml(options = null, depth = 0) {
    const i = options?.indentString ?? INDENT_STRING;
    const n = options?.newlineString ?? NEWLINE_STRING;
    const p = i.repeat(depth);
    const v = this.value;
    if (!v.size) {
      return `${p}<dict/>`;
    }
    const p2 = i.repeat(depth + 1);
    let r = `${p}<dict>`;
    for (const [key, val] of v) {
      const e = key.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;');
      r += `${n}${p2}<key>${e}</key>${n}${val.toXml(options, depth + 1)}`;
    }
    r += `${n}${p}</dict>`;
    return r;
  }
}
//# sourceMappingURL=dict.mjs.map