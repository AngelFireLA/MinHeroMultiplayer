import { INDENT_STRING } from "../options.mjs";
import { assertXmlTagName, xmlElementText } from "../util.mjs";
import { Value } from "../value.mjs";
const MAX_NUM = 0x1fffffffffffff;

/**
 * Assert number is integer.
 *
 * @param value Number value.
 */
function assertInteger(value) {
  if (typeof value === 'number' && !Number.isInteger(value)) {
    // eslint-disable-next-line unicorn/prefer-type-error
    throw new Error(`Value not an integer: ${value}`);
  }
}

/**
 * ValueInteger object.
 */
export class ValueInteger extends Value {
  /**
   * Value type.
   */
  static TYPE = 'integer';

  /**
   * Tag names.
   */
  static TAG_NAMES = ['integer'];

  /**
   * Value value.
   */
  value = 0;

  /**
   * ValueInteger constructor.
   *
   * @param value The value.
   */
  constructor(value = 0) {
    super();
    assertInteger(value);
    this.value = value;
  }

  /**
   * Get value as BigInt.
   *
   * @returns Value as a BigInt.
   */
  asBigInt() {
    return BigInt(this.value);
  }

  /**
   * Get value as Number, possibly losing some precision.
   *
   * @returns Value as a Number.
   */
  asNumber() {
    return Number(this.value);
  }

  /**
   * @inheritdoc
   */
  fromXmlElement(element) {
    assertXmlTagName(element, 'integer');
    const text = xmlElementText(element)?.nodeValue || '';
    if (!/^[+-]?\d+$/.test(text)) {
      throw new Error(`Invalid integer data: ${text}`);
    }
    const num = +text;
    this.value = num > MAX_NUM || num < -MAX_NUM ? BigInt(text) : num;
  }

  /**
   * @inheritdoc
   */
  toXml(options = null, depth = 0) {
    const p = (options?.indentString ?? INDENT_STRING).repeat(depth);
    const v = this.value;
    assertInteger(v);
    return `${p}<integer>${v}</integer>`;
  }
}
//# sourceMappingURL=integer.mjs.map