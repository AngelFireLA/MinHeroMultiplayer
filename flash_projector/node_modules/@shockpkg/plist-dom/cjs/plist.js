"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Plist = void 0;
var _options = require("./options.js");
var _util = require("./util.js");
var _dict = require("./value/dict.js");
const xmlDeclaration = '<?xml version="1.0" encoding="UTF-8"?>';
const xmlDoctype = '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">';

/**
 * Plist object.
 */
class Plist {
  /**
   * Default XML declaration.
   */
  static XML_DECLARATION = xmlDeclaration;

  /**
   * Default XML doctype.
   */
  static XML_DOCTYPE = xmlDoctype;

  /**
   * XML declaration.
   */
  xmlDeclaration = xmlDeclaration;

  /**
   * XML doctype.
   */
  xmlDoctype = xmlDoctype;

  /**
   * Value element.
   */
  value = null;

  /**
   * Plist constructor.
   *
   * @param value The value.
   */
  constructor(value = null) {
    this.value = value;
  }

  /**
   * Get value or throw if null.
   *
   * @returns The value.
   */
  getValue() {
    const {
      value
    } = this;
    if (!value) {
      throw new Error('Value is null');
    }
    return value;
  }

  /**
   * Cast to specific type or null.
   *
   * @param Type Type constructor.
   * @returns The object or null.
   */
  valueCastTo(Type) {
    const {
      value
    } = this;
    return value ? value.castTo(Type) : null;
  }

  /**
   * Cast to specific type or throw.
   *
   * @param Type Type constructor.
   * @returns The object.
   */
  valueCastAs(Type) {
    const casted = this.valueCastTo(Type);
    if (!casted) {
      throw new Error(`Cannot cast value to type '${Type.TYPE}'`);
    }
    return casted;
  }

  /**
   * Decode document from string.
   *
   * @param xml XML string.
   */
  fromXml(xml) {
    const {
      declaration,
      doctype,
      documentElement
    } = (0, _util.xmlDecode)(xml);
    this.fromXmlElement(documentElement, declaration, doctype);
  }

  /**
   * Decode document from element.
   *
   * @param element XML element.
   * @param declaration XML declaration.
   * @param doctype XML doctype.
   */
  fromXmlElement(element, declaration = null, doctype = null) {
    const {
      tagName
    } = element;
    if (tagName !== 'plist') {
      throw new Error(`Unexpected root plist tag name: ${tagName}`);
    }
    const childElements = (0, _util.xmlElementChildElements)(element);
    const childElementsL = childElements.length;
    if (childElementsL > 1) {
      throw new Error(`Multiple root plist child tag: ${childElementsL}`);
    }
    this.value = childElementsL ? this.childFromXmlElement(childElements[0]) : null;
    this.xmlDeclaration = declaration || '';
    this.xmlDoctype = doctype || '';
  }

  /**
   * Decode child element from XML element.
   *
   * @param element XML element.
   * @returns Value element.
   */
  childFromXmlElement(element) {
    const a = new _dict.ValueDict();
    return a.childFromXmlElement(element);
  }

  /**
   * Encode documents to string.
   *
   * @param options Options object.
   * @returns XML string.
   */
  toXml(options = null) {
    const ir = options?.indentRoot ?? _options.INDENT_ROOT;
    const n = options?.newlineString ?? _options.NEWLINE_STRING;
    const v = this.value;
    return [...[this.xmlDeclaration, this.xmlDoctype].filter(Boolean), '<plist version="1.0">', ...(v ? [v.toXml(options, ir ? 1 : 0)] : []), '</plist>', ''].join(n);
  }
}
exports.Plist = Plist;
//# sourceMappingURL=plist.js.map