"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ValueArray = void 0;
var _options = require("../options.js");
var _util = require("../util.js");
var _value = require("../value.js");
var _boolean = require("./boolean.js");
var _data = require("./data.js");
var _dict = require("./dict.js");
var _integer = require("./integer.js");
var _real = require("./real.js");
var _string = require("./string.js");
let childTagNames;

/**
 * ValueArray object.
 */
class ValueArray extends _value.Value {
  /**
   * Value type.
   */
  static TYPE = 'array';

  /**
   * Tag names.
   */
  static TAG_NAMES = ['array'];

  /**
   * Child tag names.
   *
   * @returns Child tag names map.
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static get CHILD_TAG_NAMES() {
    if (!childTagNames) {
      childTagNames = new Map();
      for (const ValueType of [ValueArray, _boolean.ValueBoolean, _data.ValueData, _dict.ValueDict, _integer.ValueInteger, _real.ValueReal, _string.ValueString]) {
        for (const t of ValueType.TAG_NAMES) {
          childTagNames.set(t, ValueType);
        }
      }
    }
    return childTagNames;
  }

  /**
   * Value value.
   */
  value = [];

  /**
   * ValueArray constructor.
   *
   * @param value The value.
   */
  constructor(value = []) {
    super();
    this.value = value;
  }

  /**
   * Array length.
   *
   * @returns The length.
   */
  get length() {
    return this.value.length;
  }

  /**
   * Get value at index or null if out of bounds.
   *
   * @param index Array index.
   * @returns The value or null.
   */
  get(index) {
    const {
      value
    } = this;
    return index < this.length ? value[index] : null;
  }

  /**
   * Get value at index or throw.
   *
   * @param index Array index.
   * @returns The value.
   */
  getValue(index) {
    const r = this.get(index);
    if (!r) {
      throw new Error(`Index out of bounds: ${index}`);
    }
    return r;
  }

  /**
   * Set value at index.
   *
   * @param index Array index.
   * @param value Value object.
   */
  set(index, value) {
    this.value[index] = value;
  }

  /**
   * Push values onto array.
   *
   * @param values Value objects.
   */
  push(...values) {
    this.value.push(...values);
  }

  /**
   * Pop value off array or null.
   *
   * @returns Value object or null.
   */
  pop() {
    return this.value.pop() || null;
  }

  /**
   * Pop value off array or throw.
   *
   * @returns Value object or null.
   */
  popValue() {
    const r = this.pop();
    if (!r) {
      throw new Error('Cannot pop empty array');
    }
    return r;
  }

  /**
   * Shift value off array or null.
   *
   * @returns Value object or null.
   */
  shift() {
    return this.value.shift() || null;
  }

  /**
   * Pop value off array or throw.
   *
   * @returns Value object or null.
   */
  shiftValue() {
    const r = this.shift();
    if (!r) {
      throw new Error('Cannot shift empty array');
    }
    return r;
  }

  /**
   * @inheritdoc
   */
  fromXmlElement(element) {
    (0, _util.assertXmlTagName)(element, 'array');
    const children = (0, _util.xmlElementChildElements)(element);
    this.value = children.map(el => this.childFromXmlElement(el));
  }

  /**
   * Decode child element from XML element.
   *
   * @param element XML element.
   * @returns Value element.
   */
  childFromXmlElement(element) {
    const {
      tagName
    } = element;
    const {
      CHILD_TAG_NAMES
    } = this.constructor;
    const Value = CHILD_TAG_NAMES.get(tagName) || null;
    if (!Value) {
      throw new Error(`Unknown element type: ${tagName}`);
    }
    const r = new Value();
    r.fromXmlElement(element);
    return r;
  }

  /**
   * @inheritdoc
   */
  toXml(options = null, depth = 0) {
    const n = options?.newlineString ?? _options.NEWLINE_STRING;
    const p = (options?.indentString ?? _options.INDENT_STRING).repeat(depth);
    const v = this.value;
    if (!v.length) {
      return `${p}<array/>`;
    }
    let r = `${p}<array>`;
    for (const el of v) {
      r += `${n}${el.toXml(options, depth + 1)}`;
    }
    r += `${n}${p}</array>`;
    return r;
  }
}
exports.ValueArray = ValueArray;
//# sourceMappingURL=array.js.map