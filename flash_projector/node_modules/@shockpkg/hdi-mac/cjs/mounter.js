"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Mounter = void 0;
var _nodeChild_process = require("node:child_process");
var _plistDom = require("@shockpkg/plist-dom");
/**
 * Mounter object.
 */
class Mounter {
  /**
   * The path to hdiutil.
   */

  /**
   * Mounter constructor.
   *
   * @param options Options object.
   */
  constructor(options = null) {
    this.hdiutil = (options ? options.hdiutil : null) || 'hdiutil';
  }

  /**
   * Attach a disk image.
   *
   * @param file Path to disk image.
   * @param options Options object.
   * @param ejectOnExit Eject on exit options, or null.
   * @returns Info object.
   */
  async attach(file, options = null, ejectOnExit = null) {
    const devices = await this._runAttach(this._argsAttach(file, options));
    const {
      eject,
      ejectSync
    } = this._createEjects(devices);
    return {
      devices,
      eject,
      ejectSync
    };
  }

  /**
   * Attach a disk image.
   *
   * @param file Path to disk image.
   * @param options Options object.
   * @param ejectOnExit Eject on exit options, or null.
   * @returns Info object.
   */
  attachSync(file, options = null, ejectOnExit = null) {
    // eslint-disable-next-line no-sync
    const devices = this._runAttachSync(this._argsAttach(file, options));
    const {
      eject,
      ejectSync
    } = this._createEjects(devices);
    return {
      devices,
      eject,
      ejectSync
    };
  }

  /**
   * Eject a disk image.
   *
   * @param file Path to device file or volume mount point.
   * @param options Options object.
   */
  async eject(file, options = null) {
    await this._runEject(this._argsEject(file, options));
  }

  /**
   * Eject a disk image.
   *
   * @param file Path to device file or volume mount point.
   * @param options Options object.
   */
  ejectSync(file, options = null) {
    // eslint-disable-next-line no-sync
    this._runEjectSync(this._argsEject(file, options));
  }

  /**
   * Create args for attach.
   *
   * @param file Path to disk image.
   * @param options Options object.
   * @returns Argument list.
   */
  _argsAttach(file, options = null) {
    const args = ['attach', '-plist'];
    if (options) {
      if (options.readonly) {
        args.push('-readonly');
      }
      if (options.nobrowse) {
        args.push('-nobrowse');
      }
    }
    args.push(this._fileArg(file));
    return args;
  }

  /**
   * Create args for eject.
   *
   * @param file Path to device file or volume mount point.
   * @param options Options object.
   * @returns Argument list.
   */
  _argsEject(file, options = null) {
    const args = ['eject'];
    if (options && options.force) {
      args.push('-force');
    }
    args.push(this._fileArg(file));
    return args;
  }

  /**
   * Run hdiutil attach command, returning the devices list on success.
   *
   * @param args CLI args.
   * @returns Devices list.
   */
  async _runAttach(args) {
    const stdouts = [];
    const proc = (0, _nodeChild_process.spawn)(this.hdiutil, args);
    proc.stdout.on('data', data => {
      stdouts.push(data);
    });
    const code = await new Promise((resolve, reject) => {
      proc.once('exit', resolve);
      proc.once('error', reject);
    });
    if (code) {
      throw new Error(`Attach failed: hdiutil exit code: ${code}`);
    }
    return this._parseDevices(Buffer.concat(stdouts).toString());
  }

  /**
   * Run hdiutil attach command, returning the devices list on success.
   *
   * @param args CLI args.
   * @returns Devices list.
   */
  _runAttachSync(args) {
    const {
      status,
      error,
      stdout
    } = (0, _nodeChild_process.spawnSync)(this.hdiutil, args);
    if (error) {
      throw error;
    }
    if (status) {
      throw new Error(`Attach failed: hdiutil exit code: ${status}`);
    }
    return this._parseDevices(stdout.toString());
  }

  /**
   * Run hdiutil eject command.
   *
   * @param args CLI args.
   */
  async _runEject(args) {
    const proc = (0, _nodeChild_process.spawn)(this.hdiutil, args);
    const status = await new Promise((resolve, reject) => {
      proc.once('exit', resolve);
      proc.once('error', reject);
    });
    if (status) {
      throw new Error(`Eject failed: hdiutil exit code: ${status}`);
    }
  }

  /**
   * Run hdiutil eject command.
   *
   * @param args CLI args.
   */
  _runEjectSync(args) {
    const {
      status,
      error
    } = (0, _nodeChild_process.spawnSync)(this.hdiutil, args);
    if (error) {
      throw error;
    }
    if (status) {
      throw new Error(`Eject failed: hdiutil exit code: ${status}`);
    }
  }

  /**
   * Create file argument from file path.
   *
   * @param file File path.
   * @returns A path for use as argument.
   */
  _fileArg(file) {
    // Make sure it will not be recognized as option argument.
    return file.startsWith('-') ? `./${file}` : file;
  }

  /**
   * Parse devices plist into devices list.
   *
   * @param xml XML plist.
   * @returns Devices list.
   */
  _parseDevices(xml) {
    const plist = new _plistDom.Plist();
    plist.fromXml(xml);
    const systemEntities = plist.valueCastAs(_plistDom.ValueDict).getValue('system-entities').castAs(_plistDom.ValueArray);
    const r = [];
    for (const value of systemEntities.value) {
      const dict = value.castAs(_plistDom.ValueDict);
      const devEntry = dict.getValue('dev-entry').castAs(_plistDom.ValueString).value;
      const potentiallyMountable = dict.getValue('potentially-mountable').castAs(_plistDom.ValueBoolean).value;
      const contentHint = dict.get('content-hint');
      const unmappedContentHint = dict.get('unmapped-content-hint');
      const volumeKind = dict.get('volume-kind');
      const mountPoint = dict.get('mount-point');
      const device = {
        devEntry,
        potentiallyMountable
      };
      if (contentHint) {
        device.contentHint = contentHint.castAs(_plistDom.ValueString).value;
      }
      if (unmappedContentHint) {
        device.unmappedContentHint = unmappedContentHint.castAs(_plistDom.ValueString).value;
      }
      if (volumeKind) {
        device.volumeKind = volumeKind.castAs(_plistDom.ValueString).value;
      }
      if (mountPoint) {
        device.mountPoint = mountPoint.castAs(_plistDom.ValueString).value;
      }
      r.push(device);
    }
    return r;
  }

  /**
   * Find the root device, null on empty list.
   *
   * @param devices Device list.
   * @returns Root device or null if an empty list.
   */
  _findRootDevice(devices) {
    let r = null;
    for (const device of devices) {
      if (r === null || r.devEntry.length > device.devEntry.length) {
        r = device;
      }
    }
    return r;
  }

  /**
   * Create ejects callback from a list of devices.
   *
   * @param devices Device list.
   * @param ejectOnExit Eject on exit options, or null.
   * @returns Callback function.
   */
  _createEjects(devices, ejectOnExit = null) {
    // Find the root device, to use to eject (none possible in theory).
    let devEntry = this._findRootDevice(devices)?.devEntry;
    let shutdown = null;
    const info = {
      /**
       * The eject callback function.
       *
       * @param options Eject options.
       */
      eject: async (options = null) => {
        if (devEntry) {
          await this.eject(devEntry, options);
          devEntry = '';
          if (shutdown) {
            process.off('exit', shutdown);
          }
        }
      },
      /**
       * The eject callback function.
       *
       * @param options Eject options.
       */
      ejectSync: (options = null) => {
        if (devEntry) {
          // eslint-disable-next-line no-sync
          this.ejectSync(devEntry, options);
          devEntry = '';
          if (shutdown) {
            process.off('exit', shutdown);
          }
        }
      }
    };
    if (ejectOnExit) {
      /**
       * Attempt to auto-eject on normal shutdown.
       * Does not catch signals (no clean way in a library).
       * Users can explicitly call process.exit() on signals to use this.
       */
      shutdown = () => {
        // eslint-disable-next-line no-sync
        info.ejectSync(ejectOnExit);
      };
      process.once('exit', shutdown);
    }
    return info;
  }
}
exports.Mounter = Mounter;
//# sourceMappingURL=mounter.js.map