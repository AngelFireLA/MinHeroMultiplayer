/* eslint-disable max-classes-per-file */

import { createReadStream } from 'node:fs';
import { join as pathJoin } from 'node:path';
import { Archive, Entry } from "../archive.mjs";
import { PathType } from "../types.mjs";
import { fsLstat, fsLstatExists, fsReadlinkRaw, fsWalk, pathNormalize, pathResourceFork, statToPathType } from "../util.mjs";
const walkOpts = {
  ignoreUnreadableDirectories: true
};
/**
 * EntryDir object.
 */
export class EntryDir extends Entry {
  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */
  sizeComp = null;

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */
  uname = null;

  /**
   * @inheritdoc
   */
  gname = null;

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * EntryDir constructor.
   *
   * @param info Info object.
   */
  constructor(info) {
    super(info);
    this.archive = info.archive;
    this.size = info.size;
    this.mode = info.mode;
    this.uid = info.uid;
    this.gid = info.gid;
    this.atime = info.atime;
    this.mtime = info.mtime;
  }

  /**
   * Get the path of resource psuedo-file, raw.
   *
   * @returns Path string.
   */
  get rsrcPathRaw() {
    return pathResourceFork(this.pathRaw);
  }

  /**
   * Get the path of resource psuedo-file, normalized.
   *
   * @returns Path string.
   */
  get rsrcPath() {
    return pathNormalize(pathResourceFork(this.path));
  }
}

/**
 * ArchiveDir object.
 */
export class ArchiveDir extends Archive {
  /**
   * @inheritdoc
   */
  static FILE_EXTENSIONS = null;

  /**
   * @inheritdoc
   */
  Entry = EntryDir;

  /**
   * Limit the directory reading to subpaths.
   */
  subpaths = null;

  /**
   * ArchiveDir constructor.
   *
   * @param path File path.
   */
  constructor(path) {
    super(path);
  }

  /**
   * @inheritdoc
   */
  async read(itter) {
    await super.read(itter);
  }

  /**
   * @inheritdoc
   */
  async _read(itter) {
    /**
     * Each itterator.
     *
     * @param pathFull Full path.
     * @param pathRaw Raw path.
     * @param stat Stat object.
     * @returns Recursion hint.
     */
    const each = async (pathFull, pathRaw, stat) => {
      const type = statToPathType(stat);
      if (type === null) {
        return true;
      }
      const {
        size,
        mode,
        uid,
        gid,
        atime,
        mtime
      } = stat;
      const readData = type === PathType.FILE ? async () => createReadStream(pathFull) : null;
      const readSymlink = type === PathType.SYMLINK ? async () => fsReadlinkRaw(pathFull) : null;
      const entry = new this.Entry({
        archive: this,
        type,
        pathRaw,
        size,
        mode,
        uid,
        gid,
        atime,
        mtime,
        readData,
        readSymlink
      });
      const ret = await entry.trigger(itter);
      if (ret === false) {
        return null;
      }
      if (ret === null) {
        return false;
      }
      if (type === PathType.FILE) {
        const rsrcPathFull = pathResourceFork(pathFull);
        const rsrcStat = await fsLstatExists(rsrcPathFull);
        if (rsrcStat) {
          const sizeRsrc = rsrcStat.size;

          /**
           * Read RSRC.
           *
           * @returns Read stream.
           */
          const readRsrc = async () => createReadStream(rsrcPathFull);
          const entryRsrc = new this.Entry({
            archive: this,
            type: PathType.RESOURCE_FORK,
            pathRaw,
            size: sizeRsrc,
            mode,
            uid,
            gid,
            atime,
            mtime,
            readRsrc
          });
          const ret = await entryRsrc.trigger(itter);
          if (ret === false) {
            return null;
          }
          if (ret === null) {
            return false;
          }
        }
      }
      return true;
    };
    const {
      path,
      subpaths
    } = this;
    if (subpaths) {
      for (const subpath of subpaths) {
        // eslint-disable-next-line no-await-in-loop
        const stat = await fsLstat(pathJoin(path, subpath));

        // eslint-disable-next-line no-await-in-loop
        await each(pathJoin(path, subpath), subpath, stat);
        if (stat.isDirectory()) {
          // eslint-disable-next-line no-await-in-loop
          await fsWalk(pathJoin(path, subpath), async (pathRel, stat) => {
            const pathFull = pathJoin(path, subpath, pathRel);
            return each(pathFull, pathJoin(subpath, pathRel), stat);
          }, walkOpts);
        }
      }
      return;
    }
    await fsWalk(path, async (pathRel, stat) => {
      const pathFull = pathJoin(path, pathRel);
      return each(pathFull, pathRel, stat);
    }, walkOpts);
  }
}
//# sourceMappingURL=dir.mjs.map