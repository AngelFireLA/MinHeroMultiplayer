/* eslint-disable max-classes-per-file */

import { createReadStream } from 'node:fs';
import { basename, join as pathJoin } from 'node:path';
import { Mounter } from '@shockpkg/hdi-mac';
import { Archive, Entry } from "../archive.mjs";
import { PathType } from "../types.mjs";
import { fsLstatExists, fsReadlinkRaw, fsWalk, pathNormalize, pathResourceFork, statToPathType } from "../util.mjs";
const walkOpts = {
  ignoreUnreadableDirectories: true
};
const ejectOptions = {
  force: true
};
/**
 * EntryHdi object.
 */
export class EntryHdi extends Entry {
  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */
  sizeComp = null;

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */
  uname = null;

  /**
   * @inheritdoc
   */
  gname = null;

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * EntryHdi constructor.
   *
   * @param info Info object.
   */
  constructor(info) {
    super(info);
    this.archive = info.archive;
    this.size = info.size;
    this.mode = info.mode;
    this.uid = info.uid;
    this.gid = info.gid;
    this.atime = info.atime;
    this.mtime = info.mtime;
  }

  /**
   * Get the path of resource psuedo-file, raw.
   *
   * @returns Path string.
   */
  get rsrcPathRaw() {
    return pathResourceFork(this.pathRaw);
  }

  /**
   * Get the path of resource psuedo-file, normalized.
   *
   * @returns Path string.
   */
  get rsrcPath() {
    return pathNormalize(pathResourceFork(this.path));
  }
}

/**
 * ArchiveHdi object.
 */
export class ArchiveHdi extends Archive {
  /**
   * @inheritdoc
   */
  static FILE_EXTENSIONS = ['.dmg', '.iso', '.cdr'];

  /**
   * @inheritdoc
   */
  static HAS_NAMED_VOLUMES = true;

  /**
   * @inheritdoc
   */
  Entry = EntryHdi;

  /**
   * Mounter, Mac.
   */
  mounterMac = new Mounter();

  /**
   * Hide mounted disk image from the file explorers.
   */
  nobrowse = false;

  /**
   * ArchiveHdi constructor.
   *
   * @param path File path.
   */
  constructor(path) {
    super(path);
  }

  /**
   * @inheritdoc
   */
  async read(itter) {
    await super.read(itter);
  }

  /**
   * @inheritdoc
   */
  async _read(itter) {
    const {
      mounterMac,
      nobrowse
    } = this;

    /**
     * Each itterator.
     *
     * @param pathFull Full path.
     * @param pathRaw Raw path.
     * @param stat Stat object.
     * @returns Recursion hint.
     */
    const each = async (pathFull, pathRaw, stat) => {
      const type = statToPathType(stat);
      if (type === null) {
        return true;
      }
      const {
        size,
        mode,
        uid,
        gid,
        atime,
        mtime
      } = stat;
      const readData = type === PathType.FILE ? async () => createReadStream(pathFull) : null;
      const readSymlink = type === PathType.SYMLINK ? async () => fsReadlinkRaw(pathFull) : null;
      const entry = new this.Entry({
        archive: this,
        type,
        pathRaw,
        size,
        mode,
        uid,
        gid,
        atime,
        mtime,
        readData,
        readSymlink
      });
      const ret = await entry.trigger(itter);
      if (ret === false) {
        return null;
      }
      if (ret === null) {
        return false;
      }
      if (type === PathType.FILE) {
        const rsrcPathFull = pathResourceFork(pathFull);
        const rsrcStat = await fsLstatExists(rsrcPathFull);
        if (rsrcStat) {
          const sizeRsrc = rsrcStat.size;

          /**
           * Read RSRC.
           *
           * @returns Read stream.
           */
          const readRsrc = async () => createReadStream(rsrcPathFull);
          const entryRsrc = new this.Entry({
            archive: this,
            type: PathType.RESOURCE_FORK,
            pathRaw,
            size: sizeRsrc,
            mode,
            uid,
            gid,
            atime,
            mtime,
            readRsrc
          });
          const ret = await entryRsrc.trigger(itter);
          if (ret === false) {
            return null;
          }
          if (ret === null) {
            return false;
          }
        }
      }
      return true;
    };

    // Using auto-eject on normal exit option.
    const info = await mounterMac.attach(this.path, {
      nobrowse,
      readonly: true
    }, ejectOptions);

    // Eject device when done.
    try {
      for (const device of info.devices) {
        const {
          mountPoint
        } = device;
        if (!mountPoint) {
          continue;
        }
        const volumeName = basename(mountPoint);
        // eslint-disable-next-line no-await-in-loop
        await fsWalk(mountPoint, async (pathRel, stat) => {
          const pathFull = pathJoin(mountPoint, pathRel);
          const pathRaw = pathJoin(volumeName, pathRel);
          return each(pathFull, pathRaw, stat);
        }, walkOpts);
      }
    } finally {
      await info.eject(ejectOptions);
    }
  }
}
//# sourceMappingURL=hdi.mjs.map