{"version":3,"file":"archive.mjs","names":["createWriteStream","mkdir","rm","writeFile","dirname","resolve","Readable","pipeline","promisify","pipe","PathType","fsChmod","fsLchmod","fsLstatExists","fsLutimes","fsSymlink","fsUtimes","modePermissionBits","pathNormalize","pathResourceFork","streamToBuffer","Entry","_triggering","_triggered","_extracted","constructor","info","archive","type","pathRaw","path","size","sizeComp","mode","uid","gid","uname","gname","atime","mtime","_readData","readData","_readRsrc","readRsrc","_readSymlink","readSymlink","hasNamedVolume","hasNamedVolumes","volumeName","slice","indexOf","volumePath","stream","_beginExtract","_stream","read","extract","options","_extract","trigger","itter","r","Error","setAttributes","pathFull","pathSet","ignorePermissions","ignoreTimes","link","FILE","RESOURCE_FORK","DIRECTORY","SYMLINK","atimeSet","mtimeSet","chmod","modeSet","utimes","_errorExtractPathExists","_errorNoResourceFork","afterReadSetAttributesRemove","_extractFile","_extractResourceFork","_extractDirectory","_extractSymlink","_extractStreamToFile","reader","replace","stat","recursive","force","Buffer","alloc","resourceForkAsFile","isFile","pathRsrc","isDirectory","afterReadSetAttributes","symlinkAsFile","target","_streamFile","_streamResourceFork","_streamDirectory","_streamSymlink","then","d","push","err","emit","Archive","FILE_EXTENSIONS","HAS_NAMED_VOLUMES","_reading","_afterReadSetAttributes","fileExtensions","entry","afters","set","delete","Map","_read","_afterReadSetAttributesTrigger","resolves","resolved","sort","a","b","length","ent","get"],"sources":["../src/archive.ts"],"sourcesContent":["/* eslint-disable max-classes-per-file */\n\nimport {createWriteStream} from 'node:fs';\nimport {mkdir, rm, writeFile} from 'node:fs/promises';\nimport {dirname, resolve} from 'node:path';\nimport {Readable, pipeline} from 'node:stream';\nimport {promisify} from 'node:util';\n\nconst pipe = promisify(pipeline);\n\nimport {PathType} from './types.ts';\nimport {\n\tfsChmod,\n\tfsLchmod,\n\tfsLstatExists,\n\tfsLutimes,\n\tfsSymlink,\n\tfsUtimes,\n\tmodePermissionBits,\n\tpathNormalize,\n\tpathResourceFork,\n\tstreamToBuffer\n} from './util.ts';\n\nexport interface IArchiveAfterReadSetAttributesEntry {\n\t/**\n\t * Extract path, relative.\n\t */\n\tpath: string;\n\n\t/**\n\t * Entry.\n\t */\n\tentry: Entry;\n\n\t/**\n\t * Extract options.\n\t */\n\toptions: IExtractOptions;\n}\n\nexport interface IExtractOptions {\n\t/**\n\t * Replace whatever may be at the path.\n\t * A directory will not replace another directory.\n\t *\n\t * @default false\n\t */\n\treplace?: boolean;\n\n\t/**\n\t * Ignore permissions when extracting.\n\t *\n\t * @default false\n\t */\n\tignorePermissions?: boolean;\n\n\t/**\n\t * Ignore file modification and access times when extracting.\n\t *\n\t * @default false\n\t */\n\tignoreTimes?: boolean;\n\n\t/**\n\t * Extract resource fork as a file.\n\t *\n\t * @default false\n\t */\n\tresourceForkAsFile?: boolean;\n\n\t/**\n\t * Extract symlink as a file.\n\t *\n\t * @default false\n\t */\n\tsymlinkAsFile?: boolean;\n}\n\nexport interface IEntryInfo {\n\t/**\n\t * Entry archive.\n\t */\n\tarchive: Archive;\n\n\t/**\n\t * Entry type.\n\t */\n\ttype: PathType;\n\n\t/**\n\t * Entry path, raw.\n\t */\n\tpathRaw: string;\n\n\t/**\n\t * Entry size.\n\t */\n\tsize?: number | null;\n\n\t/**\n\t * Entry size, compressed.\n\t */\n\tsizeComp?: number | null;\n\n\t/**\n\t * Entry mode.\n\t */\n\tmode?: number | null;\n\n\t/**\n\t * Entry uid.\n\t */\n\tuid?: number | null;\n\n\t/**\n\t * Entry gid.\n\t */\n\tgid?: number | null;\n\n\t/**\n\t * Entry uname.\n\t */\n\tuname?: string | null;\n\n\t/**\n\t * Entry gname.\n\t */\n\tgname?: string | null;\n\n\t/**\n\t * Entry atime.\n\t */\n\tatime?: Date | null;\n\n\t/**\n\t * Entry mtime.\n\t */\n\tmtime?: Date | null;\n\n\t/**\n\t * Read data.\n\t */\n\treadData?: (() => Promise<Readable | null>) | null;\n\n\t/**\n\t * Read rsrc.\n\t */\n\treadRsrc?: (() => Promise<Readable | null>) | null;\n\n\t/**\n\t * Read symlink.\n\t */\n\treadSymlink?: (() => Promise<Buffer>) | null;\n}\n\n/**\n * Entry object.\n */\nexport abstract class Entry {\n\t/**\n\t * Entry archive.\n\t */\n\tpublic readonly archive: Archive;\n\n\t/**\n\t * Entry type.\n\t */\n\tpublic readonly type: PathType;\n\n\t/**\n\t * Entry path.\n\t */\n\tpublic readonly path: string;\n\n\t/**\n\t * Entry path, raw.\n\t */\n\tpublic readonly pathRaw: string;\n\n\t/**\n\t * Entry size.\n\t */\n\tpublic readonly size: number | null;\n\n\t/**\n\t * Entry size, compressed.\n\t */\n\tpublic readonly sizeComp: number | null;\n\n\t/**\n\t * Entry mode.\n\t */\n\tpublic readonly mode: number | null;\n\n\t/**\n\t * Entry uid.\n\t */\n\tpublic readonly uid: number | null;\n\n\t/**\n\t * Entry gid.\n\t */\n\tpublic readonly gid: number | null;\n\n\t/**\n\t * Entry uname.\n\t */\n\tpublic readonly uname: string | null;\n\n\t/**\n\t * Entry gname.\n\t */\n\tpublic readonly gname: string | null;\n\n\t/**\n\t * Entry atime.\n\t */\n\tpublic readonly atime: Date | null;\n\n\t/**\n\t * Entry mtime.\n\t */\n\tpublic readonly mtime: Date | null;\n\n\t/**\n\t * Read data.\n\t */\n\tprotected readonly _readData: (() => Promise<Readable | null>) | null;\n\n\t/**\n\t * Read rsrc.\n\t */\n\tprotected readonly _readRsrc: (() => Promise<Readable | null>) | null;\n\n\t/**\n\t * Read symlink.\n\t */\n\tprotected readonly _readSymlink: (() => Promise<Buffer>) | null;\n\n\t/**\n\t * Entry triggering.\n\t */\n\tprotected _triggering = false;\n\n\t/**\n\t * Entry triggered.\n\t */\n\tprotected _triggered = false;\n\n\t/**\n\t * Entry extracted.\n\t */\n\tprotected _extracted = false;\n\n\t/**\n\t * Entry constructor.\n\t *\n\t * @param info Info object.\n\t */\n\tconstructor(info: Readonly<IEntryInfo>) {\n\t\tthis.archive = info.archive;\n\t\tthis.type = info.type;\n\t\tthis.pathRaw = info.pathRaw;\n\t\tthis.path = pathNormalize(info.pathRaw);\n\t\tthis.size = info.size ?? null;\n\t\tthis.sizeComp = info.sizeComp ?? null;\n\t\tthis.mode = info.mode ?? null;\n\t\tthis.uid = info.uid ?? null;\n\t\tthis.gid = info.gid ?? null;\n\t\tthis.uname = info.uname ?? null;\n\t\tthis.gname = info.gname ?? null;\n\t\tthis.atime = info.atime ?? null;\n\t\tthis.mtime = info.mtime ?? null;\n\t\tthis._readData = info.readData ?? null;\n\t\tthis._readRsrc = info.readRsrc ?? null;\n\t\tthis._readSymlink = info.readSymlink ?? null;\n\t}\n\n\t/**\n\t * This entry path includes named volume.\n\t *\n\t * @returns Entry has volume name in path.\n\t */\n\tpublic get hasNamedVolume() {\n\t\treturn this.archive.hasNamedVolumes;\n\t}\n\n\t/**\n\t * This entry volume name, or null.\n\t *\n\t * @returns Entry path volume name.\n\t */\n\tpublic get volumeName() {\n\t\tif (this.hasNamedVolume) {\n\t\t\tconst {path} = this;\n\t\t\treturn path.slice(0, path.indexOf('/'));\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * This entry path without any possible volume name.\n\t *\n\t * @returns Entry path without the volume name.\n\t */\n\tpublic get volumePath() {\n\t\tconst {path} = this;\n\t\tif (this.hasNamedVolume) {\n\t\t\treturn path.slice(path.indexOf('/') + 1);\n\t\t}\n\t\treturn path;\n\t}\n\n\t/**\n\t * Read entry as stream, or null if nothing to read.\n\t * Consuming function will need to wait for stream to close.\n\t *\n\t * @returns Readable stream or null if nothing to read.\n\t */\n\tpublic async stream() {\n\t\tthis._beginExtract();\n\t\treturn this._stream();\n\t}\n\n\t/**\n\t * Read entire entry into a Buffer.\n\t *\n\t * @returns Buffer or null if nothing to be read.\n\t */\n\tpublic async read() {\n\t\tthis._beginExtract();\n\t\tconst stream = await this._stream();\n\t\treturn stream ? streamToBuffer(stream) : null;\n\t}\n\n\t/**\n\t * Extract entry.\n\t *\n\t * @param path Extract path.\n\t * @param options Extract options.\n\t */\n\tpublic async extract(\n\t\tpath: string,\n\t\toptions: Readonly<IExtractOptions> = {}\n\t) {\n\t\tthis._beginExtract();\n\t\tawait this._extract(path, options);\n\t}\n\n\t/**\n\t * Trigger on itterator function.\n\t *\n\t * @param itter Itterator function.\n\t * @returns Return value.\n\t */\n\tpublic async trigger<T, U extends (entry: this) => Promise<T>>(itter: U) {\n\t\tlet r: T;\n\t\tif (this._triggered) {\n\t\t\tthrow new Error('Archive entry already triggered');\n\t\t}\n\t\tthis._triggered = this._triggering = true;\n\t\ttry {\n\t\t\tr = await itter(this);\n\t\t} finally {\n\t\t\tthis._triggering = false;\n\t\t}\n\t\treturn r;\n\t}\n\n\t/**\n\t * Run again after reading.\n\t *\n\t * @param path Extract path, relative.\n\t * @param pathFull An optional full path to be used.\n\t * @param options Extract options.\n\t */\n\tpublic async setAttributes(\n\t\tpath: string,\n\t\tpathFull: string | null = null,\n\t\toptions: Readonly<IExtractOptions> = {}\n\t) {\n\t\tconst pathSet = pathFull === null ? path : pathFull;\n\n\t\tconst {ignorePermissions, ignoreTimes} = options;\n\n\t\tconst {type, mode, atime, mtime} = this;\n\n\t\tlet link = false;\n\t\tswitch (type) {\n\t\t\tcase PathType.FILE: {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PathType.RESOURCE_FORK: {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PathType.DIRECTORY: {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PathType.SYMLINK: {\n\t\t\t\tlink = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error(`Unsupported path type: ${type as string}`);\n\t\t\t}\n\t\t}\n\n\t\tconst atimeSet = atime || mtime || null;\n\t\tconst mtimeSet = mtime || atime || null;\n\n\t\tif (!ignorePermissions && mode !== null) {\n\t\t\tconst chmod = link ? fsLchmod : fsChmod;\n\t\t\tconst modeSet = modePermissionBits(mode);\n\t\t\tawait chmod(pathSet, modeSet);\n\t\t}\n\n\t\tif (!ignoreTimes && atimeSet && mtimeSet) {\n\t\t\tconst utimes = link ? fsLutimes : fsUtimes;\n\t\t\tawait utimes(pathSet, atimeSet, mtimeSet);\n\t\t}\n\t}\n\n\t/**\n\t * Method to call before begining extraction.\n\t * Throws error if extraction already started or entry not active.\n\t */\n\tprotected _beginExtract() {\n\t\tif (!this._triggering) {\n\t\t\tthrow new Error('Archive entry is not active');\n\t\t}\n\t\tif (this._extracted) {\n\t\t\tthrow new Error('Archive entry can only be extracted once');\n\t\t}\n\t\tthis._extracted = true;\n\t}\n\n\t/**\n\t * Create an extract error for path that exists.\n\t *\n\t * @param path Extract path.\n\t * @returns Error object.\n\t */\n\tprotected _errorExtractPathExists(path: string) {\n\t\treturn new Error(`Extract path already exists: ${path}`);\n\t}\n\n\t/**\n\t * Create an extract error for a resource fork not going to a file.\n\t *\n\t * @param path Extract path.\n\t * @returns Error object.\n\t */\n\tprotected _errorNoResourceFork(path: string) {\n\t\treturn new Error(`Extract path for resource fork not a file: ${path}`);\n\t}\n\n\t/**\n\t * Extract entry.\n\t *\n\t * @param path Extract path.\n\t * @param options Extract options.\n\t */\n\tprotected async _extract(path: string, options: Readonly<IExtractOptions>) {\n\t\tthis.archive.afterReadSetAttributesRemove(path);\n\n\t\tconst {type} = this;\n\t\tswitch (type) {\n\t\t\tcase PathType.FILE: {\n\t\t\t\tawait this._extractFile(path, options);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PathType.RESOURCE_FORK: {\n\t\t\t\tawait this._extractResourceFork(path, options);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PathType.DIRECTORY: {\n\t\t\t\tawait this._extractDirectory(path, options);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PathType.SYMLINK: {\n\t\t\t\tawait this._extractSymlink(path, options);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error(`Unsupported path type: ${type as string}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Base function for extracting stream to a file.\n\t *\n\t * @param path Extract path.\n\t * @param reader Reader function.\n\t * @param options Extract options.\n\t */\n\tprotected async _extractStreamToFile(\n\t\tpath: string,\n\t\treader: () => Promise<Readable | null>,\n\t\toptions: Readonly<IExtractOptions>\n\t) {\n\t\tconst {replace} = options;\n\n\t\t// Check if something exists at path, optionally removing.\n\t\tconst stat = await fsLstatExists(path);\n\t\tif (stat) {\n\t\t\t// If replacing, then remove, else throw.\n\t\t\tif (replace) {\n\t\t\t\tawait rm(path, {recursive: true, force: true});\n\t\t\t} else {\n\t\t\t\tthrow this._errorExtractPathExists(path);\n\t\t\t}\n\t\t} else {\n\t\t\tawait mkdir(dirname(path), {recursive: true});\n\t\t}\n\n\t\t// Write file.\n\t\tawait writeFile(path, Buffer.alloc(0));\n\t\tconst stream = await reader();\n\t\tif (stream) {\n\t\t\tawait pipe(stream, createWriteStream(path));\n\t\t}\n\n\t\t// Set attributes.\n\t\tawait this.setAttributes(path, null, options);\n\t}\n\n\t/**\n\t * Extract as a file.\n\t *\n\t * @param path Extract path.\n\t * @param options Extract options.\n\t */\n\tprotected async _extractFile(\n\t\tpath: string,\n\t\toptions: Readonly<IExtractOptions>\n\t) {\n\t\tconst readData = this._readData;\n\t\tif (!readData) {\n\t\t\tthrow new Error('Internal error');\n\t\t}\n\n\t\tawait this._extractStreamToFile(path, readData, options);\n\t}\n\n\t/**\n\t * Extract as resource fork to an existing file.\n\t *\n\t * @param path Extract path.\n\t * @param options Extract options.\n\t */\n\tprotected async _extractResourceFork(\n\t\tpath: string,\n\t\toptions: Readonly<IExtractOptions>\n\t) {\n\t\tconst readRsrc = this._readRsrc;\n\t\tif (!readRsrc) {\n\t\t\tthrow new Error('Internal error');\n\t\t}\n\n\t\t// Optionally extract as a data file.\n\t\tif (options.resourceForkAsFile) {\n\t\t\tawait this._extractStreamToFile(path, readRsrc, options);\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if file exists at path, else throw.\n\t\tconst stat = await fsLstatExists(path);\n\t\tif (!stat || !stat.isFile()) {\n\t\t\tthrow this._errorNoResourceFork(path);\n\t\t}\n\n\t\t// Create resource fork path.\n\t\tconst pathRsrc = pathResourceFork(path);\n\n\t\t// Write the resource fork.\n\t\tconst stream = await readRsrc();\n\n\t\t// eslint-disable-next-line unicorn/prefer-ternary\n\t\tif (stream) {\n\t\t\tawait pipe(stream, createWriteStream(pathRsrc));\n\t\t} else {\n\t\t\tawait writeFile(pathRsrc, Buffer.alloc(0));\n\t\t}\n\n\t\t// Set attributes.\n\t\tawait this.setAttributes(path, null, options);\n\t}\n\n\t/**\n\t * Extract as a directory.\n\t *\n\t * @param path Extract path.\n\t * @param options Extract options.\n\t */\n\tprotected async _extractDirectory(\n\t\tpath: string,\n\t\toptions: Readonly<IExtractOptions>\n\t) {\n\t\tconst {replace} = options;\n\n\t\t// Check if something exists at path, else create.\n\t\tconst stat = await fsLstatExists(path);\n\t\tif (stat) {\n\t\t\t// If not directory, then remove and replace it, else throw.\n\t\t\tif (!stat.isDirectory()) {\n\t\t\t\tif (replace) {\n\t\t\t\t\tawait rm(path, {recursive: true, force: true});\n\t\t\t\t\tawait mkdir(path, {recursive: true});\n\t\t\t\t} else {\n\t\t\t\t\tthrow this._errorExtractPathExists(path);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tawait mkdir(path, {recursive: true});\n\t\t}\n\n\t\t// Set directory attributes after any children are added.\n\t\tthis.archive.afterReadSetAttributes(path, this, {...options});\n\t}\n\n\t/**\n\t * Extract as a symlink.\n\t *\n\t * @param path Extract path.\n\t * @param options Extract options.\n\t */\n\tprotected async _extractSymlink(\n\t\tpath: string,\n\t\toptions: Readonly<IExtractOptions>\n\t) {\n\t\tconst readSymlink = this._readSymlink;\n\t\tif (!readSymlink) {\n\t\t\tthrow new Error('Internal error');\n\t\t}\n\n\t\tconst {replace, symlinkAsFile} = options;\n\n\t\t// Check if something exists at path, optionally removing.\n\t\tconst stat = await fsLstatExists(path);\n\t\tif (stat) {\n\t\t\t// If replacing, then remove, else throw.\n\t\t\tif (replace) {\n\t\t\t\tawait rm(path, {recursive: true, force: true});\n\t\t\t} else {\n\t\t\t\tthrow this._errorExtractPathExists(path);\n\t\t\t}\n\t\t} else {\n\t\t\t// Ensure base directory exists.\n\t\t\tawait mkdir(dirname(path), {recursive: true});\n\t\t}\n\n\t\t// Read target.\n\t\tconst target = await readSymlink();\n\n\t\t// Create link, optionally as a file.\n\t\t// eslint-disable-next-line unicorn/prefer-ternary\n\t\tif (symlinkAsFile) {\n\t\t\tawait writeFile(path, target);\n\t\t} else {\n\t\t\tawait fsSymlink(path, target);\n\t\t}\n\n\t\t// Set attributes.\n\t\tawait this.setAttributes(path, null, options);\n\t}\n\n\t/**\n\t * Read as stream.\n\t *\n\t * @returns Readable stream.\n\t */\n\tprotected async _stream() {\n\t\tconst {type} = this;\n\t\tswitch (type) {\n\t\t\tcase PathType.FILE: {\n\t\t\t\treturn this._streamFile();\n\t\t\t}\n\t\t\tcase PathType.RESOURCE_FORK: {\n\t\t\t\treturn this._streamResourceFork();\n\t\t\t}\n\t\t\tcase PathType.DIRECTORY: {\n\t\t\t\treturn this._streamDirectory();\n\t\t\t}\n\t\t\tcase PathType.SYMLINK: {\n\t\t\t\treturn this._streamSymlink();\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error(`Unsupported path type: ${type as string}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Read file as stream.\n\t *\n\t * @returns Readable stream.\n\t */\n\tprotected async _streamFile() {\n\t\tconst readData = this._readData;\n\t\tif (!readData) {\n\t\t\tthrow new Error('Internal error');\n\t\t}\n\t\treturn readData();\n\t}\n\n\t/**\n\t * Read resource fork as stream.\n\t *\n\t * @returns Readable stream.\n\t */\n\tprotected async _streamResourceFork() {\n\t\tconst readRsrc = this._readRsrc;\n\t\tif (!readRsrc) {\n\t\t\tthrow new Error('Internal error');\n\t\t}\n\t\treturn readRsrc();\n\t}\n\n\t/**\n\t * Read directory null stream.\n\t *\n\t * @returns Null stream.\n\t */\n\tprotected async _streamDirectory() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Read symlink as stream.\n\t *\n\t * @returns Readable stream.\n\t */\n\tprotected async _streamSymlink() {\n\t\tconst readSymlink = this._readSymlink;\n\t\tif (!readSymlink) {\n\t\t\tthrow new Error('Internal error');\n\t\t}\n\t\tconst r = new Readable({\n\t\t\t// eslint-disable-next-line jsdoc/require-jsdoc\n\t\t\tread: () => {\n\t\t\t\treadSymlink().then(\n\t\t\t\t\td => {\n\t\t\t\t\t\tr.push(d);\n\t\t\t\t\t\t// eslint-disable-next-line unicorn/no-array-push-push\n\t\t\t\t\t\tr.push(null);\n\t\t\t\t\t},\n\t\t\t\t\terr => {\n\t\t\t\t\t\tr.emit('error', err);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t\treturn r;\n\t}\n}\n\n/**\n * Archive object.\n */\nexport abstract class Archive {\n\t/**\n\t * List of file extensions, or null.\n\t */\n\tpublic static readonly FILE_EXTENSIONS: readonly string[] | null = null;\n\n\t/**\n\t * Archive has named volumes that each entry will be under.\n\t */\n\tpublic static readonly HAS_NAMED_VOLUMES: boolean = false;\n\n\t/**\n\t * Entry constructor.\n\t */\n\tpublic readonly Entry = Entry;\n\n\t/**\n\t * File path.\n\t */\n\tpublic readonly path: string;\n\n\t/**\n\t * Flag for currently reading.\n\t */\n\tprotected _reading = false;\n\n\t/**\n\t * Map of entries to set attributes on after reading.\n\t */\n\tprotected _afterReadSetAttributes: Map<\n\t\tstring,\n\t\tReadonly<IArchiveAfterReadSetAttributesEntry>\n\t> | null = null;\n\n\t/**\n\t * Archive constructor.\n\t *\n\t * @param path File path.\n\t */\n\tconstructor(path: string) {\n\t\tthis.path = path;\n\t}\n\n\t/**\n\t * List of file extensions used by this format.\n\t *\n\t * @returns List of file extensions.\n\t */\n\tpublic get fileExtensions() {\n\t\treturn (this.constructor as typeof Archive).FILE_EXTENSIONS || null;\n\t}\n\n\t/**\n\t * Archive has named volumes that each entry will be under.\n\t *\n\t * @returns Archive has named volumns.\n\t */\n\tpublic get hasNamedVolumes() {\n\t\treturn (this.constructor as typeof Archive).HAS_NAMED_VOLUMES;\n\t}\n\n\t/**\n\t * Add an instance to set attributes after the read finishes.\n\t *\n\t * @param path Path string.\n\t * @param entry Entry instance.\n\t * @param options Extract options.\n\t */\n\tpublic afterReadSetAttributes(\n\t\tpath: string,\n\t\tentry: Entry,\n\t\toptions: Readonly<IExtractOptions> = {}\n\t) {\n\t\tconst afters = this._afterReadSetAttributes;\n\t\tif (!afters) {\n\t\t\tthrow new Error(\n\t\t\t\t'Archive after read callbacks can only be added while reading'\n\t\t\t);\n\t\t}\n\t\tafters.set(resolve(path), {\n\t\t\tpath,\n\t\t\tentry,\n\t\t\toptions\n\t\t});\n\t}\n\n\t/**\n\t * Remove an instance to set attributes after the read finishes.\n\t *\n\t * @param path Path string.\n\t */\n\tpublic afterReadSetAttributesRemove(path: string) {\n\t\tconst afters = this._afterReadSetAttributes;\n\t\tif (!afters) {\n\t\t\tthrow new Error(\n\t\t\t\t'Archive after read callbacks can only be removed while reading'\n\t\t\t);\n\t\t}\n\t\tafters.delete(resolve(path));\n\t}\n\n\t/**\n\t * Read archive.\n\t * If the itter callback returns false, reading ends.\n\t * If the itter callback returns null, skip descent where available.\n\t *\n\t * @param itter Async callback for each archive entry.\n\t */\n\tpublic async read(itter: (entry: Entry) => Promise<unknown>) {\n\t\tif (this._reading) {\n\t\t\tthrow new Error('Archive already being read');\n\t\t}\n\t\tthis._reading = true;\n\n\t\t// Reset the after entries.\n\t\tthis._afterReadSetAttributes = new Map();\n\n\t\t// Read and handle all the afters, reset after.\n\t\ttry {\n\t\t\tawait this._read(itter);\n\t\t\tawait this._afterReadSetAttributesTrigger();\n\t\t} finally {\n\t\t\tthis._afterReadSetAttributes = null;\n\t\t\tthis._reading = false;\n\t\t}\n\t}\n\n\t/**\n\t * Run all after read set attributes.\n\t */\n\tprotected async _afterReadSetAttributesTrigger() {\n\t\tconst afters = this._afterReadSetAttributes;\n\t\tif (!afters) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Prioritize by path length.\n\t\tconst resolves: string[] = [];\n\t\tfor (const [resolved] of afters) {\n\t\t\tresolves.push(resolved);\n\t\t}\n\t\tresolves.sort((a, b) => b.length - a.length);\n\n\t\tfor (const resolved of resolves) {\n\t\t\tconst ent = afters.get(resolved);\n\t\t\tif (!ent) {\n\t\t\t\tthrow new Error('Internal error');\n\t\t\t}\n\t\t\tconst {entry, path, options} = ent;\n\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\tawait entry.setAttributes(path, resolved, options);\n\t\t}\n\t}\n\n\t/**\n\t * Read archive, class implementation.\n\t * If the itter callback returns false, reading ends.\n\t * If the itter callback returns null, skip descent where available.\n\t *\n\t * @param itter Async callback for each archive entry.\n\t */\n\tprotected abstract _read(\n\t\titter: (entry: Entry) => Promise<unknown>\n\t): Promise<void>;\n}\n"],"mappings":"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","ignoreList":[]}