"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EntryHdi = exports.ArchiveHdi = void 0;
var _nodeFs = require("node:fs");
var _nodePath = require("node:path");
var _hdiMac = require("@shockpkg/hdi-mac");
var _archive = require("../archive.js");
var _types = require("../types.js");
var _util = require("../util.js");
/* eslint-disable max-classes-per-file */

const walkOpts = {
  ignoreUnreadableDirectories: true
};
const ejectOptions = {
  force: true
};
/**
 * EntryHdi object.
 */
class EntryHdi extends _archive.Entry {
  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */
  sizeComp = null;

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */
  uname = null;

  /**
   * @inheritdoc
   */
  gname = null;

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * EntryHdi constructor.
   *
   * @param info Info object.
   */
  constructor(info) {
    super(info);
    this.archive = info.archive;
    this.size = info.size;
    this.mode = info.mode;
    this.uid = info.uid;
    this.gid = info.gid;
    this.atime = info.atime;
    this.mtime = info.mtime;
  }

  /**
   * Get the path of resource psuedo-file, raw.
   *
   * @returns Path string.
   */
  get rsrcPathRaw() {
    return (0, _util.pathResourceFork)(this.pathRaw);
  }

  /**
   * Get the path of resource psuedo-file, normalized.
   *
   * @returns Path string.
   */
  get rsrcPath() {
    return (0, _util.pathNormalize)((0, _util.pathResourceFork)(this.path));
  }
}

/**
 * ArchiveHdi object.
 */
exports.EntryHdi = EntryHdi;
class ArchiveHdi extends _archive.Archive {
  /**
   * @inheritdoc
   */
  static FILE_EXTENSIONS = ['.dmg', '.iso', '.cdr'];

  /**
   * @inheritdoc
   */
  static HAS_NAMED_VOLUMES = true;

  /**
   * @inheritdoc
   */
  Entry = EntryHdi;

  /**
   * Mounter, Mac.
   */
  mounterMac = new _hdiMac.Mounter();

  /**
   * Hide mounted disk image from the file explorers.
   */
  nobrowse = false;

  /**
   * ArchiveHdi constructor.
   *
   * @param path File path.
   */
  constructor(path) {
    super(path);
  }

  /**
   * @inheritdoc
   */
  async read(itter) {
    await super.read(itter);
  }

  /**
   * @inheritdoc
   */
  async _read(itter) {
    const {
      mounterMac,
      nobrowse
    } = this;

    /**
     * Each itterator.
     *
     * @param pathFull Full path.
     * @param pathRaw Raw path.
     * @param stat Stat object.
     * @returns Recursion hint.
     */
    const each = async (pathFull, pathRaw, stat) => {
      const type = (0, _util.statToPathType)(stat);
      if (type === null) {
        return true;
      }
      const {
        size,
        mode,
        uid,
        gid,
        atime,
        mtime
      } = stat;
      const readData = type === _types.PathType.FILE ? async () => (0, _nodeFs.createReadStream)(pathFull) : null;
      const readSymlink = type === _types.PathType.SYMLINK ? async () => (0, _util.fsReadlinkRaw)(pathFull) : null;
      const entry = new this.Entry({
        archive: this,
        type,
        pathRaw,
        size,
        mode,
        uid,
        gid,
        atime,
        mtime,
        readData,
        readSymlink
      });
      const ret = await entry.trigger(itter);
      if (ret === false) {
        return null;
      }
      if (ret === null) {
        return false;
      }
      if (type === _types.PathType.FILE) {
        const rsrcPathFull = (0, _util.pathResourceFork)(pathFull);
        const rsrcStat = await (0, _util.fsLstatExists)(rsrcPathFull);
        if (rsrcStat) {
          const sizeRsrc = rsrcStat.size;

          /**
           * Read RSRC.
           *
           * @returns Read stream.
           */
          const readRsrc = async () => (0, _nodeFs.createReadStream)(rsrcPathFull);
          const entryRsrc = new this.Entry({
            archive: this,
            type: _types.PathType.RESOURCE_FORK,
            pathRaw,
            size: sizeRsrc,
            mode,
            uid,
            gid,
            atime,
            mtime,
            readRsrc
          });
          const ret = await entryRsrc.trigger(itter);
          if (ret === false) {
            return null;
          }
          if (ret === null) {
            return false;
          }
        }
      }
      return true;
    };

    // Using auto-eject on normal exit option.
    const info = await mounterMac.attach(this.path, {
      nobrowse,
      readonly: true
    }, ejectOptions);

    // Eject device when done.
    try {
      for (const device of info.devices) {
        const {
          mountPoint
        } = device;
        if (!mountPoint) {
          continue;
        }
        const volumeName = (0, _nodePath.basename)(mountPoint);
        // eslint-disable-next-line no-await-in-loop
        await (0, _util.fsWalk)(mountPoint, async (pathRel, stat) => {
          const pathFull = (0, _nodePath.join)(mountPoint, pathRel);
          const pathRaw = (0, _nodePath.join)(volumeName, pathRel);
          return each(pathFull, pathRaw, stat);
        }, walkOpts);
      }
    } finally {
      await info.eject(ejectOptions);
    }
  }
}
exports.ArchiveHdi = ArchiveHdi;
//# sourceMappingURL=hdi.js.map