"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EntryDir = exports.ArchiveDir = void 0;
var _nodeFs = require("node:fs");
var _nodePath = require("node:path");
var _archive = require("../archive.js");
var _types = require("../types.js");
var _util = require("../util.js");
/* eslint-disable max-classes-per-file */

const walkOpts = {
  ignoreUnreadableDirectories: true
};
/**
 * EntryDir object.
 */
class EntryDir extends _archive.Entry {
  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */
  sizeComp = null;

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */
  uname = null;

  /**
   * @inheritdoc
   */
  gname = null;

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * EntryDir constructor.
   *
   * @param info Info object.
   */
  constructor(info) {
    super(info);
    this.archive = info.archive;
    this.size = info.size;
    this.mode = info.mode;
    this.uid = info.uid;
    this.gid = info.gid;
    this.atime = info.atime;
    this.mtime = info.mtime;
  }

  /**
   * Get the path of resource psuedo-file, raw.
   *
   * @returns Path string.
   */
  get rsrcPathRaw() {
    return (0, _util.pathResourceFork)(this.pathRaw);
  }

  /**
   * Get the path of resource psuedo-file, normalized.
   *
   * @returns Path string.
   */
  get rsrcPath() {
    return (0, _util.pathNormalize)((0, _util.pathResourceFork)(this.path));
  }
}

/**
 * ArchiveDir object.
 */
exports.EntryDir = EntryDir;
class ArchiveDir extends _archive.Archive {
  /**
   * @inheritdoc
   */
  static FILE_EXTENSIONS = null;

  /**
   * @inheritdoc
   */
  Entry = EntryDir;

  /**
   * Limit the directory reading to subpaths.
   */
  subpaths = null;

  /**
   * ArchiveDir constructor.
   *
   * @param path File path.
   */
  constructor(path) {
    super(path);
  }

  /**
   * @inheritdoc
   */
  async read(itter) {
    await super.read(itter);
  }

  /**
   * @inheritdoc
   */
  async _read(itter) {
    /**
     * Each itterator.
     *
     * @param pathFull Full path.
     * @param pathRaw Raw path.
     * @param stat Stat object.
     * @returns Recursion hint.
     */
    const each = async (pathFull, pathRaw, stat) => {
      const type = (0, _util.statToPathType)(stat);
      if (type === null) {
        return true;
      }
      const {
        size,
        mode,
        uid,
        gid,
        atime,
        mtime
      } = stat;
      const readData = type === _types.PathType.FILE ? async () => (0, _nodeFs.createReadStream)(pathFull) : null;
      const readSymlink = type === _types.PathType.SYMLINK ? async () => (0, _util.fsReadlinkRaw)(pathFull) : null;
      const entry = new this.Entry({
        archive: this,
        type,
        pathRaw,
        size,
        mode,
        uid,
        gid,
        atime,
        mtime,
        readData,
        readSymlink
      });
      const ret = await entry.trigger(itter);
      if (ret === false) {
        return null;
      }
      if (ret === null) {
        return false;
      }
      if (type === _types.PathType.FILE) {
        const rsrcPathFull = (0, _util.pathResourceFork)(pathFull);
        const rsrcStat = await (0, _util.fsLstatExists)(rsrcPathFull);
        if (rsrcStat) {
          const sizeRsrc = rsrcStat.size;

          /**
           * Read RSRC.
           *
           * @returns Read stream.
           */
          const readRsrc = async () => (0, _nodeFs.createReadStream)(rsrcPathFull);
          const entryRsrc = new this.Entry({
            archive: this,
            type: _types.PathType.RESOURCE_FORK,
            pathRaw,
            size: sizeRsrc,
            mode,
            uid,
            gid,
            atime,
            mtime,
            readRsrc
          });
          const ret = await entryRsrc.trigger(itter);
          if (ret === false) {
            return null;
          }
          if (ret === null) {
            return false;
          }
        }
      }
      return true;
    };
    const {
      path,
      subpaths
    } = this;
    if (subpaths) {
      for (const subpath of subpaths) {
        // eslint-disable-next-line no-await-in-loop
        const stat = await (0, _util.fsLstat)((0, _nodePath.join)(path, subpath));

        // eslint-disable-next-line no-await-in-loop
        await each((0, _nodePath.join)(path, subpath), subpath, stat);
        if (stat.isDirectory()) {
          // eslint-disable-next-line no-await-in-loop
          await (0, _util.fsWalk)((0, _nodePath.join)(path, subpath), async (pathRel, stat) => {
            const pathFull = (0, _nodePath.join)(path, subpath, pathRel);
            return each(pathFull, (0, _nodePath.join)(subpath, pathRel), stat);
          }, walkOpts);
        }
      }
      return;
    }
    await (0, _util.fsWalk)(path, async (pathRel, stat) => {
      const pathFull = (0, _nodePath.join)(path, pathRel);
      return each(pathFull, pathRel, stat);
    }, walkOpts);
  }
}
exports.ArchiveDir = ArchiveDir;
//# sourceMappingURL=dir.js.map