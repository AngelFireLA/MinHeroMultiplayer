"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EntryTar = exports.ArchiveTar = void 0;
var _nodeFs = require("node:fs");
var _nodeStream = require("node:stream");
var _archive = require("../archive.js");
var _types = require("../types.js");
/* eslint-disable max-classes-per-file */

// Based on it-tar TarEntryHeader.

/**
 * Load it-tar, even in CommonJS.
 *
 * @returns The it-tar module.
 */
const itTar = async () => import('it-tar');

/**
 * Create stream from a BufferList generator.
 *
 * @param gen BufferList generator.
 * @returns Readable stream.
 */
const streamFromBufferListGenerator = gen => {
  const r = new _nodeStream.Readable({
    /**
     * Read method.
     */
    read: () => {
      gen.next().then(({
        done,
        value
      }) => {
        // eslint-disable-next-line unicorn/prefer-spread
        r.push(done ? null : value.slice());
      }, err => {
        r.emit('error', err);
      });
    }
  });
  return r;
};
/**
 * EntryTar object.
 */
class EntryTar extends _archive.Entry {
  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */
  sizeComp = null;

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */
  atime = null;

  /**
   * @inheritdoc
   */

  /**
   * Entry linkname if present.
   */

  /**
   * @inheritdoc
   */
  _readRsrc = null;

  /**
   * EntryTar constructor.
   *
   * @param info Info object.
   */
  constructor(info) {
    super(info);
    this.archive = info.archive;
    this.size = info.size;
    this.mode = info.mode;
    this.uid = info.uid;
    this.gid = info.gid;
    this.uname = info.uname ?? null;
    this.gname = info.gname ?? null;
    this.mtime = info.mtime;
    this.linkname = info.linkname ?? null;
  }
}

/**
 * ArchiveTar object.
 */
exports.EntryTar = EntryTar;
class ArchiveTar extends _archive.Archive {
  /**
   * @inheritdoc
   */
  static FILE_EXTENSIONS = ['.tar'];

  /**
   * @inheritdoc
   */
  Entry = EntryTar;

  /**
   * ArchiveTar constructor.
   *
   * @param path File path.
   */
  constructor(path) {
    super(path);
  }

  /**
   * @inheritdoc
   */
  async read(itter) {
    await super.read(itter);
  }

  /**
   * @inheritdoc
   */
  async _read(itter) {
    /**
     * Each itterator.
     *
     * @param header Entry header.
     * @param stream Entry stream.
     * @returns Recursion hint.
     */
    const each = async (header, stream) => {
      // Check type, skip unsupported.
      let type;
      switch (header.type) {
        case 'file':
          {
            type = _types.PathType.FILE;
            break;
          }
        case 'symlink':
          {
            type = _types.PathType.SYMLINK;
            break;
          }
        case 'directory':
          {
            type = _types.PathType.DIRECTORY;
            break;
          }
        default:
          {
            return false;
          }
      }

      // These values should always be set.
      const pathRaw = header.name;
      let {
        size
      } = header;
      const {
        mode,
        uid,
        gid,
        mtime,
        uname,
        gname
      } = header;

      // Used for symbolic links, convert to a buffer.
      const linkname = header.linkname ?? null;
      const linknameBuffer = linkname === null ? null : Buffer.from(linkname, 'utf8');
      const readData = type === _types.PathType.FILE ? async () => stream() : null;
      const readSymlink = linknameBuffer ? async () => linknameBuffer : null;

      // If a symbolic link, make it the size of the link data, not 0.
      if (type === _types.PathType.SYMLINK) {
        if (!linknameBuffer) {
          throw new Error('Internal error');
        }
        size = linknameBuffer.length;
      }
      const entry = new this.Entry({
        archive: this,
        type,
        pathRaw,
        size,
        mode,
        uid,
        gid,
        uname,
        gname,
        mtime,
        linkname,
        readData,
        readSymlink
      });
      const ret = await entry.trigger(itter);
      return ret === false;
    };
    let cancel = false;
    const input = (0, _nodeFs.createReadStream)(this.path);
    const {
      extract
    } = await itTar();
    for await (const {
      header,
      body
    } of extract()(this._decompress(input))) {
      // Call handler for each, break off on cancel.
      cancel = await each(header, () => streamFromBufferListGenerator(body));
      if (cancel) {
        break;
      }

      // Finish reading the body if not read, get to the next entry.
      // eslint-disable-next-line no-await-in-loop
      while (!(await body.next()).done) {
        // Do nothing.
      }
    }
    if (cancel) {
      input.destroy();
    }
  }

  /**
   * A async buffer generator to decopress if needed.
   *
   * @param input Buffer generator.
   * @yields Decompressed data.
   */
  async *_decompress(input) {
    // Plain tar files are not compressed, just pass data through.
    for await (const chunk of input) {
      yield chunk;
    }
  }
}
exports.ArchiveTar = ArchiveTar;
//# sourceMappingURL=tar.js.map