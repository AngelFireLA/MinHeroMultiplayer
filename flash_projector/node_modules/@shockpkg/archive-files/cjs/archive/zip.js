"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EntryZip = exports.ArchiveZip = void 0;
var _yauzl = require("yauzl");
var _archive = require("../archive.js");
var _types = require("../types.js");
var _util = require("../util.js");
/* eslint-disable max-classes-per-file */

/**
 * Read entry.
 *
 * @param zipfile Zipfile.
 * @param entry Entry.
 * @returns Readable stream.
 */
const yauzlEntryRead = async (zipfile, entry) => {
  // If the entry is empty, just return an empty stream.
  if (!entry.uncompressedSize) {
    return null;
  }
  return new Promise((resolve, reject) => {
    zipfile.openReadStream(entry, (err, stream) => {
      if (err) {
        reject(err);
        return;
      }
      resolve(stream);
    });
  });
};

/**
 * Read entry as symlink.
 *
 * @param zipfile Zipfile.
 * @param entry Entry.
 * @returns Buffer.
 */
const yauzlEntryReadSymlink = async (zipfile, entry) => {
  const stream = await yauzlEntryRead(zipfile, entry);
  return stream ? (0, _util.streamToBuffer)(stream) : Buffer.alloc(0);
};
/**
 * EntryZip object.
 */
class EntryZip extends _archive.Entry {
  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */

  /**
   * @inheritdoc
   */
  uid = null;

  /**
   * @inheritdoc
   */
  gid = null;

  /**
   * @inheritdoc
   */
  uname = null;

  /**
   * @inheritdoc
   */
  gname = null;

  /**
   * @inheritdoc
   */
  atime = null;

  /**
   * @inheritdoc
   */

  /**
   * Entry CRC32.
   */

  /**
   * Entry compression method.
   */

  /**
   * Entry is compressed flag.
   */

  /**
   * Entry is encrypted flag.
   */

  /**
   * Entry version made by.
   */

  /**
   * Entry version needed to extract.
   */

  /**
   * Entry general purpose bit flags.
   */

  /**
   * Entry internal file attributes.
   */

  /**
   * Entry external file attributes.
   */

  /**
   * Entry comment.
   */

  /**
   * Entry extra fields.
   */

  /**
   * @inheritdoc
   */
  _readRsrc = null;

  /**
   * EntryZip constructor.
   *
   * @param info Info object.
   */
  constructor(info) {
    super(info);
    this.archive = info.archive;
    this.size = info.size;
    this.sizeComp = info.sizeComp;
    this.mtime = info.mtime;
    this.crc32 = info.crc32;
    this.compressionMethod = info.compressionMethod;
    this.isCompressed = info.isCompressed;
    this.isEncrypted = info.isEncrypted;
    this.versionMadeBy = info.versionMadeBy;
    this.versionNeededToExtract = info.versionNeededToExtract;
    this.comment = info.comment;
    this.generalPurposeBitFlag = info.generalPurposeBitFlag;
    this.internalFileAttributes = info.internalFileAttributes;
    this.externalFileAttributes = info.externalFileAttributes;
    this.extraFields = info.extraFields;
  }
}

/**
 * ArchiveZip object.
 */
exports.EntryZip = EntryZip;
class ArchiveZip extends _archive.Archive {
  /**
   * @inheritdoc
   */
  static FILE_EXTENSIONS = ['.zip'];

  /**
   * @inheritdoc
   */
  Entry = EntryZip;

  /**
   * ArchiveZip constructor.
   *
   * @param path File path.
   */
  constructor(path) {
    super(path);
  }

  /**
   * @inheritdoc
   */
  async read(itter) {
    await super.read(itter);
  }

  /**
   * @inheritdoc
   */
  async _read(itter) {
    const Static = this.constructor;
    const zipfile = await new Promise((resolve, reject) => {
      _yauzl.open(this.path, {
        lazyEntries: true
      }, (err, zipfile) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(zipfile);
      });
    });

    /**
     * Each itterator.
     *
     * @param yentry Entry.
     * @returns Recursion hint.
     */
    const each = async yentry => {
      const {
        comment,
        compressedSize,
        compressionMethod,
        crc32,
        externalFileAttributes,
        extraFields,
        fileName,
        generalPurposeBitFlag,
        internalFileAttributes,
        uncompressedSize,
        versionMadeBy,
        versionNeededToExtract
      } = yentry;
      const type = Static.efaOrPathToPathType(externalFileAttributes, fileName);
      if (type === null) {
        return false;
      }

      // Mac resource fork paths currently unsupported, so skip.
      // The actual file format is unknown.
      const isMacResource = Static.pathIsMacResource(fileName);
      if (isMacResource) {
        return false;
      }
      const mode = Static.efaToUnixMode(externalFileAttributes);
      const lastModDate = yentry.getLastModDate();
      const isCompressed = yentry.isCompressed();
      const isEncrypted = yentry.isEncrypted();
      const readData = type === _types.PathType.FILE ? async () => yauzlEntryRead(zipfile, yentry) : null;
      const readSymlink = type === _types.PathType.SYMLINK ? async () => yauzlEntryReadSymlink(zipfile, yentry) : null;
      const entry = new this.Entry({
        archive: this,
        type,
        pathRaw: fileName,
        size: uncompressedSize,
        sizeComp: compressedSize,
        mode,
        mtime: lastModDate,
        crc32,
        compressionMethod,
        isCompressed,
        isEncrypted,
        versionMadeBy,
        versionNeededToExtract,
        generalPurposeBitFlag,
        internalFileAttributes,
        externalFileAttributes,
        comment,
        extraFields,
        readData,
        readSymlink
      });
      const ret = await entry.trigger(itter);
      return ret === false;
    };
    await new Promise((resolve, reject) => {
      let error = null;

      /**
       * Next callback.
       *
       * @param err Error object or null.
       */
      const next = err => {
        if (err) {
          error = err;
          zipfile.close();
          return;
        }
        zipfile.readEntry();
      };
      zipfile.on('error', next);
      zipfile.on('entry', entry => {
        each(entry).then(done => {
          if (!done) {
            next(null);
            return;
          }
          zipfile.close();
        }).catch(next);
      });
      zipfile.on('close', () => {
        if (error) {
          reject(error);
          return;
        }
        resolve();
      });
      next(null);
    });
  }

  /**
   * Get Unix bits from the ZIP file external file attributes.
   *
   * @param attrs Attributes value.
   * @returns Unix bits or null.
   */
  static efaToUnix(attrs) {
    // eslint-disable-next-line no-bitwise
    return attrs >>> 16;
  }

  /**
   * Get stat mode value from ZIP file external file attributes, if present.
   *
   * @param attrs Attributes value.
   * @returns Stat mode or null.
   */
  static efaToUnixMode(attrs) {
    const mode = this.efaToUnix(attrs);

    // Check if type bits are present, else no Unix info.
    // eslint-disable-next-line no-bitwise
    return mode >> 12 & 0b1111 ? mode : null;
  }

  /**
   * Get path type from attributes and path value from ZIP file entry.
   *
   * @param attrs Attributes value.
   * @param path Entry path.
   * @returns Path type.
   */
  static efaOrPathToPathType(attrs, path) {
    // Check for Unix stat type information.
    const mode = this.efaToUnixMode(attrs);
    if (!mode) {
      // No Unix type information, assume Windows info only.
      // Only file or directory, with directory having a trailing slash.
      return /[/\\]$/.test(path) ? _types.PathType.DIRECTORY : _types.PathType.FILE;
    }
    return (0, _util.modeToPathType)(mode);
  }

  /**
   * Check if path is a Mac resource fork related path.
   *
   * @param path Zip path.
   * @returns Boolean value.
   */
  static pathIsMacResource(path) {
    return /^__MACOSX(\\|\/|$)/.test(path);
  }
}
exports.ArchiveZip = ArchiveZip;
//# sourceMappingURL=zip.js.map