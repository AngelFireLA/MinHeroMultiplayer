"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createArchiveByFileExtension = createArchiveByFileExtension;
exports.createArchiveByFileExtensionOrThrow = createArchiveByFileExtensionOrThrow;
exports.createArchiveByFileStat = createArchiveByFileStat;
exports.createArchiveByFileStatOrThrow = createArchiveByFileStatOrThrow;
var _promises = require("node:fs/promises");
var _dir = require("./archive/dir.js");
var _hdi = require("./archive/hdi.js");
var _tar = require("./archive/tar.js");
var _bz = require("./archive/tar/bz2.js");
var _gz = require("./archive/tar/gz.js");
var _zip = require("./archive/zip.js");
const archives = [_dir.ArchiveDir, _hdi.ArchiveHdi, _tar.ArchiveTar, _bz.ArchiveTarBz2, _gz.ArchiveTarGz, _zip.ArchiveZip];
let archivesExtensionsCache = null;

/**
 * Get all archive and extension pairs, ordered longest to shortest.
 *
 * @returns List of archive and extenion pairs.
 */
function archivesExtensions() {
  if (archivesExtensionsCache) {
    return archivesExtensionsCache;
  }

  // List all the extension and archive pairs.
  const all = [];
  for (const Archive of archives) {
    const {
      FILE_EXTENSIONS
    } = Archive;
    if (!FILE_EXTENSIONS) {
      continue;
    }
    for (const ext of FILE_EXTENSIONS) {
      all.push({
        Archive,
        ext: ext.toLowerCase()
      });
    }
  }

  // Match longest extensions first.
  all.sort((a, b) => b.ext.length - a.ext.length);
  return archivesExtensionsCache = all;
}

/**
 * Create an Archive instance for a given path.
 * Based on file extension.
 *
 * @param path File path.
 * @param options Optional options.
 * @returns Archive instance or null.
 */
function createArchiveByFileExtension(path, options = null) {
  const pathLower = path.toLowerCase();
  const list = archivesExtensions();
  for (const {
    Archive,
    ext
  } of list) {
    if (pathLower.endsWith(ext)) {
      const a = new Archive(path);
      if (options && a instanceof _hdi.ArchiveHdi) {
        a.nobrowse = options.nobrowse ?? false;
      }
      return a;
    }
  }
  return null;
}

/**
 * Create an Archive instance for a given path.
 * Based on file extension.
 *
 * @param path File path.
 * @param options Optional options.
 * @returns Archive instance.
 */
function createArchiveByFileExtensionOrThrow(path, options = null) {
  const a = createArchiveByFileExtension(path, options);
  if (!a) {
    throw new Error(`Unsupported archive format: ${path}`);
  }
  return a;
}

/**
 * Create an Archive instance for a given path.
 * Based on file extension or if a directory.
 *
 * @param path File path.
 * @param options Optional options.
 * @returns Archive instance or null.
 */
async function createArchiveByFileStat(path, options = null) {
  const st = await (0, _promises.stat)(path).catch(() => null);
  if (!st) {
    return null;
  }
  return st.isDirectory() ? new _dir.ArchiveDir(path) : createArchiveByFileExtension(path, options);
}

/**
 * Create an Archive instance for a given path.
 * Based on file extension or if a directory.
 *
 * @param path File path.
 * @param options Optional options.
 * @returns Archive instance.
 */
async function createArchiveByFileStatOrThrow(path, options = null) {
  const st = await (0, _promises.stat)(path);
  return st.isDirectory() ? new _dir.ArchiveDir(path) : createArchiveByFileExtensionOrThrow(path, options);
}
//# sourceMappingURL=create.js.map