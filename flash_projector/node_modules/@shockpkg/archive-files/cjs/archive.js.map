{"version":3,"file":"archive.js","names":["_nodeFs","require","_promises","_nodePath","_nodeStream","_nodeUtil","_types","_util","pipe","promisify","pipeline","Entry","_triggering","_triggered","_extracted","constructor","info","archive","type","pathRaw","path","pathNormalize","size","sizeComp","mode","uid","gid","uname","gname","atime","mtime","_readData","readData","_readRsrc","readRsrc","_readSymlink","readSymlink","hasNamedVolume","hasNamedVolumes","volumeName","slice","indexOf","volumePath","stream","_beginExtract","_stream","read","streamToBuffer","extract","options","_extract","trigger","itter","r","Error","setAttributes","pathFull","pathSet","ignorePermissions","ignoreTimes","link","PathType","FILE","RESOURCE_FORK","DIRECTORY","SYMLINK","atimeSet","mtimeSet","chmod","fsLchmod","fsChmod","modeSet","modePermissionBits","utimes","fsLutimes","fsUtimes","_errorExtractPathExists","_errorNoResourceFork","afterReadSetAttributesRemove","_extractFile","_extractResourceFork","_extractDirectory","_extractSymlink","_extractStreamToFile","reader","replace","stat","fsLstatExists","rm","recursive","force","mkdir","dirname","writeFile","Buffer","alloc","createWriteStream","resourceForkAsFile","isFile","pathRsrc","pathResourceFork","isDirectory","afterReadSetAttributes","symlinkAsFile","target","fsSymlink","_streamFile","_streamResourceFork","_streamDirectory","_streamSymlink","Readable","then","d","push","err","emit","exports","Archive","FILE_EXTENSIONS","HAS_NAMED_VOLUMES","_reading","_afterReadSetAttributes","fileExtensions","entry","afters","set","resolve","delete","Map","_read","_afterReadSetAttributesTrigger","resolves","resolved","sort","a","b","length","ent","get"],"sources":["../src/archive.ts"],"sourcesContent":["/* eslint-disable max-classes-per-file */\n\nimport {createWriteStream} from 'node:fs';\nimport {mkdir, rm, writeFile} from 'node:fs/promises';\nimport {dirname, resolve} from 'node:path';\nimport {Readable, pipeline} from 'node:stream';\nimport {promisify} from 'node:util';\n\nconst pipe = promisify(pipeline);\n\nimport {PathType} from './types.ts';\nimport {\n\tfsChmod,\n\tfsLchmod,\n\tfsLstatExists,\n\tfsLutimes,\n\tfsSymlink,\n\tfsUtimes,\n\tmodePermissionBits,\n\tpathNormalize,\n\tpathResourceFork,\n\tstreamToBuffer\n} from './util.ts';\n\nexport interface IArchiveAfterReadSetAttributesEntry {\n\t/**\n\t * Extract path, relative.\n\t */\n\tpath: string;\n\n\t/**\n\t * Entry.\n\t */\n\tentry: Entry;\n\n\t/**\n\t * Extract options.\n\t */\n\toptions: IExtractOptions;\n}\n\nexport interface IExtractOptions {\n\t/**\n\t * Replace whatever may be at the path.\n\t * A directory will not replace another directory.\n\t *\n\t * @default false\n\t */\n\treplace?: boolean;\n\n\t/**\n\t * Ignore permissions when extracting.\n\t *\n\t * @default false\n\t */\n\tignorePermissions?: boolean;\n\n\t/**\n\t * Ignore file modification and access times when extracting.\n\t *\n\t * @default false\n\t */\n\tignoreTimes?: boolean;\n\n\t/**\n\t * Extract resource fork as a file.\n\t *\n\t * @default false\n\t */\n\tresourceForkAsFile?: boolean;\n\n\t/**\n\t * Extract symlink as a file.\n\t *\n\t * @default false\n\t */\n\tsymlinkAsFile?: boolean;\n}\n\nexport interface IEntryInfo {\n\t/**\n\t * Entry archive.\n\t */\n\tarchive: Archive;\n\n\t/**\n\t * Entry type.\n\t */\n\ttype: PathType;\n\n\t/**\n\t * Entry path, raw.\n\t */\n\tpathRaw: string;\n\n\t/**\n\t * Entry size.\n\t */\n\tsize?: number | null;\n\n\t/**\n\t * Entry size, compressed.\n\t */\n\tsizeComp?: number | null;\n\n\t/**\n\t * Entry mode.\n\t */\n\tmode?: number | null;\n\n\t/**\n\t * Entry uid.\n\t */\n\tuid?: number | null;\n\n\t/**\n\t * Entry gid.\n\t */\n\tgid?: number | null;\n\n\t/**\n\t * Entry uname.\n\t */\n\tuname?: string | null;\n\n\t/**\n\t * Entry gname.\n\t */\n\tgname?: string | null;\n\n\t/**\n\t * Entry atime.\n\t */\n\tatime?: Date | null;\n\n\t/**\n\t * Entry mtime.\n\t */\n\tmtime?: Date | null;\n\n\t/**\n\t * Read data.\n\t */\n\treadData?: (() => Promise<Readable | null>) | null;\n\n\t/**\n\t * Read rsrc.\n\t */\n\treadRsrc?: (() => Promise<Readable | null>) | null;\n\n\t/**\n\t * Read symlink.\n\t */\n\treadSymlink?: (() => Promise<Buffer>) | null;\n}\n\n/**\n * Entry object.\n */\nexport abstract class Entry {\n\t/**\n\t * Entry archive.\n\t */\n\tpublic readonly archive: Archive;\n\n\t/**\n\t * Entry type.\n\t */\n\tpublic readonly type: PathType;\n\n\t/**\n\t * Entry path.\n\t */\n\tpublic readonly path: string;\n\n\t/**\n\t * Entry path, raw.\n\t */\n\tpublic readonly pathRaw: string;\n\n\t/**\n\t * Entry size.\n\t */\n\tpublic readonly size: number | null;\n\n\t/**\n\t * Entry size, compressed.\n\t */\n\tpublic readonly sizeComp: number | null;\n\n\t/**\n\t * Entry mode.\n\t */\n\tpublic readonly mode: number | null;\n\n\t/**\n\t * Entry uid.\n\t */\n\tpublic readonly uid: number | null;\n\n\t/**\n\t * Entry gid.\n\t */\n\tpublic readonly gid: number | null;\n\n\t/**\n\t * Entry uname.\n\t */\n\tpublic readonly uname: string | null;\n\n\t/**\n\t * Entry gname.\n\t */\n\tpublic readonly gname: string | null;\n\n\t/**\n\t * Entry atime.\n\t */\n\tpublic readonly atime: Date | null;\n\n\t/**\n\t * Entry mtime.\n\t */\n\tpublic readonly mtime: Date | null;\n\n\t/**\n\t * Read data.\n\t */\n\tprotected readonly _readData: (() => Promise<Readable | null>) | null;\n\n\t/**\n\t * Read rsrc.\n\t */\n\tprotected readonly _readRsrc: (() => Promise<Readable | null>) | null;\n\n\t/**\n\t * Read symlink.\n\t */\n\tprotected readonly _readSymlink: (() => Promise<Buffer>) | null;\n\n\t/**\n\t * Entry triggering.\n\t */\n\tprotected _triggering = false;\n\n\t/**\n\t * Entry triggered.\n\t */\n\tprotected _triggered = false;\n\n\t/**\n\t * Entry extracted.\n\t */\n\tprotected _extracted = false;\n\n\t/**\n\t * Entry constructor.\n\t *\n\t * @param info Info object.\n\t */\n\tconstructor(info: Readonly<IEntryInfo>) {\n\t\tthis.archive = info.archive;\n\t\tthis.type = info.type;\n\t\tthis.pathRaw = info.pathRaw;\n\t\tthis.path = pathNormalize(info.pathRaw);\n\t\tthis.size = info.size ?? null;\n\t\tthis.sizeComp = info.sizeComp ?? null;\n\t\tthis.mode = info.mode ?? null;\n\t\tthis.uid = info.uid ?? null;\n\t\tthis.gid = info.gid ?? null;\n\t\tthis.uname = info.uname ?? null;\n\t\tthis.gname = info.gname ?? null;\n\t\tthis.atime = info.atime ?? null;\n\t\tthis.mtime = info.mtime ?? null;\n\t\tthis._readData = info.readData ?? null;\n\t\tthis._readRsrc = info.readRsrc ?? null;\n\t\tthis._readSymlink = info.readSymlink ?? null;\n\t}\n\n\t/**\n\t * This entry path includes named volume.\n\t *\n\t * @returns Entry has volume name in path.\n\t */\n\tpublic get hasNamedVolume() {\n\t\treturn this.archive.hasNamedVolumes;\n\t}\n\n\t/**\n\t * This entry volume name, or null.\n\t *\n\t * @returns Entry path volume name.\n\t */\n\tpublic get volumeName() {\n\t\tif (this.hasNamedVolume) {\n\t\t\tconst {path} = this;\n\t\t\treturn path.slice(0, path.indexOf('/'));\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * This entry path without any possible volume name.\n\t *\n\t * @returns Entry path without the volume name.\n\t */\n\tpublic get volumePath() {\n\t\tconst {path} = this;\n\t\tif (this.hasNamedVolume) {\n\t\t\treturn path.slice(path.indexOf('/') + 1);\n\t\t}\n\t\treturn path;\n\t}\n\n\t/**\n\t * Read entry as stream, or null if nothing to read.\n\t * Consuming function will need to wait for stream to close.\n\t *\n\t * @returns Readable stream or null if nothing to read.\n\t */\n\tpublic async stream() {\n\t\tthis._beginExtract();\n\t\treturn this._stream();\n\t}\n\n\t/**\n\t * Read entire entry into a Buffer.\n\t *\n\t * @returns Buffer or null if nothing to be read.\n\t */\n\tpublic async read() {\n\t\tthis._beginExtract();\n\t\tconst stream = await this._stream();\n\t\treturn stream ? streamToBuffer(stream) : null;\n\t}\n\n\t/**\n\t * Extract entry.\n\t *\n\t * @param path Extract path.\n\t * @param options Extract options.\n\t */\n\tpublic async extract(\n\t\tpath: string,\n\t\toptions: Readonly<IExtractOptions> = {}\n\t) {\n\t\tthis._beginExtract();\n\t\tawait this._extract(path, options);\n\t}\n\n\t/**\n\t * Trigger on itterator function.\n\t *\n\t * @param itter Itterator function.\n\t * @returns Return value.\n\t */\n\tpublic async trigger<T, U extends (entry: this) => Promise<T>>(itter: U) {\n\t\tlet r: T;\n\t\tif (this._triggered) {\n\t\t\tthrow new Error('Archive entry already triggered');\n\t\t}\n\t\tthis._triggered = this._triggering = true;\n\t\ttry {\n\t\t\tr = await itter(this);\n\t\t} finally {\n\t\t\tthis._triggering = false;\n\t\t}\n\t\treturn r;\n\t}\n\n\t/**\n\t * Run again after reading.\n\t *\n\t * @param path Extract path, relative.\n\t * @param pathFull An optional full path to be used.\n\t * @param options Extract options.\n\t */\n\tpublic async setAttributes(\n\t\tpath: string,\n\t\tpathFull: string | null = null,\n\t\toptions: Readonly<IExtractOptions> = {}\n\t) {\n\t\tconst pathSet = pathFull === null ? path : pathFull;\n\n\t\tconst {ignorePermissions, ignoreTimes} = options;\n\n\t\tconst {type, mode, atime, mtime} = this;\n\n\t\tlet link = false;\n\t\tswitch (type) {\n\t\t\tcase PathType.FILE: {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PathType.RESOURCE_FORK: {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PathType.DIRECTORY: {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PathType.SYMLINK: {\n\t\t\t\tlink = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error(`Unsupported path type: ${type as string}`);\n\t\t\t}\n\t\t}\n\n\t\tconst atimeSet = atime || mtime || null;\n\t\tconst mtimeSet = mtime || atime || null;\n\n\t\tif (!ignorePermissions && mode !== null) {\n\t\t\tconst chmod = link ? fsLchmod : fsChmod;\n\t\t\tconst modeSet = modePermissionBits(mode);\n\t\t\tawait chmod(pathSet, modeSet);\n\t\t}\n\n\t\tif (!ignoreTimes && atimeSet && mtimeSet) {\n\t\t\tconst utimes = link ? fsLutimes : fsUtimes;\n\t\t\tawait utimes(pathSet, atimeSet, mtimeSet);\n\t\t}\n\t}\n\n\t/**\n\t * Method to call before begining extraction.\n\t * Throws error if extraction already started or entry not active.\n\t */\n\tprotected _beginExtract() {\n\t\tif (!this._triggering) {\n\t\t\tthrow new Error('Archive entry is not active');\n\t\t}\n\t\tif (this._extracted) {\n\t\t\tthrow new Error('Archive entry can only be extracted once');\n\t\t}\n\t\tthis._extracted = true;\n\t}\n\n\t/**\n\t * Create an extract error for path that exists.\n\t *\n\t * @param path Extract path.\n\t * @returns Error object.\n\t */\n\tprotected _errorExtractPathExists(path: string) {\n\t\treturn new Error(`Extract path already exists: ${path}`);\n\t}\n\n\t/**\n\t * Create an extract error for a resource fork not going to a file.\n\t *\n\t * @param path Extract path.\n\t * @returns Error object.\n\t */\n\tprotected _errorNoResourceFork(path: string) {\n\t\treturn new Error(`Extract path for resource fork not a file: ${path}`);\n\t}\n\n\t/**\n\t * Extract entry.\n\t *\n\t * @param path Extract path.\n\t * @param options Extract options.\n\t */\n\tprotected async _extract(path: string, options: Readonly<IExtractOptions>) {\n\t\tthis.archive.afterReadSetAttributesRemove(path);\n\n\t\tconst {type} = this;\n\t\tswitch (type) {\n\t\t\tcase PathType.FILE: {\n\t\t\t\tawait this._extractFile(path, options);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PathType.RESOURCE_FORK: {\n\t\t\t\tawait this._extractResourceFork(path, options);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PathType.DIRECTORY: {\n\t\t\t\tawait this._extractDirectory(path, options);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PathType.SYMLINK: {\n\t\t\t\tawait this._extractSymlink(path, options);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error(`Unsupported path type: ${type as string}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Base function for extracting stream to a file.\n\t *\n\t * @param path Extract path.\n\t * @param reader Reader function.\n\t * @param options Extract options.\n\t */\n\tprotected async _extractStreamToFile(\n\t\tpath: string,\n\t\treader: () => Promise<Readable | null>,\n\t\toptions: Readonly<IExtractOptions>\n\t) {\n\t\tconst {replace} = options;\n\n\t\t// Check if something exists at path, optionally removing.\n\t\tconst stat = await fsLstatExists(path);\n\t\tif (stat) {\n\t\t\t// If replacing, then remove, else throw.\n\t\t\tif (replace) {\n\t\t\t\tawait rm(path, {recursive: true, force: true});\n\t\t\t} else {\n\t\t\t\tthrow this._errorExtractPathExists(path);\n\t\t\t}\n\t\t} else {\n\t\t\tawait mkdir(dirname(path), {recursive: true});\n\t\t}\n\n\t\t// Write file.\n\t\tawait writeFile(path, Buffer.alloc(0));\n\t\tconst stream = await reader();\n\t\tif (stream) {\n\t\t\tawait pipe(stream, createWriteStream(path));\n\t\t}\n\n\t\t// Set attributes.\n\t\tawait this.setAttributes(path, null, options);\n\t}\n\n\t/**\n\t * Extract as a file.\n\t *\n\t * @param path Extract path.\n\t * @param options Extract options.\n\t */\n\tprotected async _extractFile(\n\t\tpath: string,\n\t\toptions: Readonly<IExtractOptions>\n\t) {\n\t\tconst readData = this._readData;\n\t\tif (!readData) {\n\t\t\tthrow new Error('Internal error');\n\t\t}\n\n\t\tawait this._extractStreamToFile(path, readData, options);\n\t}\n\n\t/**\n\t * Extract as resource fork to an existing file.\n\t *\n\t * @param path Extract path.\n\t * @param options Extract options.\n\t */\n\tprotected async _extractResourceFork(\n\t\tpath: string,\n\t\toptions: Readonly<IExtractOptions>\n\t) {\n\t\tconst readRsrc = this._readRsrc;\n\t\tif (!readRsrc) {\n\t\t\tthrow new Error('Internal error');\n\t\t}\n\n\t\t// Optionally extract as a data file.\n\t\tif (options.resourceForkAsFile) {\n\t\t\tawait this._extractStreamToFile(path, readRsrc, options);\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if file exists at path, else throw.\n\t\tconst stat = await fsLstatExists(path);\n\t\tif (!stat || !stat.isFile()) {\n\t\t\tthrow this._errorNoResourceFork(path);\n\t\t}\n\n\t\t// Create resource fork path.\n\t\tconst pathRsrc = pathResourceFork(path);\n\n\t\t// Write the resource fork.\n\t\tconst stream = await readRsrc();\n\n\t\t// eslint-disable-next-line unicorn/prefer-ternary\n\t\tif (stream) {\n\t\t\tawait pipe(stream, createWriteStream(pathRsrc));\n\t\t} else {\n\t\t\tawait writeFile(pathRsrc, Buffer.alloc(0));\n\t\t}\n\n\t\t// Set attributes.\n\t\tawait this.setAttributes(path, null, options);\n\t}\n\n\t/**\n\t * Extract as a directory.\n\t *\n\t * @param path Extract path.\n\t * @param options Extract options.\n\t */\n\tprotected async _extractDirectory(\n\t\tpath: string,\n\t\toptions: Readonly<IExtractOptions>\n\t) {\n\t\tconst {replace} = options;\n\n\t\t// Check if something exists at path, else create.\n\t\tconst stat = await fsLstatExists(path);\n\t\tif (stat) {\n\t\t\t// If not directory, then remove and replace it, else throw.\n\t\t\tif (!stat.isDirectory()) {\n\t\t\t\tif (replace) {\n\t\t\t\t\tawait rm(path, {recursive: true, force: true});\n\t\t\t\t\tawait mkdir(path, {recursive: true});\n\t\t\t\t} else {\n\t\t\t\t\tthrow this._errorExtractPathExists(path);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tawait mkdir(path, {recursive: true});\n\t\t}\n\n\t\t// Set directory attributes after any children are added.\n\t\tthis.archive.afterReadSetAttributes(path, this, {...options});\n\t}\n\n\t/**\n\t * Extract as a symlink.\n\t *\n\t * @param path Extract path.\n\t * @param options Extract options.\n\t */\n\tprotected async _extractSymlink(\n\t\tpath: string,\n\t\toptions: Readonly<IExtractOptions>\n\t) {\n\t\tconst readSymlink = this._readSymlink;\n\t\tif (!readSymlink) {\n\t\t\tthrow new Error('Internal error');\n\t\t}\n\n\t\tconst {replace, symlinkAsFile} = options;\n\n\t\t// Check if something exists at path, optionally removing.\n\t\tconst stat = await fsLstatExists(path);\n\t\tif (stat) {\n\t\t\t// If replacing, then remove, else throw.\n\t\t\tif (replace) {\n\t\t\t\tawait rm(path, {recursive: true, force: true});\n\t\t\t} else {\n\t\t\t\tthrow this._errorExtractPathExists(path);\n\t\t\t}\n\t\t} else {\n\t\t\t// Ensure base directory exists.\n\t\t\tawait mkdir(dirname(path), {recursive: true});\n\t\t}\n\n\t\t// Read target.\n\t\tconst target = await readSymlink();\n\n\t\t// Create link, optionally as a file.\n\t\t// eslint-disable-next-line unicorn/prefer-ternary\n\t\tif (symlinkAsFile) {\n\t\t\tawait writeFile(path, target);\n\t\t} else {\n\t\t\tawait fsSymlink(path, target);\n\t\t}\n\n\t\t// Set attributes.\n\t\tawait this.setAttributes(path, null, options);\n\t}\n\n\t/**\n\t * Read as stream.\n\t *\n\t * @returns Readable stream.\n\t */\n\tprotected async _stream() {\n\t\tconst {type} = this;\n\t\tswitch (type) {\n\t\t\tcase PathType.FILE: {\n\t\t\t\treturn this._streamFile();\n\t\t\t}\n\t\t\tcase PathType.RESOURCE_FORK: {\n\t\t\t\treturn this._streamResourceFork();\n\t\t\t}\n\t\t\tcase PathType.DIRECTORY: {\n\t\t\t\treturn this._streamDirectory();\n\t\t\t}\n\t\t\tcase PathType.SYMLINK: {\n\t\t\t\treturn this._streamSymlink();\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error(`Unsupported path type: ${type as string}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Read file as stream.\n\t *\n\t * @returns Readable stream.\n\t */\n\tprotected async _streamFile() {\n\t\tconst readData = this._readData;\n\t\tif (!readData) {\n\t\t\tthrow new Error('Internal error');\n\t\t}\n\t\treturn readData();\n\t}\n\n\t/**\n\t * Read resource fork as stream.\n\t *\n\t * @returns Readable stream.\n\t */\n\tprotected async _streamResourceFork() {\n\t\tconst readRsrc = this._readRsrc;\n\t\tif (!readRsrc) {\n\t\t\tthrow new Error('Internal error');\n\t\t}\n\t\treturn readRsrc();\n\t}\n\n\t/**\n\t * Read directory null stream.\n\t *\n\t * @returns Null stream.\n\t */\n\tprotected async _streamDirectory() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Read symlink as stream.\n\t *\n\t * @returns Readable stream.\n\t */\n\tprotected async _streamSymlink() {\n\t\tconst readSymlink = this._readSymlink;\n\t\tif (!readSymlink) {\n\t\t\tthrow new Error('Internal error');\n\t\t}\n\t\tconst r = new Readable({\n\t\t\t// eslint-disable-next-line jsdoc/require-jsdoc\n\t\t\tread: () => {\n\t\t\t\treadSymlink().then(\n\t\t\t\t\td => {\n\t\t\t\t\t\tr.push(d);\n\t\t\t\t\t\t// eslint-disable-next-line unicorn/no-array-push-push\n\t\t\t\t\t\tr.push(null);\n\t\t\t\t\t},\n\t\t\t\t\terr => {\n\t\t\t\t\t\tr.emit('error', err);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t\treturn r;\n\t}\n}\n\n/**\n * Archive object.\n */\nexport abstract class Archive {\n\t/**\n\t * List of file extensions, or null.\n\t */\n\tpublic static readonly FILE_EXTENSIONS: readonly string[] | null = null;\n\n\t/**\n\t * Archive has named volumes that each entry will be under.\n\t */\n\tpublic static readonly HAS_NAMED_VOLUMES: boolean = false;\n\n\t/**\n\t * Entry constructor.\n\t */\n\tpublic readonly Entry = Entry;\n\n\t/**\n\t * File path.\n\t */\n\tpublic readonly path: string;\n\n\t/**\n\t * Flag for currently reading.\n\t */\n\tprotected _reading = false;\n\n\t/**\n\t * Map of entries to set attributes on after reading.\n\t */\n\tprotected _afterReadSetAttributes: Map<\n\t\tstring,\n\t\tReadonly<IArchiveAfterReadSetAttributesEntry>\n\t> | null = null;\n\n\t/**\n\t * Archive constructor.\n\t *\n\t * @param path File path.\n\t */\n\tconstructor(path: string) {\n\t\tthis.path = path;\n\t}\n\n\t/**\n\t * List of file extensions used by this format.\n\t *\n\t * @returns List of file extensions.\n\t */\n\tpublic get fileExtensions() {\n\t\treturn (this.constructor as typeof Archive).FILE_EXTENSIONS || null;\n\t}\n\n\t/**\n\t * Archive has named volumes that each entry will be under.\n\t *\n\t * @returns Archive has named volumns.\n\t */\n\tpublic get hasNamedVolumes() {\n\t\treturn (this.constructor as typeof Archive).HAS_NAMED_VOLUMES;\n\t}\n\n\t/**\n\t * Add an instance to set attributes after the read finishes.\n\t *\n\t * @param path Path string.\n\t * @param entry Entry instance.\n\t * @param options Extract options.\n\t */\n\tpublic afterReadSetAttributes(\n\t\tpath: string,\n\t\tentry: Entry,\n\t\toptions: Readonly<IExtractOptions> = {}\n\t) {\n\t\tconst afters = this._afterReadSetAttributes;\n\t\tif (!afters) {\n\t\t\tthrow new Error(\n\t\t\t\t'Archive after read callbacks can only be added while reading'\n\t\t\t);\n\t\t}\n\t\tafters.set(resolve(path), {\n\t\t\tpath,\n\t\t\tentry,\n\t\t\toptions\n\t\t});\n\t}\n\n\t/**\n\t * Remove an instance to set attributes after the read finishes.\n\t *\n\t * @param path Path string.\n\t */\n\tpublic afterReadSetAttributesRemove(path: string) {\n\t\tconst afters = this._afterReadSetAttributes;\n\t\tif (!afters) {\n\t\t\tthrow new Error(\n\t\t\t\t'Archive after read callbacks can only be removed while reading'\n\t\t\t);\n\t\t}\n\t\tafters.delete(resolve(path));\n\t}\n\n\t/**\n\t * Read archive.\n\t * If the itter callback returns false, reading ends.\n\t * If the itter callback returns null, skip descent where available.\n\t *\n\t * @param itter Async callback for each archive entry.\n\t */\n\tpublic async read(itter: (entry: Entry) => Promise<unknown>) {\n\t\tif (this._reading) {\n\t\t\tthrow new Error('Archive already being read');\n\t\t}\n\t\tthis._reading = true;\n\n\t\t// Reset the after entries.\n\t\tthis._afterReadSetAttributes = new Map();\n\n\t\t// Read and handle all the afters, reset after.\n\t\ttry {\n\t\t\tawait this._read(itter);\n\t\t\tawait this._afterReadSetAttributesTrigger();\n\t\t} finally {\n\t\t\tthis._afterReadSetAttributes = null;\n\t\t\tthis._reading = false;\n\t\t}\n\t}\n\n\t/**\n\t * Run all after read set attributes.\n\t */\n\tprotected async _afterReadSetAttributesTrigger() {\n\t\tconst afters = this._afterReadSetAttributes;\n\t\tif (!afters) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Prioritize by path length.\n\t\tconst resolves: string[] = [];\n\t\tfor (const [resolved] of afters) {\n\t\t\tresolves.push(resolved);\n\t\t}\n\t\tresolves.sort((a, b) => b.length - a.length);\n\n\t\tfor (const resolved of resolves) {\n\t\t\tconst ent = afters.get(resolved);\n\t\t\tif (!ent) {\n\t\t\t\tthrow new Error('Internal error');\n\t\t\t}\n\t\t\tconst {entry, path, options} = ent;\n\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\tawait entry.setAttributes(path, resolved, options);\n\t\t}\n\t}\n\n\t/**\n\t * Read archive, class implementation.\n\t * If the itter callback returns false, reading ends.\n\t * If the itter callback returns null, skip descent where available.\n\t *\n\t * @param itter Async callback for each archive entry.\n\t */\n\tprotected abstract _read(\n\t\titter: (entry: Entry) => Promise<unknown>\n\t): Promise<void>;\n}\n"],"mappings":"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","ignoreList":[]}