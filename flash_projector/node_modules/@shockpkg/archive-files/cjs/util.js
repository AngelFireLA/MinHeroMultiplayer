"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bitwiseAndEqual = bitwiseAndEqual;
exports.fsChmod = fsChmod;
exports.fsLchmod = fsLchmod;
exports.fsLchmodSupported = void 0;
exports.fsLstat = fsLstat;
exports.fsLstatExists = fsLstatExists;
exports.fsLutimes = fsLutimes;
exports.fsLutimesSupported = void 0;
exports.fsReaddir = fsReaddir;
exports.fsReadlinkRaw = fsReadlinkRaw;
exports.fsSymlink = fsSymlink;
exports.fsUtimes = fsUtimes;
exports.fsWalk = fsWalk;
exports.modePermissionBits = modePermissionBits;
exports.modeToPathType = modeToPathType;
exports.pathNormalize = pathNormalize;
exports.pathResourceFork = pathResourceFork;
exports.statToPathType = statToPathType;
exports.streamToBuffer = streamToBuffer;
var _nodeFs = require("node:fs");
var _promises = require("node:fs/promises");
var _nodePath = require("node:path");
var _nodeStream = require("node:stream");
var _promises2 = require("node:stream/promises");
var _types = require("./types.js");
const {
  O_WRONLY,
  O_SYMLINK
} = _nodeFs.constants;
const fsLchmodSupported = exports.fsLchmodSupported = !!O_SYMLINK;
const fsLutimesSupported = exports.fsLutimesSupported = !!O_SYMLINK;

/**
 * Normalize an entry path.
 *
 * @param path Path string.
 * @returns Normalized path.
 */
function pathNormalize(path) {
  return path.replace(/\\/g, '/').replace(/([^/])\/+$/, '$1');
}

/**
 * Get path to the resource fork pseudo-file.
 *
 * @param path Path string.
 * @returns Resource fork pseudo-file path.
 */
function pathResourceFork(path) {
  return (0, _nodePath.join)(path, '..namedfork', 'rsrc');
}

/**
 * Get path type from stat object, or null if unsupported.
 *
 * @param stat Stats object.
 * @returns Path type.
 */
function statToPathType(stat) {
  if (stat.isSymbolicLink()) {
    return _types.PathType.SYMLINK;
  }
  if (stat.isDirectory()) {
    return _types.PathType.DIRECTORY;
  }
  if (stat.isFile()) {
    return _types.PathType.FILE;
  }
  return null;
}

/**
 * Get path type from stat mode, or null if unsupported.
 *
 * @param mode Stat mode.
 * @returns Path type.
 */
function modeToPathType(mode) {
  if (bitwiseAndEqual(mode, 0o0120000)) {
    return _types.PathType.SYMLINK;
  }
  if (bitwiseAndEqual(mode, 0o0040000)) {
    return _types.PathType.DIRECTORY;
  }
  if (bitwiseAndEqual(mode, 0o0100000)) {
    return _types.PathType.FILE;
  }
  return null;
}

/**
 * Get permission bits from mode value.
 *
 * @param mode Stat mode.
 * @returns Permission bits.
 */
function modePermissionBits(mode) {
  // eslint-disable-next-line no-bitwise
  return mode & 0b111111111;
}

/**
 * Check if all the bits set.
 *
 * @param value Bits value.
 * @param mask Mask value.
 * @returns True of all the bits set.
 */
function bitwiseAndEqual(value, mask) {
  // eslint-disable-next-line no-bitwise
  return (value & mask) === mask;
}

/**
 * Read a stream into a buffer.
 * Reading a stream into a buffer should be avoided where possible.
 * This is however useful for some small streams.
 *
 * @param stream Readable stream.
 * @returns Full buffer.
 */
async function streamToBuffer(stream) {
  const datas = [];
  let size = 0;
  await (0, _promises2.pipeline)(stream, new _nodeStream.Writable({
    // eslint-disable-next-line jsdoc/require-jsdoc
    write: (data, _encoding, cb) => {
      datas.push(data);
      size += data.length;
      cb();
    }
  }));
  return Buffer.concat(datas, size);
}

/**
 * Wrapper for lchmod, does nothing on unsupported platforms.
 *
 * @param path File path.
 * @param mode File mode.
 */
async function fsLchmod(path, mode) {
  // Skip if not supported.
  if (!fsLchmodSupported) {
    return;
  }

  // eslint-disable-next-line no-bitwise
  const fd = await (0, _promises.open)(path, O_WRONLY | O_SYMLINK);
  try {
    await fd.chmod(mode);
  } finally {
    await fd.close();
  }
}

/**
 * Wrapper for utimes.
 *
 * @param path File path.
 * @param atime Access time.
 * @param mtime Modification time.
 */
async function fsUtimes(path, atime, mtime) {
  await (0, _promises.utimes)(path, atime, mtime);
}

/**
 * Implementation of lutimes, does nothing on unsupported platforms.
 *
 * @param path File path.
 * @param atime Access time.
 * @param mtime Modification time.
 */
async function fsLutimes(path, atime, mtime) {
  // Skip if not supported.
  if (!fsLutimesSupported) {
    return;
  }

  // eslint-disable-next-line no-bitwise
  const fd = await (0, _promises.open)(path, O_WRONLY | O_SYMLINK);
  try {
    await fd.utimes(atime, mtime);
  } finally {
    await fd.close();
  }
}

/**
 * A readlink wrapper that returns raw link buffer.
 *
 * @param path Link path.
 * @returns Raw link.
 */
async function fsReadlinkRaw(path) {
  return (0, _promises.readlink)(path, 'buffer');
}

/**
 * Wrapper for symlink.
 *
 * @param path Path of symbolic link.
 * @param target Target of symbolic link.
 */
async function fsSymlink(path, target) {
  await (0, _promises.symlink)(target, path);
}

/**
 * Wrapper for chmod.
 *
 * @param path File path.
 * @param mode File mode.
 */
async function fsChmod(path, mode) {
  await (0, _promises.chmod)(path, mode);
}

/**
 * A readdir wrapper with consistent output.
 *
 * @param path Directory path.
 * @returns Directory listing.
 */
async function fsReaddir(path) {
  return (await (0, _promises.readdir)(path)).sort();
}

/**
 * An lstat wrapper.
 *
 * @param path Path string.
 * @returns Stat object.
 */
async function fsLstat(path) {
  return (0, _promises.lstat)(path);
}

/**
 * An lstat wrapper returning null if not exist.
 *
 * @param path Path string.
 * @returns Stat object.
 */
async function fsLstatExists(path) {
  try {
    return await fsLstat(path);
  } catch (err) {
    const {
      code
    } = err;
    if (code === 'ENOENT' || code === 'ENOTDIR') {
      return null;
    }
    throw err;
  }
}

/**
 * Walk file system path.
 * If callback returns false skips recursing a directory.
 * If callback returns null aborts walking.
 *
 * @param base Directory path.
 * @param itter Callback for each entry.
 * @param options Walk options.
 */
async function fsWalk(base, itter, options = {}) {
  const {
    ignoreUnreadableDirectories
  } = options;
  const stack = (await fsReaddir(base)).reverse();
  while (stack.length) {
    const entry = stack.pop();
    const fullPath = (0, _nodePath.join)(base, entry);
    // eslint-disable-next-line no-await-in-loop
    const stat = await fsLstat(fullPath);

    // Callback, possibly stop recursion on directory.
    // eslint-disable-next-line no-await-in-loop
    const recurse = await itter(entry, stat);
    if (recurse === null) {
      break;
    }
    if (recurse === false || !stat.isDirectory()) {
      continue;
    }

    // Recurse down.
    let subs = [];
    try {
      // eslint-disable-next-line no-await-in-loop
      subs = await fsReaddir(fullPath);
    } catch (err) {
      if (!(err && ignoreUnreadableDirectories && err.code === 'EACCES')) {
        throw err;
      }
    }
    for (let i = subs.length; i--;) {
      stack.push((0, _nodePath.join)(entry, subs[i]));
    }
  }
}
//# sourceMappingURL=util.js.map