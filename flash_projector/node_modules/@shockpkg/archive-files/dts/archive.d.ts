import { Readable } from 'node:stream';
import { PathType } from './types.ts';
export interface IArchiveAfterReadSetAttributesEntry {
    /**
     * Extract path, relative.
     */
    path: string;
    /**
     * Entry.
     */
    entry: Entry;
    /**
     * Extract options.
     */
    options: IExtractOptions;
}
export interface IExtractOptions {
    /**
     * Replace whatever may be at the path.
     * A directory will not replace another directory.
     *
     * @default false
     */
    replace?: boolean;
    /**
     * Ignore permissions when extracting.
     *
     * @default false
     */
    ignorePermissions?: boolean;
    /**
     * Ignore file modification and access times when extracting.
     *
     * @default false
     */
    ignoreTimes?: boolean;
    /**
     * Extract resource fork as a file.
     *
     * @default false
     */
    resourceForkAsFile?: boolean;
    /**
     * Extract symlink as a file.
     *
     * @default false
     */
    symlinkAsFile?: boolean;
}
export interface IEntryInfo {
    /**
     * Entry archive.
     */
    archive: Archive;
    /**
     * Entry type.
     */
    type: PathType;
    /**
     * Entry path, raw.
     */
    pathRaw: string;
    /**
     * Entry size.
     */
    size?: number | null;
    /**
     * Entry size, compressed.
     */
    sizeComp?: number | null;
    /**
     * Entry mode.
     */
    mode?: number | null;
    /**
     * Entry uid.
     */
    uid?: number | null;
    /**
     * Entry gid.
     */
    gid?: number | null;
    /**
     * Entry uname.
     */
    uname?: string | null;
    /**
     * Entry gname.
     */
    gname?: string | null;
    /**
     * Entry atime.
     */
    atime?: Date | null;
    /**
     * Entry mtime.
     */
    mtime?: Date | null;
    /**
     * Read data.
     */
    readData?: (() => Promise<Readable | null>) | null;
    /**
     * Read rsrc.
     */
    readRsrc?: (() => Promise<Readable | null>) | null;
    /**
     * Read symlink.
     */
    readSymlink?: (() => Promise<Buffer>) | null;
}
/**
 * Entry object.
 */
export declare abstract class Entry {
    /**
     * Entry archive.
     */
    readonly archive: Archive;
    /**
     * Entry type.
     */
    readonly type: PathType;
    /**
     * Entry path.
     */
    readonly path: string;
    /**
     * Entry path, raw.
     */
    readonly pathRaw: string;
    /**
     * Entry size.
     */
    readonly size: number | null;
    /**
     * Entry size, compressed.
     */
    readonly sizeComp: number | null;
    /**
     * Entry mode.
     */
    readonly mode: number | null;
    /**
     * Entry uid.
     */
    readonly uid: number | null;
    /**
     * Entry gid.
     */
    readonly gid: number | null;
    /**
     * Entry uname.
     */
    readonly uname: string | null;
    /**
     * Entry gname.
     */
    readonly gname: string | null;
    /**
     * Entry atime.
     */
    readonly atime: Date | null;
    /**
     * Entry mtime.
     */
    readonly mtime: Date | null;
    /**
     * Read data.
     */
    protected readonly _readData: (() => Promise<Readable | null>) | null;
    /**
     * Read rsrc.
     */
    protected readonly _readRsrc: (() => Promise<Readable | null>) | null;
    /**
     * Read symlink.
     */
    protected readonly _readSymlink: (() => Promise<Buffer>) | null;
    /**
     * Entry triggering.
     */
    protected _triggering: boolean;
    /**
     * Entry triggered.
     */
    protected _triggered: boolean;
    /**
     * Entry extracted.
     */
    protected _extracted: boolean;
    /**
     * Entry constructor.
     *
     * @param info Info object.
     */
    constructor(info: Readonly<IEntryInfo>);
    /**
     * This entry path includes named volume.
     *
     * @returns Entry has volume name in path.
     */
    get hasNamedVolume(): boolean;
    /**
     * This entry volume name, or null.
     *
     * @returns Entry path volume name.
     */
    get volumeName(): string | null;
    /**
     * This entry path without any possible volume name.
     *
     * @returns Entry path without the volume name.
     */
    get volumePath(): string;
    /**
     * Read entry as stream, or null if nothing to read.
     * Consuming function will need to wait for stream to close.
     *
     * @returns Readable stream or null if nothing to read.
     */
    stream(): Promise<Readable | null>;
    /**
     * Read entire entry into a Buffer.
     *
     * @returns Buffer or null if nothing to be read.
     */
    read(): Promise<Buffer | null>;
    /**
     * Extract entry.
     *
     * @param path Extract path.
     * @param options Extract options.
     */
    extract(path: string, options?: Readonly<IExtractOptions>): Promise<void>;
    /**
     * Trigger on itterator function.
     *
     * @param itter Itterator function.
     * @returns Return value.
     */
    trigger<T, U extends (entry: this) => Promise<T>>(itter: U): Promise<T>;
    /**
     * Run again after reading.
     *
     * @param path Extract path, relative.
     * @param pathFull An optional full path to be used.
     * @param options Extract options.
     */
    setAttributes(path: string, pathFull?: string | null, options?: Readonly<IExtractOptions>): Promise<void>;
    /**
     * Method to call before begining extraction.
     * Throws error if extraction already started or entry not active.
     */
    protected _beginExtract(): void;
    /**
     * Create an extract error for path that exists.
     *
     * @param path Extract path.
     * @returns Error object.
     */
    protected _errorExtractPathExists(path: string): Error;
    /**
     * Create an extract error for a resource fork not going to a file.
     *
     * @param path Extract path.
     * @returns Error object.
     */
    protected _errorNoResourceFork(path: string): Error;
    /**
     * Extract entry.
     *
     * @param path Extract path.
     * @param options Extract options.
     */
    protected _extract(path: string, options: Readonly<IExtractOptions>): Promise<void>;
    /**
     * Base function for extracting stream to a file.
     *
     * @param path Extract path.
     * @param reader Reader function.
     * @param options Extract options.
     */
    protected _extractStreamToFile(path: string, reader: () => Promise<Readable | null>, options: Readonly<IExtractOptions>): Promise<void>;
    /**
     * Extract as a file.
     *
     * @param path Extract path.
     * @param options Extract options.
     */
    protected _extractFile(path: string, options: Readonly<IExtractOptions>): Promise<void>;
    /**
     * Extract as resource fork to an existing file.
     *
     * @param path Extract path.
     * @param options Extract options.
     */
    protected _extractResourceFork(path: string, options: Readonly<IExtractOptions>): Promise<void>;
    /**
     * Extract as a directory.
     *
     * @param path Extract path.
     * @param options Extract options.
     */
    protected _extractDirectory(path: string, options: Readonly<IExtractOptions>): Promise<void>;
    /**
     * Extract as a symlink.
     *
     * @param path Extract path.
     * @param options Extract options.
     */
    protected _extractSymlink(path: string, options: Readonly<IExtractOptions>): Promise<void>;
    /**
     * Read as stream.
     *
     * @returns Readable stream.
     */
    protected _stream(): Promise<Readable | null>;
    /**
     * Read file as stream.
     *
     * @returns Readable stream.
     */
    protected _streamFile(): Promise<Readable | null>;
    /**
     * Read resource fork as stream.
     *
     * @returns Readable stream.
     */
    protected _streamResourceFork(): Promise<Readable | null>;
    /**
     * Read directory null stream.
     *
     * @returns Null stream.
     */
    protected _streamDirectory(): Promise<null>;
    /**
     * Read symlink as stream.
     *
     * @returns Readable stream.
     */
    protected _streamSymlink(): Promise<Readable>;
}
/**
 * Archive object.
 */
export declare abstract class Archive {
    /**
     * List of file extensions, or null.
     */
    static readonly FILE_EXTENSIONS: readonly string[] | null;
    /**
     * Archive has named volumes that each entry will be under.
     */
    static readonly HAS_NAMED_VOLUMES: boolean;
    /**
     * Entry constructor.
     */
    readonly Entry: typeof Entry;
    /**
     * File path.
     */
    readonly path: string;
    /**
     * Flag for currently reading.
     */
    protected _reading: boolean;
    /**
     * Map of entries to set attributes on after reading.
     */
    protected _afterReadSetAttributes: Map<string, Readonly<IArchiveAfterReadSetAttributesEntry>> | null;
    /**
     * Archive constructor.
     *
     * @param path File path.
     */
    constructor(path: string);
    /**
     * List of file extensions used by this format.
     *
     * @returns List of file extensions.
     */
    get fileExtensions(): readonly string[] | null;
    /**
     * Archive has named volumes that each entry will be under.
     *
     * @returns Archive has named volumns.
     */
    get hasNamedVolumes(): boolean;
    /**
     * Add an instance to set attributes after the read finishes.
     *
     * @param path Path string.
     * @param entry Entry instance.
     * @param options Extract options.
     */
    afterReadSetAttributes(path: string, entry: Entry, options?: Readonly<IExtractOptions>): void;
    /**
     * Remove an instance to set attributes after the read finishes.
     *
     * @param path Path string.
     */
    afterReadSetAttributesRemove(path: string): void;
    /**
     * Read archive.
     * If the itter callback returns false, reading ends.
     * If the itter callback returns null, skip descent where available.
     *
     * @param itter Async callback for each archive entry.
     */
    read(itter: (entry: Entry) => Promise<unknown>): Promise<void>;
    /**
     * Run all after read set attributes.
     */
    protected _afterReadSetAttributesTrigger(): Promise<void>;
    /**
     * Read archive, class implementation.
     * If the itter callback returns false, reading ends.
     * If the itter callback returns null, skip descent where available.
     *
     * @param itter Async callback for each archive entry.
     */
    protected abstract _read(itter: (entry: Entry) => Promise<unknown>): Promise<void>;
}
