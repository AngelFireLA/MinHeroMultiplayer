var FormatBase = /** @class */ (function () {
    function FormatBase(view) {
        this.view = view;
    }
    FormatBase.prototype.copyTo = function (bin, offset) {
        new Uint8Array(bin, offset, this.view.byteLength).set(new Uint8Array(this.view.buffer, this.view.byteOffset, this.view.byteLength));
    };
    Object.defineProperty(FormatBase.prototype, "byteLength", {
        get: function () {
            return this.view.byteLength;
        },
        enumerable: false,
        configurable: true
    });
    return FormatBase;
}());

var __extends$b = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/** abstract class that support array-like methods and 'for...of' operation */
var ArrayFormatBase = /** @class */ (function (_super) {
    __extends$b(ArrayFormatBase, _super);
    function ArrayFormatBase(view) {
        return _super.call(this, view) || this;
    }
    ArrayFormatBase.prototype.forEach = function (callback) {
        var len = this.length;
        var a = [];
        a.length = len;
        for (var i = 0; i < len; ++i) {
            a[i] = this.get(i);
        }
        for (var i = 0; i < len; ++i) {
            callback(a[i], i, this);
        }
    };
    ArrayFormatBase.prototype._iterator = function () {
        return new (/** @class */ (function () {
            function class_1(base) {
                this.base = base;
                this.i = 0;
            }
            class_1.prototype.next = function () {
                if (this.i === this.base.length) {
                    return {
                        value: undefined,
                        done: true,
                    };
                }
                else {
                    return {
                        value: this.base.get(this.i++),
                        done: false,
                    };
                }
            };
            return class_1;
        }()))(this);
    };
    return ArrayFormatBase;
}(FormatBase));
/* istanbul ignore else */
if (typeof Symbol !== 'undefined') {
    ArrayFormatBase.prototype[Symbol.iterator] =
        ArrayFormatBase.prototype._iterator;
}

var __extends$a = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ImageDataDirectoryArray = /** @class */ (function (_super) {
    __extends$a(ImageDataDirectoryArray, _super);
    function ImageDataDirectoryArray(view) {
        var _this = _super.call(this, view) || this;
        _this.length = 16;
        return _this;
    }
    /** @note This does not clone binary data; the changes to the array will modify the specified buffer `bin` */
    ImageDataDirectoryArray.from = function (bin, offset) {
        if (offset === void 0) { offset = 0; }
        return new ImageDataDirectoryArray(new DataView(bin, offset, 128));
    };
    ImageDataDirectoryArray.prototype.get = function (index) {
        return {
            virtualAddress: this.view.getUint32(index * 8, true),
            size: this.view.getUint32(4 + index * 8, true),
        };
    };
    ImageDataDirectoryArray.prototype.set = function (index, data) {
        this.view.setUint32(index * 8, data.virtualAddress, true);
        this.view.setUint32(4 + index * 8, data.size, true);
    };
    ImageDataDirectoryArray.prototype.findIndexByVirtualAddress = function (virtualAddress) {
        for (var i = 0; i < 16; ++i) {
            var va = this.view.getUint32(i * 8, true);
            var vs = this.view.getUint32(4 + i * 8, true);
            if (virtualAddress >= va && virtualAddress < va + vs) {
                return i;
            }
        }
        return null;
    };
    ImageDataDirectoryArray.size = 128; // 16 * 8
    ImageDataDirectoryArray.itemSize = 8;
    return ImageDataDirectoryArray;
}(ArrayFormatBase));

var ImageDirectoryEntry;
(function (ImageDirectoryEntry) {
    ImageDirectoryEntry[ImageDirectoryEntry["Export"] = 0] = "Export";
    ImageDirectoryEntry[ImageDirectoryEntry["Import"] = 1] = "Import";
    ImageDirectoryEntry[ImageDirectoryEntry["Resource"] = 2] = "Resource";
    ImageDirectoryEntry[ImageDirectoryEntry["Exception"] = 3] = "Exception";
    ImageDirectoryEntry[ImageDirectoryEntry["Certificate"] = 4] = "Certificate";
    // alias
    ImageDirectoryEntry[ImageDirectoryEntry["Security"] = 4] = "Security";
    ImageDirectoryEntry[ImageDirectoryEntry["BaseRelocation"] = 5] = "BaseRelocation";
    ImageDirectoryEntry[ImageDirectoryEntry["Debug"] = 6] = "Debug";
    ImageDirectoryEntry[ImageDirectoryEntry["Architecture"] = 7] = "Architecture";
    ImageDirectoryEntry[ImageDirectoryEntry["GlobalPointer"] = 8] = "GlobalPointer";
    ImageDirectoryEntry[ImageDirectoryEntry["Tls"] = 9] = "Tls";
    ImageDirectoryEntry[ImageDirectoryEntry["TLS"] = 9] = "TLS";
    ImageDirectoryEntry[ImageDirectoryEntry["LoadConfig"] = 10] = "LoadConfig";
    ImageDirectoryEntry[ImageDirectoryEntry["BoundImport"] = 11] = "BoundImport";
    ImageDirectoryEntry[ImageDirectoryEntry["Iat"] = 12] = "Iat";
    ImageDirectoryEntry[ImageDirectoryEntry["IAT"] = 12] = "IAT";
    ImageDirectoryEntry[ImageDirectoryEntry["DelayImport"] = 13] = "DelayImport";
    ImageDirectoryEntry[ImageDirectoryEntry["ComDescriptor"] = 14] = "ComDescriptor";
    ImageDirectoryEntry[ImageDirectoryEntry["COMDescriptor"] = 14] = "COMDescriptor";
})(ImageDirectoryEntry || (ImageDirectoryEntry = {}));
var ImageDirectoryEntry$1 = ImageDirectoryEntry;

// eslint-disable-next-line @typescript-eslint/triple-slash-reference
/// <reference lib='dom' />
function cloneObject$1(object) {
    var r = {};
    Object.keys(object).forEach(function (key) {
        r[key] = object[key];
    });
    return r;
}
/* eslint-enable @typescript-eslint/ban-types */
function createDataView$1(bin, byteOffset, byteLength) {
    if ('buffer' in bin) {
        var newOffset = bin.byteOffset;
        var newLength = bin.byteLength;
        if (typeof byteOffset !== 'undefined') {
            newOffset += byteOffset;
            newLength -= byteOffset;
        }
        if (typeof byteLength !== 'undefined') {
            newLength = byteLength;
        }
        return new DataView(bin.buffer, newOffset, newLength);
    }
    else {
        return new DataView(bin, byteOffset, byteLength);
    }
}
function calculateCheckSumForPE(bin, storeToBinary) {
    var dosHeader = ImageDosHeader.from(bin);
    var view = new DataView(bin);
    var checkSumOffset = dosHeader.newHeaderAddress + 88;
    var result = 0;
    var limit = 0x100000000; // 2^32
    var update = function (dword) {
        result += dword;
        if (result >= limit) {
            result = (result % limit) + ((result / limit) | 0);
        }
    };
    var len = view.byteLength;
    var lenExtra = len % 4;
    var lenAlign = len - lenExtra;
    for (var i = 0; i < lenAlign; i += 4) {
        if (i !== checkSumOffset) {
            update(view.getUint32(i, true));
        }
    }
    if (lenExtra !== 0) {
        var extra = 0;
        for (var i = 0; i < lenExtra; i++) {
            extra |= view.getUint8(lenAlign + i) << ((3 - i) * 8);
        }
        update(extra);
    }
    result = (result & 0xffff) + (result >>> 16);
    result += result >>> 16;
    result = (result & 0xffff) + len;
    if (storeToBinary) {
        view.setUint32(checkSumOffset, result, true);
    }
    return result;
}
function roundUp$1(val, align) {
    return Math.floor((val + align - 1) / align) * align;
}
function copyBuffer$1(dest, destOffset, src, srcOffset, length) {
    var ua8Dest = 'buffer' in dest
        ? new Uint8Array(dest.buffer, dest.byteOffset + (destOffset || 0), length)
        : new Uint8Array(dest, destOffset, length);
    var ua8Src = 'buffer' in src
        ? new Uint8Array(src.buffer, src.byteOffset + (srcOffset || 0), length)
        : new Uint8Array(src, srcOffset, length);
    ua8Dest.set(ua8Src);
}
function allocatePartialBinary$1(binBase, offset, length) {
    var b = new ArrayBuffer(length);
    copyBuffer$1(b, 0, binBase, offset, length);
    return b;
}
function cloneToArrayBuffer$1(binBase) {
    if ('buffer' in binBase) {
        var b = new ArrayBuffer(binBase.byteLength);
        new Uint8Array(b).set(new Uint8Array(binBase.buffer, binBase.byteOffset, binBase.byteLength));
        return b;
    }
    else {
        var b = new ArrayBuffer(binBase.byteLength);
        new Uint8Array(b).set(new Uint8Array(binBase));
        return b;
    }
}
function getFixedString(view, offset, length) {
    var actualLen = 0;
    for (var i = 0; i < length; ++i) {
        if (view.getUint8(offset + i) === 0) {
            break;
        }
        ++actualLen;
    }
    if (typeof Buffer !== 'undefined') {
        return Buffer.from(view.buffer, view.byteOffset + offset, actualLen).toString('utf8');
    }
    else if (typeof decodeURIComponent !== 'undefined') {
        var s = '';
        for (var i = 0; i < actualLen; ++i) {
            var c = view.getUint8(offset + i);
            if (c < 16) {
                s += '%0' + c.toString(16);
            }
            else {
                s += '%' + c.toString(16);
            }
        }
        return decodeURIComponent(s);
    }
    else {
        var s = '';
        for (var i = 0; i < actualLen; ++i) {
            var c = view.getUint8(offset + i);
            s += String.fromCharCode(c);
        }
        return s;
    }
}
function setFixedString(view, offset, length, text) {
    if (typeof Buffer !== 'undefined') {
        var u = new Uint8Array(view.buffer, view.byteOffset + offset, length);
        // fill by zero
        u.set(new Uint8Array(length));
        u.set(Buffer.from(text, 'utf8').subarray(0, length));
    }
    else if (typeof encodeURIComponent !== 'undefined') {
        var s = encodeURIComponent(text);
        for (var i = 0, j = 0; i < length; ++i) {
            if (j >= s.length) {
                view.setUint8(i + offset, 0);
            }
            else {
                var c = s.charCodeAt(j);
                if (c === 37) {
                    // '%'
                    var n = parseInt(s.substr(j + 1, 2), 16);
                    if (typeof n === 'number' && !isNaN(n)) {
                        view.setUint8(i + offset, n);
                    }
                    else {
                        view.setUint8(i + offset, 0);
                    }
                    j += 3;
                }
                else {
                    view.setUint8(i + offset, c);
                }
            }
        }
    }
    else {
        for (var i = 0, j = 0; i < length; ++i) {
            if (j >= text.length) {
                view.setUint8(i + offset, 0);
            }
            else {
                var c = text.charCodeAt(j);
                view.setUint8(i + offset, c & 0xff);
            }
        }
    }
}
function binaryToString(bin) {
    if (typeof TextDecoder !== 'undefined') {
        var dec = new TextDecoder();
        return dec.decode(bin);
    }
    else if (typeof Buffer !== 'undefined') {
        var b = void 0;
        if ('buffer' in bin) {
            b = Buffer.from(bin.buffer, bin.byteOffset, bin.byteLength);
        }
        else {
            b = Buffer.from(bin);
        }
        return b.toString('utf8');
    }
    else {
        var view = void 0;
        if ('buffer' in bin) {
            view = new Uint8Array(bin.buffer, bin.byteOffset, bin.byteLength);
        }
        else {
            view = new Uint8Array(bin);
        }
        if (typeof decodeURIComponent !== 'undefined') {
            var s = '';
            for (var i = 0; i < view.length; ++i) {
                var c = view[i];
                if (c < 16) {
                    s += '%0' + c.toString(16);
                }
                else {
                    s += '%' + c.toString(16);
                }
            }
            return decodeURIComponent(s);
        }
        else {
            var s = '';
            for (var i = 0; i < view.length; ++i) {
                var c = view[i];
                s += String.fromCharCode(c);
            }
            return s;
        }
    }
}
function stringToBinary(string) {
    if (typeof TextEncoder !== 'undefined') {
        var enc = new TextEncoder();
        return cloneToArrayBuffer$1(enc.encode(string));
    }
    else if (typeof Buffer !== 'undefined') {
        return cloneToArrayBuffer$1(Buffer.from(string, 'utf8'));
    }
    else if (typeof encodeURIComponent !== 'undefined') {
        var data = encodeURIComponent(string);
        var len = 0;
        for (var i = 0; i < data.length; ++len) {
            var c = data.charCodeAt(i);
            if (c === 37) {
                i += 3;
            }
            else {
                ++i;
            }
        }
        var bin = new ArrayBuffer(len);
        var view = new Uint8Array(bin);
        for (var i = 0, j = 0; i < data.length; ++j) {
            var c = data.charCodeAt(i);
            if (c === 37) {
                var n = parseInt(data.substring(i + 1, i + 3), 16);
                view[j] = n;
                i += 3;
            }
            else {
                view[j] = c;
                ++i;
            }
        }
        return bin;
    }
    else {
        var bin = new ArrayBuffer(string.length);
        new Uint8Array(bin).set([].map.call(string, function (c) {
            return c.charCodeAt(0);
        }));
        return bin;
    }
}

var __extends$9 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ImageDosHeader = /** @class */ (function (_super) {
    __extends$9(ImageDosHeader, _super);
    function ImageDosHeader(view) {
        return _super.call(this, view) || this;
    }
    ImageDosHeader.from = function (bin, offset) {
        if (offset === void 0) { offset = 0; }
        return new ImageDosHeader(createDataView$1(bin, offset, 64));
    };
    ImageDosHeader.prototype.isValid = function () {
        return this.magic === ImageDosHeader.DEFAULT_MAGIC;
    };
    Object.defineProperty(ImageDosHeader.prototype, "magic", {
        get: function () {
            return this.view.getUint16(0, true);
        },
        set: function (val) {
            this.view.setUint16(0, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageDosHeader.prototype, "lastPageSize", {
        get: function () {
            return this.view.getUint16(2, true);
        },
        set: function (val) {
            this.view.setUint16(2, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageDosHeader.prototype, "pages", {
        get: function () {
            return this.view.getUint16(4, true);
        },
        set: function (val) {
            this.view.setUint16(4, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageDosHeader.prototype, "relocations", {
        get: function () {
            return this.view.getUint16(6, true);
        },
        set: function (val) {
            this.view.setUint16(6, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageDosHeader.prototype, "headerSizeInParagraph", {
        get: function () {
            return this.view.getUint16(8, true);
        },
        set: function (val) {
            this.view.setUint16(8, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageDosHeader.prototype, "minAllocParagraphs", {
        get: function () {
            return this.view.getUint16(10, true);
        },
        set: function (val) {
            this.view.setUint16(10, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageDosHeader.prototype, "maxAllocParagraphs", {
        get: function () {
            return this.view.getUint16(12, true);
        },
        set: function (val) {
            this.view.setUint16(12, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageDosHeader.prototype, "initialSS", {
        get: function () {
            return this.view.getUint16(14, true);
        },
        set: function (val) {
            this.view.setUint16(14, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageDosHeader.prototype, "initialSP", {
        get: function () {
            return this.view.getUint16(16, true);
        },
        set: function (val) {
            this.view.setUint16(16, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageDosHeader.prototype, "checkSum", {
        get: function () {
            return this.view.getUint16(18, true);
        },
        set: function (val) {
            this.view.setUint16(18, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageDosHeader.prototype, "initialIP", {
        get: function () {
            return this.view.getUint16(20, true);
        },
        set: function (val) {
            this.view.setUint16(20, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageDosHeader.prototype, "initialCS", {
        get: function () {
            return this.view.getUint16(22, true);
        },
        set: function (val) {
            this.view.setUint16(22, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageDosHeader.prototype, "relocationTableAddress", {
        get: function () {
            return this.view.getUint16(24, true);
        },
        set: function (val) {
            this.view.setUint16(24, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageDosHeader.prototype, "overlayNum", {
        get: function () {
            return this.view.getUint16(26, true);
        },
        set: function (val) {
            this.view.setUint16(26, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageDosHeader.prototype, "oemId", {
        // WORD e_res[4] (28,30,32,34)
        get: function () {
            return this.view.getUint16(36, true);
        },
        set: function (val) {
            this.view.setUint16(36, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageDosHeader.prototype, "oemInfo", {
        get: function () {
            return this.view.getUint16(38, true);
        },
        set: function (val) {
            this.view.setUint16(38, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageDosHeader.prototype, "newHeaderAddress", {
        // WORD e_res2[10] (40,42,44,46,48,50,52,54,56,58)
        get: function () {
            return this.view.getUint32(60, true);
        },
        set: function (val) {
            this.view.setUint32(60, val, true);
        },
        enumerable: false,
        configurable: true
    });
    ImageDosHeader.size = 64;
    ImageDosHeader.DEFAULT_MAGIC = 0x5a4d; // 'MZ'
    return ImageDosHeader;
}(FormatBase));

var __extends$8 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ImageFileHeader = /** @class */ (function (_super) {
    __extends$8(ImageFileHeader, _super);
    function ImageFileHeader(view) {
        return _super.call(this, view) || this;
    }
    ImageFileHeader.from = function (bin, offset) {
        if (offset === void 0) { offset = 0; }
        return new ImageFileHeader(new DataView(bin, offset, 20));
    };
    Object.defineProperty(ImageFileHeader.prototype, "machine", {
        get: function () {
            return this.view.getUint16(0, true);
        },
        set: function (val) {
            this.view.setUint16(0, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageFileHeader.prototype, "numberOfSections", {
        get: function () {
            return this.view.getUint16(2, true);
        },
        set: function (val) {
            this.view.setUint16(2, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageFileHeader.prototype, "timeDateStamp", {
        get: function () {
            return this.view.getUint32(4, true);
        },
        set: function (val) {
            this.view.setUint32(4, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageFileHeader.prototype, "pointerToSymbolTable", {
        get: function () {
            return this.view.getUint32(8, true);
        },
        set: function (val) {
            this.view.setUint32(8, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageFileHeader.prototype, "numberOfSymbols", {
        get: function () {
            return this.view.getUint32(12, true);
        },
        set: function (val) {
            this.view.setUint32(12, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageFileHeader.prototype, "sizeOfOptionalHeader", {
        get: function () {
            return this.view.getUint16(16, true);
        },
        set: function (val) {
            this.view.setUint16(16, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageFileHeader.prototype, "characteristics", {
        get: function () {
            return this.view.getUint16(18, true);
        },
        set: function (val) {
            this.view.setUint16(18, val, true);
        },
        enumerable: false,
        configurable: true
    });
    ImageFileHeader.size = 20;
    return ImageFileHeader;
}(FormatBase));

var __extends$7 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ImageOptionalHeader = /** @class */ (function (_super) {
    __extends$7(ImageOptionalHeader, _super);
    function ImageOptionalHeader(view) {
        return _super.call(this, view) || this;
    }
    ImageOptionalHeader.from = function (bin, offset) {
        if (offset === void 0) { offset = 0; }
        return new ImageOptionalHeader(new DataView(bin, offset, 96));
    };
    Object.defineProperty(ImageOptionalHeader.prototype, "magic", {
        get: function () {
            return this.view.getUint16(0, true);
        },
        set: function (val) {
            this.view.setUint16(0, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "majorLinkerVersion", {
        get: function () {
            return this.view.getUint8(2);
        },
        set: function (val) {
            this.view.setUint8(2, val);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "minorLinkerVersion", {
        get: function () {
            return this.view.getUint8(3);
        },
        set: function (val) {
            this.view.setUint8(3, val);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "sizeOfCode", {
        get: function () {
            return this.view.getUint32(4, true);
        },
        set: function (val) {
            this.view.setUint32(4, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "sizeOfInitializedData", {
        get: function () {
            return this.view.getUint32(8, true);
        },
        set: function (val) {
            this.view.setUint32(8, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "sizeOfUninitializedData", {
        get: function () {
            return this.view.getUint32(12, true);
        },
        set: function (val) {
            this.view.setUint32(12, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "addressOfEntryPoint", {
        get: function () {
            return this.view.getUint32(16, true);
        },
        set: function (val) {
            this.view.setUint32(16, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "baseOfCode", {
        get: function () {
            return this.view.getUint32(20, true);
        },
        set: function (val) {
            this.view.setUint32(20, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "baseOfData", {
        get: function () {
            return this.view.getUint32(24, true);
        },
        set: function (val) {
            this.view.setUint32(24, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "imageBase", {
        get: function () {
            return this.view.getUint32(28, true);
        },
        set: function (val) {
            this.view.setUint32(28, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "sectionAlignment", {
        get: function () {
            return this.view.getUint32(32, true);
        },
        set: function (val) {
            this.view.setUint32(32, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "fileAlignment", {
        get: function () {
            return this.view.getUint32(36, true);
        },
        set: function (val) {
            this.view.setUint32(36, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "majorOperatingSystemVersion", {
        get: function () {
            return this.view.getUint16(40, true);
        },
        set: function (val) {
            this.view.setUint16(40, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "minorOperatingSystemVersion", {
        get: function () {
            return this.view.getUint16(42, true);
        },
        set: function (val) {
            this.view.setUint16(42, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "majorImageVersion", {
        get: function () {
            return this.view.getUint16(44, true);
        },
        set: function (val) {
            this.view.setUint16(44, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "minorImageVersion", {
        get: function () {
            return this.view.getUint16(46, true);
        },
        set: function (val) {
            this.view.setUint16(46, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "majorSubsystemVersion", {
        get: function () {
            return this.view.getUint16(48, true);
        },
        set: function (val) {
            this.view.setUint16(48, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "minorSubsystemVersion", {
        get: function () {
            return this.view.getUint16(50, true);
        },
        set: function (val) {
            this.view.setUint16(50, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "win32VersionValue", {
        get: function () {
            return this.view.getUint32(52, true);
        },
        set: function (val) {
            this.view.setUint32(52, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "sizeOfImage", {
        get: function () {
            return this.view.getUint32(56, true);
        },
        set: function (val) {
            this.view.setUint32(56, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "sizeOfHeaders", {
        get: function () {
            return this.view.getUint32(60, true);
        },
        set: function (val) {
            this.view.setUint32(60, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "checkSum", {
        get: function () {
            return this.view.getUint32(64, true);
        },
        set: function (val) {
            this.view.setUint32(64, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "subsystem", {
        get: function () {
            return this.view.getUint16(68, true);
        },
        set: function (val) {
            this.view.setUint16(68, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "dllCharacteristics", {
        get: function () {
            return this.view.getUint16(70, true);
        },
        set: function (val) {
            this.view.setUint16(70, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "sizeOfStackReserve", {
        get: function () {
            return this.view.getUint32(72, true);
        },
        set: function (val) {
            this.view.setUint32(72, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "sizeOfStackCommit", {
        get: function () {
            return this.view.getUint32(76, true);
        },
        set: function (val) {
            this.view.setUint32(76, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "sizeOfHeapReserve", {
        get: function () {
            return this.view.getUint32(80, true);
        },
        set: function (val) {
            this.view.setUint32(80, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "sizeOfHeapCommit", {
        get: function () {
            return this.view.getUint32(84, true);
        },
        set: function (val) {
            this.view.setUint32(84, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "loaderFlags", {
        get: function () {
            return this.view.getUint32(88, true);
        },
        set: function (val) {
            this.view.setUint32(88, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader.prototype, "numberOfRvaAndSizes", {
        get: function () {
            return this.view.getUint32(92, true);
        },
        set: function (val) {
            this.view.setUint32(92, val, true);
        },
        enumerable: false,
        configurable: true
    });
    ImageOptionalHeader.size = 96;
    ImageOptionalHeader.DEFAULT_MAGIC = 0x10b;
    return ImageOptionalHeader;
}(FormatBase));

var __extends$6 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function getUint64LE(view, offset) {
    return (view.getUint32(offset + 4, true) * 0x100000000 +
        view.getUint32(offset, true));
}
function setUint64LE(view, offset, val) {
    view.setUint32(offset, val & 0xffffffff, true);
    view.setUint32(offset + 4, Math.floor(val / 0x100000000), true);
}
function getUint64LEBigInt(view, offset) {
    /* istanbul ignore if */
    if (typeof BigInt === 'undefined') {
        throw new Error('BigInt not supported');
    }
    return (BigInt(0x100000000) * BigInt(view.getUint32(offset + 4, true)) +
        BigInt(view.getUint32(offset, true)));
}
function setUint64LEBigInt(view, offset, val) {
    /* istanbul ignore if */
    if (typeof BigInt === 'undefined') {
        throw new Error('BigInt not supported');
    }
    view.setUint32(offset, Number(val & BigInt(0xffffffff)), true);
    view.setUint32(offset + 4, Math.floor(Number((val / BigInt(0x100000000)) & BigInt(0xffffffff))), true);
}
var ImageOptionalHeader64 = /** @class */ (function (_super) {
    __extends$6(ImageOptionalHeader64, _super);
    function ImageOptionalHeader64(view) {
        return _super.call(this, view) || this;
    }
    ImageOptionalHeader64.from = function (bin, offset) {
        if (offset === void 0) { offset = 0; }
        return new ImageOptionalHeader64(new DataView(bin, offset, 112));
    };
    Object.defineProperty(ImageOptionalHeader64.prototype, "magic", {
        get: function () {
            return this.view.getUint16(0, true);
        },
        set: function (val) {
            this.view.setUint16(0, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "majorLinkerVersion", {
        get: function () {
            return this.view.getUint8(2);
        },
        set: function (val) {
            this.view.setUint8(2, val);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "minorLinkerVersion", {
        get: function () {
            return this.view.getUint8(3);
        },
        set: function (val) {
            this.view.setUint8(3, val);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "sizeOfCode", {
        get: function () {
            return this.view.getUint32(4, true);
        },
        set: function (val) {
            this.view.setUint32(4, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "sizeOfInitializedData", {
        get: function () {
            return this.view.getUint32(8, true);
        },
        set: function (val) {
            this.view.setUint32(8, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "sizeOfUninitializedData", {
        get: function () {
            return this.view.getUint32(12, true);
        },
        set: function (val) {
            this.view.setUint32(12, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "addressOfEntryPoint", {
        get: function () {
            return this.view.getUint32(16, true);
        },
        set: function (val) {
            this.view.setUint32(16, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "baseOfCode", {
        get: function () {
            return this.view.getUint32(20, true);
        },
        set: function (val) {
            this.view.setUint32(20, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "imageBase", {
        get: function () {
            return getUint64LE(this.view, 24);
        },
        set: function (val) {
            setUint64LE(this.view, 24, val);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "imageBaseBigInt", {
        get: function () {
            return getUint64LEBigInt(this.view, 24);
        },
        set: function (val) {
            setUint64LEBigInt(this.view, 24, val);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "sectionAlignment", {
        get: function () {
            return this.view.getUint32(32, true);
        },
        set: function (val) {
            this.view.setUint32(32, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "fileAlignment", {
        get: function () {
            return this.view.getUint32(36, true);
        },
        set: function (val) {
            this.view.setUint32(36, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "majorOperatingSystemVersion", {
        get: function () {
            return this.view.getUint16(40, true);
        },
        set: function (val) {
            this.view.setUint16(40, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "minorOperatingSystemVersion", {
        get: function () {
            return this.view.getUint16(42, true);
        },
        set: function (val) {
            this.view.setUint16(42, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "majorImageVersion", {
        get: function () {
            return this.view.getUint16(44, true);
        },
        set: function (val) {
            this.view.setUint16(44, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "minorImageVersion", {
        get: function () {
            return this.view.getUint16(46, true);
        },
        set: function (val) {
            this.view.setUint16(46, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "majorSubsystemVersion", {
        get: function () {
            return this.view.getUint16(48, true);
        },
        set: function (val) {
            this.view.setUint16(48, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "minorSubsystemVersion", {
        get: function () {
            return this.view.getUint16(50, true);
        },
        set: function (val) {
            this.view.setUint16(50, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "win32VersionValue", {
        get: function () {
            return this.view.getUint32(52, true);
        },
        set: function (val) {
            this.view.setUint32(52, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "sizeOfImage", {
        get: function () {
            return this.view.getUint32(56, true);
        },
        set: function (val) {
            this.view.setUint32(56, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "sizeOfHeaders", {
        get: function () {
            return this.view.getUint32(60, true);
        },
        set: function (val) {
            this.view.setUint32(60, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "checkSum", {
        get: function () {
            return this.view.getUint32(64, true);
        },
        set: function (val) {
            this.view.setUint32(64, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "subsystem", {
        get: function () {
            return this.view.getUint16(68, true);
        },
        set: function (val) {
            this.view.setUint16(68, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "dllCharacteristics", {
        get: function () {
            return this.view.getUint16(70, true);
        },
        set: function (val) {
            this.view.setUint16(70, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "sizeOfStackReserve", {
        get: function () {
            return getUint64LE(this.view, 72);
        },
        set: function (val) {
            setUint64LE(this.view, 72, val);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "sizeOfStackReserveBigInt", {
        get: function () {
            return getUint64LEBigInt(this.view, 72);
        },
        set: function (val) {
            setUint64LEBigInt(this.view, 72, val);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "sizeOfStackCommit", {
        get: function () {
            return getUint64LE(this.view, 80);
        },
        set: function (val) {
            setUint64LE(this.view, 80, val);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "sizeOfStackCommitBigInt", {
        get: function () {
            return getUint64LEBigInt(this.view, 80);
        },
        set: function (val) {
            setUint64LEBigInt(this.view, 80, val);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "sizeOfHeapReserve", {
        get: function () {
            return getUint64LE(this.view, 88);
        },
        set: function (val) {
            setUint64LE(this.view, 88, val);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "sizeOfHeapReserveBigInt", {
        get: function () {
            return getUint64LEBigInt(this.view, 88);
        },
        set: function (val) {
            setUint64LEBigInt(this.view, 88, val);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "sizeOfHeapCommit", {
        get: function () {
            return getUint64LE(this.view, 96);
        },
        set: function (val) {
            setUint64LE(this.view, 96, val);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "sizeOfHeapCommitBigInt", {
        get: function () {
            return getUint64LEBigInt(this.view, 96);
        },
        set: function (val) {
            setUint64LEBigInt(this.view, 96, val);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "loaderFlags", {
        get: function () {
            return this.view.getUint32(104, true);
        },
        set: function (val) {
            this.view.setUint32(104, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageOptionalHeader64.prototype, "numberOfRvaAndSizes", {
        get: function () {
            return this.view.getUint32(108, true);
        },
        set: function (val) {
            this.view.setUint32(108, val, true);
        },
        enumerable: false,
        configurable: true
    });
    ImageOptionalHeader64.size = 112;
    ImageOptionalHeader64.DEFAULT_MAGIC = 0x20b;
    return ImageOptionalHeader64;
}(FormatBase));

var __extends$5 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ImageNtHeaders = /** @class */ (function (_super) {
    __extends$5(ImageNtHeaders, _super);
    function ImageNtHeaders(view) {
        return _super.call(this, view) || this;
    }
    ImageNtHeaders.from = function (bin, offset) {
        if (offset === void 0) { offset = 0; }
        var magic = createDataView$1(bin, offset + ImageFileHeader.size, 6).getUint16(4, true);
        var len = 4 + ImageFileHeader.size + ImageDataDirectoryArray.size;
        if (magic === ImageOptionalHeader64.DEFAULT_MAGIC) {
            len += ImageOptionalHeader64.size;
        }
        else {
            len += ImageOptionalHeader.size;
        }
        return new ImageNtHeaders(createDataView$1(bin, offset, len));
    };
    ImageNtHeaders.prototype.isValid = function () {
        return this.signature === ImageNtHeaders.DEFAULT_SIGNATURE;
    };
    ImageNtHeaders.prototype.is32bit = function () {
        return (this.view.getUint16(ImageFileHeader.size + 4, true) ===
            ImageOptionalHeader.DEFAULT_MAGIC);
    };
    Object.defineProperty(ImageNtHeaders.prototype, "signature", {
        get: function () {
            return this.view.getUint32(0, true);
        },
        set: function (val) {
            this.view.setUint32(0, val, true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageNtHeaders.prototype, "fileHeader", {
        get: function () {
            return ImageFileHeader.from(this.view.buffer, this.view.byteOffset + 4);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageNtHeaders.prototype, "optionalHeader", {
        get: function () {
            var off = ImageFileHeader.size + 4;
            var magic = this.view.getUint16(off, true);
            if (magic === ImageOptionalHeader64.DEFAULT_MAGIC) {
                return ImageOptionalHeader64.from(this.view.buffer, this.view.byteOffset + off);
            }
            else {
                return ImageOptionalHeader.from(this.view.buffer, this.view.byteOffset + off);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageNtHeaders.prototype, "optionalHeaderDataDirectory", {
        get: function () {
            return ImageDataDirectoryArray.from(this.view.buffer, this.view.byteOffset + this.getDataDirectoryOffset());
        },
        enumerable: false,
        configurable: true
    });
    ImageNtHeaders.prototype.getDataDirectoryOffset = function () {
        var off = ImageFileHeader.size + 4;
        var magic = this.view.getUint16(off, true);
        if (magic === ImageOptionalHeader64.DEFAULT_MAGIC) {
            off += ImageOptionalHeader64.size;
        }
        else {
            off += ImageOptionalHeader.size;
        }
        return off;
    };
    ImageNtHeaders.prototype.getSectionHeaderOffset = function () {
        return this.getDataDirectoryOffset() + ImageDataDirectoryArray.size;
    };
    ImageNtHeaders.DEFAULT_SIGNATURE = 0x4550; // 'PE\x00\x00'
    return ImageNtHeaders;
}(FormatBase));

var __extends$4 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ImageSectionHeaderArray = /** @class */ (function (_super) {
    __extends$4(ImageSectionHeaderArray, _super);
    function ImageSectionHeaderArray(view, length) {
        var _this = _super.call(this, view) || this;
        _this.length = length;
        return _this;
    }
    ImageSectionHeaderArray.from = function (bin, length, offset) {
        if (offset === void 0) { offset = 0; }
        var size = length * 40;
        return new ImageSectionHeaderArray(new DataView(bin, offset, size), length);
    };
    ImageSectionHeaderArray.prototype.get = function (index) {
        return {
            name: getFixedString(this.view, index * 40, 8),
            virtualSize: this.view.getUint32(8 + index * 40, true),
            virtualAddress: this.view.getUint32(12 + index * 40, true),
            sizeOfRawData: this.view.getUint32(16 + index * 40, true),
            pointerToRawData: this.view.getUint32(20 + index * 40, true),
            pointerToRelocations: this.view.getUint32(24 + index * 40, true),
            pointerToLineNumbers: this.view.getUint32(28 + index * 40, true),
            numberOfRelocations: this.view.getUint16(32 + index * 40, true),
            numberOfLineNumbers: this.view.getUint16(34 + index * 40, true),
            characteristics: this.view.getUint32(36 + index * 40, true),
        };
    };
    ImageSectionHeaderArray.prototype.set = function (index, data) {
        setFixedString(this.view, index * 40, 8, data.name);
        this.view.setUint32(8 + index * 40, data.virtualSize, true);
        this.view.setUint32(12 + index * 40, data.virtualAddress, true);
        this.view.setUint32(16 + index * 40, data.sizeOfRawData, true);
        this.view.setUint32(20 + index * 40, data.pointerToRawData, true);
        this.view.setUint32(24 + index * 40, data.pointerToRelocations, true);
        this.view.setUint32(28 + index * 40, data.pointerToLineNumbers, true);
        this.view.setUint16(32 + index * 40, data.numberOfRelocations, true);
        this.view.setUint16(34 + index * 40, data.numberOfLineNumbers, true);
        this.view.setUint32(36 + index * 40, data.characteristics, true);
    };
    ImageSectionHeaderArray.itemSize = 40;
    return ImageSectionHeaderArray;
}(ArrayFormatBase));

// To make the binary (DOS_STUB_PROGRAM):
// $ cd tools/dos-stub
// $ nasm -f bin -o dos-stub.bin dos-stub.asm
// $ node -e "console.log([].map.call(fs.readFileSync('tools/dos-stub/dos-stub.bin'), (v)=>`0x${Buffer.from([v]).toString('hex')}`).join(','))"
//
// NOTE: the original dos-stub.asm program and the bit code in DOS_STUB_PROGRAM are under the 0-BSD license.
// fill with '0x00' to make 8-bytes alignment
// prettier-ignore
var DOS_STUB_PROGRAM = new Uint8Array([
    0x0e, 0x1f, 0xba, 0x0e, 0x00, 0xb4, 0x09, 0xcd, 0x21, 0xb8, 0x01, 0x4c, 0xcd, 0x21, 0x44, 0x4f,
    0x53, 0x20, 0x6d, 0x6f, 0x64, 0x65, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x73, 0x75, 0x70, 0x70, 0x6f,
    0x72, 0x74, 0x65, 0x64, 0x2e, 0x0d, 0x0d, 0x0a, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
]);
var DOS_STUB_SIZE = roundUp$1(ImageDosHeader.size + DOS_STUB_PROGRAM.length, 0x80);
var DEFAULT_FILE_ALIGNMENT = 512;
function fillDosStubData(bin) {
    var dos = ImageDosHeader.from(bin);
    dos.magic = ImageDosHeader.DEFAULT_MAGIC;
    // last page size
    dos.lastPageSize = DOS_STUB_SIZE % 512;
    // total page count
    dos.pages = Math.ceil(DOS_STUB_SIZE / 512);
    // no relocations
    dos.relocations = 0;
    // header size as paragraph count (1 paragraph = 16 bytes)
    dos.headerSizeInParagraph = Math.ceil(ImageDosHeader.size / 16);
    dos.minAllocParagraphs = 0;
    dos.maxAllocParagraphs = 0xffff;
    dos.initialSS = 0;
    dos.initialSP = 0x80;
    // (no relocations, but set offset after the header)
    dos.relocationTableAddress = ImageDosHeader.size;
    dos.newHeaderAddress = DOS_STUB_SIZE;
    copyBuffer$1(bin, ImageDosHeader.size, DOS_STUB_PROGRAM, 0, DOS_STUB_PROGRAM.length);
}
function estimateNewHeaderSize(is32Bit) {
    return (
    // magic
    4 +
        ImageFileHeader.size +
        (is32Bit ? ImageOptionalHeader.size : ImageOptionalHeader64.size) +
        ImageDataDirectoryArray.size);
}
function fillPeHeaderEmptyData(bin, offset, totalBinSize, is32Bit, isDLL) {
    var _bin;
    var _offset;
    if ('buffer' in bin) {
        _bin = bin.buffer;
        _offset = bin.byteOffset + offset;
    }
    else {
        _bin = bin;
        _offset = offset;
    }
    new DataView(_bin, _offset).setUint32(0, ImageNtHeaders.DEFAULT_SIGNATURE, true);
    var fh = ImageFileHeader.from(_bin, _offset + 4);
    fh.machine = is32Bit ? 0x14c : 0x8664;
    fh.numberOfSections = 0; // no sections
    fh.timeDateStamp = 0;
    fh.pointerToSymbolTable = 0;
    fh.numberOfSymbols = 0;
    fh.sizeOfOptionalHeader =
        (is32Bit ? ImageOptionalHeader.size : ImageOptionalHeader64.size) +
            ImageDataDirectoryArray.size;
    fh.characteristics = isDLL ? 0x2102 : 0x102;
    var oh = (is32Bit ? ImageOptionalHeader : ImageOptionalHeader64).from(_bin, _offset + 4 + ImageFileHeader.size);
    oh.magic = is32Bit
        ? ImageOptionalHeader.DEFAULT_MAGIC
        : ImageOptionalHeader64.DEFAULT_MAGIC;
    // oh.majorLinkerVersion = 0;
    // oh.minorLinkerVersion = 0;
    oh.sizeOfCode = 0;
    oh.sizeOfInitializedData = 0;
    oh.sizeOfUninitializedData = 0;
    oh.addressOfEntryPoint = 0;
    oh.baseOfCode = 0x1000;
    // oh.baseOfData = 0; // for 32bit only
    oh.imageBase = is32Bit ? 0x1000000 : 0x180000000;
    oh.sectionAlignment = 4096;
    oh.fileAlignment = DEFAULT_FILE_ALIGNMENT;
    oh.majorOperatingSystemVersion = 6;
    oh.minorOperatingSystemVersion = 0;
    // oh.majorImageVersion = 0;
    // oh.minorImageVersion = 0;
    oh.majorSubsystemVersion = 6;
    oh.minorSubsystemVersion = 0;
    // oh.win32VersionValue = 0;
    oh.sizeOfHeaders = roundUp$1(totalBinSize, oh.fileAlignment);
    // oh.checkSum = 0;
    oh.subsystem = 2; // IMAGE_SUBSYSTEM_WINDOWS_GUI
    oh.dllCharacteristics =
        (is32Bit ? 0 : 0x20) + // IMAGE_DLL_CHARACTERISTICS_HIGH_ENTROPY_VA
            0x40 + // IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE
            0x100; // IMAGE_DLLCHARACTERISTICS_NX_COMPAT
    oh.sizeOfStackReserve = 0x100000;
    oh.sizeOfStackCommit = 0x1000;
    oh.sizeOfHeapReserve = 0x100000;
    oh.sizeOfHeapCommit = 0x1000;
    // oh.loaderFlags = 0;
    oh.numberOfRvaAndSizes =
        ImageDataDirectoryArray.size / ImageDataDirectoryArray.itemSize;
}
function makeEmptyNtExecutableBinary(is32Bit, isDLL) {
    var bufferSize = roundUp$1(DOS_STUB_SIZE + estimateNewHeaderSize(is32Bit), DEFAULT_FILE_ALIGNMENT);
    var bin = new ArrayBuffer(bufferSize);
    fillDosStubData(bin);
    fillPeHeaderEmptyData(bin, DOS_STUB_SIZE, bufferSize, is32Bit, isDLL);
    return bin;
}

var NtExecutable = /** @class */ (function () {
    function NtExecutable(_headers, _sections, _ex) {
        this._headers = _headers;
        this._sections = _sections;
        this._ex = _ex;
        var dh = ImageDosHeader.from(_headers);
        var nh = ImageNtHeaders.from(_headers, dh.newHeaderAddress);
        this._dh = dh;
        this._nh = nh;
        this._dda = nh.optionalHeaderDataDirectory;
        _sections.sort(function (a, b) {
            var ra = a.info.pointerToRawData;
            var rb = a.info.pointerToRawData;
            if (ra !== rb) {
                return ra - rb;
            }
            var va = a.info.virtualAddress;
            var vb = b.info.virtualAddress;
            if (va === vb) {
                return a.info.virtualSize - b.info.virtualSize;
            }
            return va - vb;
        });
    }
    /**
     * Creates an NtExecutable instance with an 'empty' executable binary.
     * @param is32Bit set true if the binary is for 32-bit (default: false)
     * @param isDLL set true if the binary is DLL (default: true)
     * @return NtExecutable instance
     */
    NtExecutable.createEmpty = function (is32Bit, isDLL) {
        if (is32Bit === void 0) { is32Bit = false; }
        if (isDLL === void 0) { isDLL = true; }
        return this.from(makeEmptyNtExecutableBinary(is32Bit, isDLL));
    };
    /**
     * Parse the binary and create NtExecutable instance.
     * An error will be thrown if the binary data is invalid
     * @param bin binary data
     * @param options additional option for parsing
     * @return NtExecutable instance
     */
    NtExecutable.from = function (bin, options) {
        var dh = ImageDosHeader.from(bin);
        var nh = ImageNtHeaders.from(bin, dh.newHeaderAddress);
        if (!dh.isValid() || !nh.isValid()) {
            throw new TypeError('Invalid binary format');
        }
        if (nh.fileHeader.numberOfSymbols > 0) {
            throw new Error('Binary with symbols is not supported now');
        }
        var fileAlignment = nh.optionalHeader.fileAlignment;
        var securityEntry = nh.optionalHeaderDataDirectory.get(ImageDirectoryEntry$1.Certificate);
        if (securityEntry.size > 0) {
            // Signed executables should be parsed only when `ignoreCert` is true
            if (!(options === null || options === void 0 ? void 0 : options.ignoreCert)) {
                throw new Error('Parsing signed executable binary is not allowed by default.');
            }
        }
        var secOff = dh.newHeaderAddress + nh.getSectionHeaderOffset();
        var secCount = nh.fileHeader.numberOfSections;
        var sections = [];
        var tempSectionHeaderBinary = allocatePartialBinary$1(bin, secOff, secCount * ImageSectionHeaderArray.itemSize);
        var secArray = ImageSectionHeaderArray.from(tempSectionHeaderBinary, secCount, 0);
        var lastOffset = roundUp$1(secOff + secCount * ImageSectionHeaderArray.itemSize, fileAlignment);
        // console.log(`from data size 0x${bin.byteLength.toString(16)}:`);
        secArray.forEach(function (info) {
            if (!info.pointerToRawData || !info.sizeOfRawData) {
                info.pointerToRawData = 0;
                info.sizeOfRawData = 0;
                sections.push({
                    info: info,
                    data: null,
                });
            }
            else {
                // console.log(`  section ${info.name}: 0x${info.pointerToRawData.toString(16)}, size = 0x${info.sizeOfRawData.toString(16)}`);
                var secBin = allocatePartialBinary$1(bin, info.pointerToRawData, info.sizeOfRawData);
                sections.push({
                    info: info,
                    data: secBin,
                });
                var secEndOffset = roundUp$1(info.pointerToRawData + info.sizeOfRawData, fileAlignment);
                if (secEndOffset > lastOffset) {
                    lastOffset = secEndOffset;
                }
            }
        });
        // the size of DOS and NT headers is equal to section offset
        var headers = allocatePartialBinary$1(bin, 0, secOff);
        // extra data
        var exData = null;
        var lastExDataOffset = bin.byteLength;
        // It may contain that both extra data and certificate data are available.
        // In this case the extra data is followed by the certificate data.
        if (securityEntry.size > 0) {
            lastExDataOffset = securityEntry.virtualAddress;
        }
        if (lastOffset < lastExDataOffset) {
            exData = allocatePartialBinary$1(bin, lastOffset, lastExDataOffset - lastOffset);
        }
        return new NtExecutable(headers, sections, exData);
    };
    /**
     * Returns whether the executable is for 32-bit architecture
     */
    NtExecutable.prototype.is32bit = function () {
        return this._nh.is32bit();
    };
    NtExecutable.prototype.getTotalHeaderSize = function () {
        return this._headers.byteLength;
    };
    Object.defineProperty(NtExecutable.prototype, "dosHeader", {
        get: function () {
            return this._dh;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NtExecutable.prototype, "newHeader", {
        get: function () {
            return this._nh;
        },
        enumerable: false,
        configurable: true
    });
    NtExecutable.prototype.getRawHeader = function () {
        return this._headers;
    };
    NtExecutable.prototype.getImageBase = function () {
        return this._nh.optionalHeader.imageBase;
    };
    NtExecutable.prototype.getFileAlignment = function () {
        return this._nh.optionalHeader.fileAlignment;
    };
    NtExecutable.prototype.getSectionAlignment = function () {
        return this._nh.optionalHeader.sectionAlignment;
    };
    /**
     * Return all sections. The returned array is sorted by raw address.
     */
    NtExecutable.prototype.getAllSections = function () {
        return this._sections;
    };
    /**
     * Return the section data from ImageDirectoryEntry enum value.
     */
    NtExecutable.prototype.getSectionByEntry = function (entry) {
        var dd = this._dda.get(entry);
        var r = this._sections
            .filter(function (sec) {
            var vaEnd = sec.info.virtualAddress + sec.info.virtualSize;
            return (dd.virtualAddress >= sec.info.virtualAddress &&
                dd.virtualAddress < vaEnd);
        })
            .shift();
        return r !== undefined ? r : null;
    };
    /**
     * Set the section data from ImageDirectoryEntry enum value.
     * If entry is found, then replaces the secion data. If not found, then adds the section data.
     *
     * NOTE: 'virtualAddress' and 'pointerToRawData' of section object is ignored
     * and calculated automatically. 'virtualSize' and 'sizeOfRawData' are used, but
     * if the 'section.data.byteLength' is larger than 'sizeOfRawData', then
     * these members are replaced.
     *
     * @param entry ImageDirectoryEntry enum value for the section
     * @param section the section data, or null to remove the section
     */
    NtExecutable.prototype.setSectionByEntry = function (entry, section) {
        var sec = section
            ? { data: section.data, info: section.info }
            : null;
        var dd = this._dda.get(entry);
        var hasEntry = dd.size > 0;
        if (!sec) {
            if (!hasEntry) ;
            else {
                // clear entry
                this._dda.set(entry, { size: 0, virtualAddress: 0 });
                var len = this._sections.length;
                for (var i = 0; i < len; ++i) {
                    var sec_1 = this._sections[i];
                    var vaStart = sec_1.info.virtualAddress;
                    var vaLast = vaStart + sec_1.info.virtualSize;
                    if (dd.virtualAddress >= vaStart &&
                        dd.virtualAddress < vaLast) {
                        this._sections.splice(i, 1);
                        // section count changed
                        this._nh.fileHeader.numberOfSections =
                            this._sections.length;
                        break;
                    }
                }
            }
        }
        else {
            var rawSize = !sec.data ? 0 : sec.data.byteLength;
            var fileAlign = this._nh.optionalHeader.fileAlignment;
            var secAlign = this._nh.optionalHeader.sectionAlignment;
            var alignedFileSize = !sec.data ? 0 : roundUp$1(rawSize, fileAlign);
            var alignedSecSize = !sec.data
                ? 0
                : roundUp$1(sec.info.virtualSize, secAlign);
            if (sec.info.sizeOfRawData < alignedFileSize) {
                sec.info.sizeOfRawData = alignedFileSize;
            }
            else {
                alignedFileSize = sec.info.sizeOfRawData;
            }
            if (!hasEntry) {
                var virtAddr_1 = 0;
                var rawAddr_1 = roundUp$1(this._headers.byteLength, fileAlign);
                // get largest addresses
                this._sections.forEach(function (secExist) {
                    if (secExist.info.pointerToRawData) {
                        if (rawAddr_1 <= secExist.info.pointerToRawData) {
                            rawAddr_1 =
                                secExist.info.pointerToRawData +
                                    secExist.info.sizeOfRawData;
                        }
                    }
                    if (virtAddr_1 <= secExist.info.virtualAddress) {
                        virtAddr_1 =
                            secExist.info.virtualAddress +
                                secExist.info.virtualSize;
                    }
                });
                if (!alignedFileSize) {
                    rawAddr_1 = 0;
                }
                if (!virtAddr_1) {
                    virtAddr_1 = this.newHeader.optionalHeader.baseOfCode;
                }
                virtAddr_1 = roundUp$1(virtAddr_1, secAlign);
                sec.info.pointerToRawData = rawAddr_1;
                sec.info.virtualAddress = virtAddr_1;
                // add entry
                this._dda.set(entry, {
                    size: rawSize,
                    virtualAddress: virtAddr_1,
                });
                this._sections.push(sec);
                // section count changed
                this._nh.fileHeader.numberOfSections = this._sections.length;
                // change image size
                this._nh.optionalHeader.sizeOfImage = roundUp$1(virtAddr_1 + alignedSecSize, this._nh.optionalHeader.sectionAlignment);
            }
            else {
                // replace entry
                this.replaceSectionImpl(dd.virtualAddress, sec.info, sec.data);
            }
        }
    };
    /**
     * Returns the extra data in the executable, or `null` if nothing.
     * You can rewrite the returned buffer without using `setExtraData` if
     * the size of the new data is equal to the old data.
     */
    NtExecutable.prototype.getExtraData = function () {
        return this._ex;
    };
    /**
     * Specifies the new extra data in the executable.
     * The specified buffer will be cloned and you can release it after calling this method.
     * @param bin buffer containing the new data
     * @note
     * The extra data will not be aligned by `NtExecutable`.
     */
    NtExecutable.prototype.setExtraData = function (bin) {
        if (bin === null) {
            this._ex = null;
        }
        else {
            this._ex = cloneToArrayBuffer$1(bin);
        }
    };
    /**
     * Generates the executable binary data.
     */
    NtExecutable.prototype.generate = function (paddingSize) {
        // calculate binary size
        var dh = this._dh;
        var nh = this._nh;
        var secOff = dh.newHeaderAddress + nh.getSectionHeaderOffset();
        var size = secOff;
        size += this._sections.length * ImageSectionHeaderArray.itemSize;
        var align = nh.optionalHeader.fileAlignment;
        size = roundUp$1(size, align);
        this._sections.forEach(function (sec) {
            if (!sec.info.pointerToRawData) {
                return;
            }
            var lastOff = sec.info.pointerToRawData + sec.info.sizeOfRawData;
            if (size < lastOff) {
                size = lastOff;
                size = roundUp$1(size, align);
            }
        });
        var lastPosition = size;
        if (this._ex !== null) {
            size += this._ex.byteLength;
        }
        if (typeof paddingSize === 'number') {
            size += paddingSize;
        }
        // make buffer
        var bin = new ArrayBuffer(size);
        var u8bin = new Uint8Array(bin);
        u8bin.set(new Uint8Array(this._headers, 0, secOff));
        // reset Security section offset (eliminate it)
        ImageDataDirectoryArray.from(bin, dh.newHeaderAddress + nh.getDataDirectoryOffset()).set(ImageDirectoryEntry$1.Certificate, {
            size: 0,
            virtualAddress: 0,
        });
        var secArray = ImageSectionHeaderArray.from(bin, this._sections.length, secOff);
        this._sections.forEach(function (sec, i) {
            if (!sec.data) {
                sec.info.pointerToRawData = 0;
                sec.info.sizeOfRawData = 0;
            }
            secArray.set(i, sec.info);
            if (!sec.data || !sec.info.pointerToRawData) {
                return;
            }
            u8bin.set(new Uint8Array(sec.data), sec.info.pointerToRawData);
        });
        if (this._ex !== null) {
            u8bin.set(new Uint8Array(this._ex), lastPosition);
        }
        // re-calc checksum
        if (nh.optionalHeader.checkSum !== 0) {
            calculateCheckSumForPE(bin, true);
        }
        return bin;
    };
    NtExecutable.prototype.rearrangeSections = function (rawAddressStart, rawDiff, virtualAddressStart, virtualDiff) {
        if (!rawDiff && !virtualDiff) {
            return;
        }
        var nh = this._nh;
        var secAlign = nh.optionalHeader.sectionAlignment;
        var dirs = this._dda;
        var len = this._sections.length;
        var lastVirtAddress = 0;
        for (var i = 0; i < len; ++i) {
            var sec = this._sections[i];
            var virtAddr = sec.info.virtualAddress;
            if (virtualDiff && virtAddr >= virtualAddressStart) {
                var iDir = dirs.findIndexByVirtualAddress(virtAddr);
                virtAddr += virtualDiff;
                if (iDir !== null) {
                    dirs.set(iDir, {
                        virtualAddress: virtAddr,
                        size: sec.info.virtualSize,
                    });
                }
                sec.info.virtualAddress = virtAddr;
            }
            var fileAddr = sec.info.pointerToRawData;
            if (rawDiff && fileAddr >= rawAddressStart) {
                sec.info.pointerToRawData = fileAddr + rawDiff;
            }
            lastVirtAddress = roundUp$1(sec.info.virtualAddress + sec.info.virtualSize, secAlign);
        }
        // fix image size from last virtual address
        nh.optionalHeader.sizeOfImage = lastVirtAddress;
    };
    // NOTE: info.virtualSize must be valid
    NtExecutable.prototype.replaceSectionImpl = function (virtualAddress, info, data) {
        var len = this._sections.length;
        for (var i = 0; i < len; ++i) {
            var s = this._sections[i];
            // console.log(`replaceSectionImpl: ${virtualAddress} <--> ${s.info.virtualAddress}`);
            if (s.info.virtualAddress === virtualAddress) {
                // console.log(`  found`);
                var secAlign = this._nh.optionalHeader.sectionAlignment;
                var fileAddr = s.info.pointerToRawData;
                var oldFileAddr = fileAddr + s.info.sizeOfRawData;
                var oldVirtAddr = virtualAddress + roundUp$1(s.info.virtualSize, secAlign);
                s.info = cloneObject$1(info);
                s.info.virtualAddress = virtualAddress;
                s.info.pointerToRawData = fileAddr;
                s.data = data;
                // shift addresses
                var newFileAddr = fileAddr + info.sizeOfRawData;
                var newVirtAddr = virtualAddress + roundUp$1(info.virtualSize, secAlign);
                this.rearrangeSections(oldFileAddr, newFileAddr - oldFileAddr, oldVirtAddr, newVirtAddr - oldVirtAddr);
                // BLOCK: rewrite DataDirectory entry for specified virtualAddress
                {
                    var dirs = this._dda;
                    var iDir = dirs.findIndexByVirtualAddress(virtualAddress);
                    if (iDir !== null) {
                        dirs.set(iDir, {
                            virtualAddress: virtualAddress,
                            size: info.virtualSize,
                        });
                    }
                }
                break;
            }
        }
    };
    return NtExecutable;
}());

function removeDuplicates(a) {
    return a.reduce(function (p, c) {
        return p.indexOf(c) >= 0 ? p : p.concat(c);
    }, []);
}
function readString(view, offset) {
    var length = view.getUint16(offset, true);
    var r = '';
    offset += 2;
    for (var i = 0; i < length; ++i) {
        r += String.fromCharCode(view.getUint16(offset, true));
        offset += 2;
    }
    return r;
}
function readLanguageTable(view, typeEntry, name, languageTable, cb) {
    var off = languageTable;
    var nameEntry = {
        name: name,
        languageTable: languageTable,
        characteristics: view.getUint32(off, true),
        dateTime: view.getUint32(off + 4, true),
        majorVersion: view.getUint16(off + 8, true),
        minorVersion: view.getUint16(off + 10, true),
    };
    var nameCount = view.getUint16(off + 12, true);
    var idCount = view.getUint16(off + 14, true);
    off += 16;
    for (var i = 0; i < nameCount; ++i) {
        var nameOffset = view.getUint32(off, true) & 0x7fffffff;
        var dataOffset = view.getUint32(off + 4, true);
        // ignore if the offset refers to the next table
        if ((dataOffset & 0x80000000) !== 0) {
            off += 8;
            continue;
        }
        var name_1 = readString(view, nameOffset);
        cb(typeEntry, nameEntry, { lang: name_1, dataOffset: dataOffset });
        off += 8;
    }
    for (var i = 0; i < idCount; ++i) {
        var id = view.getUint32(off, true) & 0x7fffffff;
        var dataOffset = view.getUint32(off + 4, true);
        // ignore if the offset refers to the next table
        if ((dataOffset & 0x80000000) !== 0) {
            off += 8;
            continue;
        }
        cb(typeEntry, nameEntry, { lang: id, dataOffset: dataOffset });
        off += 8;
    }
}
function readNameTable(view, type, nameTable, cb) {
    var off = nameTable;
    var typeEntry = {
        type: type,
        nameTable: nameTable,
        characteristics: view.getUint32(off, true),
        dateTime: view.getUint32(off + 4, true),
        majorVersion: view.getUint16(off + 8, true),
        minorVersion: view.getUint16(off + 10, true),
    };
    var nameCount = view.getUint16(off + 12, true);
    var idCount = view.getUint16(off + 14, true);
    off += 16;
    for (var i = 0; i < nameCount; ++i) {
        var nameOffset = view.getUint32(off, true) & 0x7fffffff;
        var nextTable = view.getUint32(off + 4, true);
        // ignore if no next table is available
        if (!(nextTable & 0x80000000)) {
            off += 8;
            continue;
        }
        nextTable &= 0x7fffffff;
        var name_2 = readString(view, nameOffset);
        readLanguageTable(view, typeEntry, name_2, nextTable, cb);
        off += 8;
    }
    for (var i = 0; i < idCount; ++i) {
        var id = view.getUint32(off, true) & 0x7fffffff;
        var nextTable = view.getUint32(off + 4, true);
        // ignore if no next table is available
        if (!(nextTable & 0x80000000)) {
            off += 8;
            continue;
        }
        nextTable &= 0x7fffffff;
        readLanguageTable(view, typeEntry, id, nextTable, cb);
        off += 8;
    }
}
function divideEntriesImplByID(r, names, entries) {
    var entriesByString = {};
    var entriesByNumber = {};
    entries.forEach(function (e) {
        if (typeof e.lang === 'string') {
            entriesByString[e.lang] = e;
            names.push(e.lang);
        }
        else {
            entriesByNumber[e.lang] = e;
        }
    });
    var strKeys = Object.keys(entriesByString);
    strKeys.sort().forEach(function (type) {
        r.s.push(entriesByString[type]);
    });
    var numKeys = Object.keys(entriesByNumber);
    numKeys
        .map(function (k) { return Number(k); })
        .sort(function (a, b) { return a - b; })
        .forEach(function (type) {
        r.n.push(entriesByNumber[type]);
    });
    return 16 + 8 * (strKeys.length + numKeys.length);
}
function divideEntriesImplByName(r, names, entries) {
    var entriesByString = {};
    var entriesByNumber = {};
    entries.forEach(function (e) {
        var _a, _b;
        if (typeof e.id === 'string') {
            var a = (_a = entriesByString[e.id]) !== null && _a !== void 0 ? _a : (entriesByString[e.id] = []);
            names.push(e.id);
            a.push(e);
        }
        else {
            var a = (_b = entriesByNumber[e.id]) !== null && _b !== void 0 ? _b : (entriesByNumber[e.id] = []);
            a.push(e);
        }
    });
    var sSum = Object.keys(entriesByString)
        .sort()
        .map(function (id) {
        var o = {
            id: id,
            s: [],
            n: [],
        };
        r.s.push(o);
        return divideEntriesImplByID(o, names, entriesByString[id]);
    })
        .reduce(function (p, c) { return p + 8 + c; }, 0);
    var nSum = Object.keys(entriesByNumber)
        .map(function (k) { return Number(k); })
        .sort(function (a, b) { return a - b; })
        .map(function (id) {
        var o = {
            id: id,
            s: [],
            n: [],
        };
        r.n.push(o);
        return divideEntriesImplByID(o, names, entriesByNumber[id]);
    })
        .reduce(function (p, c) { return p + 8 + c; }, 0);
    return 16 + sSum + nSum;
}
function divideEntriesImplByType(r, names, entries) {
    var entriesByString = {};
    var entriesByNumber = {};
    entries.forEach(function (e) {
        var _a, _b;
        if (typeof e.type === 'string') {
            var a = (_a = entriesByString[e.type]) !== null && _a !== void 0 ? _a : (entriesByString[e.type] = []);
            names.push(e.type);
            a.push(e);
        }
        else {
            var a = (_b = entriesByNumber[e.type]) !== null && _b !== void 0 ? _b : (entriesByNumber[e.type] = []);
            a.push(e);
        }
    });
    var sSum = Object.keys(entriesByString)
        .sort()
        .map(function (type) {
        var o = { type: type, s: [], n: [] };
        r.s.push(o);
        return divideEntriesImplByName(o, names, entriesByString[type]);
    })
        .reduce(function (p, c) { return p + 8 + c; }, 0);
    var nSum = Object.keys(entriesByNumber)
        .map(function (k) { return Number(k); })
        .sort(function (a, b) { return a - b; })
        .map(function (type) {
        var o = { type: type, s: [], n: [] };
        r.n.push(o);
        return divideEntriesImplByName(o, names, entriesByNumber[type]);
    })
        .reduce(function (p, c) { return p + 8 + c; }, 0);
    return 16 + sSum + nSum;
}
function calculateStringLengthForWrite(text) {
    var length = text.length;
    // limit to 65535 because the 'length' field is uint16
    return length > 65535 ? 65535 : length;
}
function getStringOffset(target, strings) {
    var l = strings.length;
    for (var i = 0; i < l; ++i) {
        var s = strings[i];
        if (s.text === target) {
            return s.offset;
        }
    }
    throw new Error('Unexpected');
}
/** (returns offset just after the written text) */
function writeString(view, offset, text) {
    var length = calculateStringLengthForWrite(text);
    view.setUint16(offset, length, true);
    offset += 2;
    for (var i = 0; i < length; ++i) {
        view.setUint16(offset, text.charCodeAt(i), true);
        offset += 2;
    }
    return offset;
}
function writeLanguageTable(view, offset, strings, data) {
    // characteristics
    view.setUint32(offset, 0, true);
    // timestamp
    view.setUint32(offset + 4, 0, true);
    // major version / minor version
    view.setUint32(offset + 8, 0, true);
    // name entries
    view.setUint16(offset + 12, data.s.length, true);
    // id entries
    view.setUint16(offset + 14, data.n.length, true);
    offset += 16;
    // name entries (not in specification)
    data.s.forEach(function (e) {
        var strOff = getStringOffset(e.lang, strings);
        view.setUint32(offset, strOff, true);
        view.setUint32(offset + 4, e.offset, true);
        offset += 8;
    });
    // id entries
    data.n.forEach(function (e) {
        view.setUint32(offset, e.lang, true);
        view.setUint32(offset + 4, e.offset, true);
        offset += 8;
    });
    return offset;
}
function writeNameTable(view, offset, leafOffset, strings, data) {
    // characteristics
    view.setUint32(offset, 0, true);
    // timestamp
    view.setUint32(offset + 4, 0, true);
    // major version / minor version
    view.setUint32(offset + 8, 0, true);
    // name entries
    view.setUint16(offset + 12, data.s.length, true);
    // id entries
    view.setUint16(offset + 14, data.n.length, true);
    offset += 16;
    data.s.forEach(function (e) {
        e.offset = leafOffset;
        leafOffset = writeLanguageTable(view, leafOffset, strings, e);
    });
    data.n.forEach(function (e) {
        e.offset = leafOffset;
        leafOffset = writeLanguageTable(view, leafOffset, strings, e);
    });
    data.s.forEach(function (e) {
        var strOff = getStringOffset(e.id, strings);
        view.setUint32(offset, strOff + 0x80000000, true);
        view.setUint32(offset + 4, e.offset + 0x80000000, true);
        offset += 8;
    });
    data.n.forEach(function (e) {
        view.setUint32(offset, e.id, true);
        view.setUint32(offset + 4, e.offset + 0x80000000, true);
        offset += 8;
    });
    return leafOffset;
}
function writeTypeTable(view, offset, strings, data) {
    // characteristics
    view.setUint32(offset, 0, true);
    // timestamp
    view.setUint32(offset + 4, 0, true);
    // major version / minor version
    view.setUint32(offset + 8, 0, true);
    // name entries
    view.setUint16(offset + 12, data.s.length, true);
    // id entries
    view.setUint16(offset + 14, data.n.length, true);
    offset += 16;
    var nextTableOffset = offset + 8 * (data.s.length + data.n.length);
    data.s.forEach(function (e) {
        e.offset = nextTableOffset;
        nextTableOffset += 16 + 8 * (e.s.length + e.n.length);
    });
    data.n.forEach(function (e) {
        e.offset = nextTableOffset;
        nextTableOffset += 16 + 8 * (e.s.length + e.n.length);
    });
    data.s.forEach(function (e) {
        var strOff = getStringOffset(e.type, strings);
        view.setUint32(offset, strOff + 0x80000000, true);
        view.setUint32(offset + 4, e.offset + 0x80000000, true);
        offset += 8;
        nextTableOffset = writeNameTable(view, e.offset, nextTableOffset, strings, e);
    });
    data.n.forEach(function (e) {
        view.setUint32(offset, e.type, true);
        view.setUint32(offset + 4, e.offset + 0x80000000, true);
        offset += 8;
        nextTableOffset = writeNameTable(view, e.offset, nextTableOffset, strings, e);
    });
    return nextTableOffset;
}
////////////////////////////////////////////////////////////////////////////////
/** Manages resource data for NtExecutable */
var NtExecutableResource = /** @class */ (function () {
    function NtExecutableResource() {
        /** The timestamp for resource */
        this.dateTime = 0;
        /** The major version data for resource */
        this.majorVersion = 0;
        /** The minor version data for resource */
        this.minorVersion = 0;
        /** Resource entries */
        this.entries = [];
        /**
         * The section data header of resource data (used by outputResource method).
         * This instance will be null if the base executable does not contain resource data.
         * You can override this field before calling outputResource method.
         * (Note that the addresses and sizes are ignored for output)
         */
        this.sectionDataHeader = null;
        this.originalSize = 0;
    }
    NtExecutableResource.prototype.parse = function (section, ignoreUnparsableData) {
        if (!section.data) {
            return;
        }
        var view = new DataView(section.data);
        // --- First: Resource Directory Table ---
        // (off: 0 -- Characteristics (uint32))
        this.dateTime = view.getUint32(4, true);
        this.majorVersion = view.getUint16(8, true);
        this.minorVersion = view.getUint16(10, true);
        var nameCount = view.getUint16(12, true);
        var idCount = view.getUint16(14, true);
        var off = 16;
        var res = [];
        var cb = function (t, n, l) {
            var off = view.getUint32(l.dataOffset, true) -
                section.info.virtualAddress;
            var size = view.getUint32(l.dataOffset + 4, true);
            var cp = view.getUint32(l.dataOffset + 8, true);
            if (off >= 0) {
                var bin = new Uint8Array(size);
                bin.set(new Uint8Array(section.data, off, size));
                res.push({
                    type: t.type,
                    id: n.name,
                    lang: l.lang,
                    codepage: cp,
                    bin: bin.buffer,
                });
            }
            else {
                if (!ignoreUnparsableData) {
                    throw new Error('Cannot parse resource directory entry; RVA seems to be invalid.');
                }
                res.push({
                    type: t.type,
                    id: n.name,
                    lang: l.lang,
                    codepage: cp,
                    bin: new ArrayBuffer(0),
                    rva: l.dataOffset,
                });
            }
        };
        for (var i = 0; i < nameCount; ++i) {
            var nameOffset = view.getUint32(off, true) & 0x7fffffff;
            var nextTable = view.getUint32(off + 4, true);
            // ignore if no next table is available
            if (!(nextTable & 0x80000000)) {
                off += 8;
                continue;
            }
            nextTable &= 0x7fffffff;
            var name_3 = readString(view, nameOffset);
            readNameTable(view, name_3, nextTable, cb);
            off += 8;
        }
        for (var i = 0; i < idCount; ++i) {
            var typeId = view.getUint32(off, true) & 0x7fffffff;
            var nextTable = view.getUint32(off + 4, true);
            // ignore if no next table is available
            if (!(nextTable & 0x80000000)) {
                off += 8;
                continue;
            }
            nextTable &= 0x7fffffff;
            readNameTable(view, typeId, nextTable, cb);
            off += 8;
        }
        this.entries = res;
        this.originalSize = section.data.byteLength;
    };
    /**
     * Parses resource data for `NtExecutable`.
     * This function returns valid instance even if
     * the executable does not have resource data.
     * @param exe `NtExecutable` instance
     * @param ignoreUnparsableData (default: false) specify true if skipping 'unparsable' (e.g. unusual format) data.
     *   When true, the resource data may break on write operation.
     */
    NtExecutableResource.from = function (exe, ignoreUnparsableData) {
        if (ignoreUnparsableData === void 0) { ignoreUnparsableData = false; }
        var secs = []
            .concat(exe.getAllSections())
            .sort(function (a, b) { return a.info.virtualAddress - b.info.virtualAddress; });
        var entry = exe.getSectionByEntry(ImageDirectoryEntry$1.Resource);
        // check if the section order is supported
        // (not supported if any other sections except 'relocation' is available,
        // because the recalculation of virtual address is not simple)
        if (entry) {
            var reloc = exe.getSectionByEntry(ImageDirectoryEntry$1.BaseRelocation);
            for (var i = 0; i < secs.length; ++i) {
                var s = secs[i];
                if (s.info.name === entry.info.name) {
                    for (var j = i + 1; j < secs.length; ++j) {
                        if (!reloc || secs[j].info.name !== reloc.info.name) {
                            throw new Error('After Resource section, sections except for relocation are not supported');
                        }
                    }
                    break;
                }
            }
        }
        var r = new NtExecutableResource();
        r.sectionDataHeader = entry ? cloneObject$1(entry.info) : null;
        if (entry) {
            r.parse(entry, ignoreUnparsableData);
        }
        return r;
    };
    /**
     * Add or replace the resource entry.
     * This method replaces the entry only if there is an entry with `type`, `id` and `lang` equal.
     */
    NtExecutableResource.prototype.replaceResourceEntry = function (entry) {
        for (var len = this.entries.length, i = 0; i < len; ++i) {
            var e = this.entries[i];
            if (e.type === entry.type &&
                e.id === entry.id &&
                e.lang === entry.lang) {
                this.entries[i] = entry;
                return;
            }
        }
        this.entries.push(entry);
    };
    /**
     * Returns all resource entries, which has specified type and id, as UTF-8 string data.
     * @param type Resource type
     * @param id Resource id
     * @returns an array of lang and value pair (tuple)
     */
    NtExecutableResource.prototype.getResourceEntriesAsString = function (type, id) {
        return this.entries
            .filter(function (entry) { return entry.type === type && entry.id === id; })
            .map(function (entry) { return [entry.lang, binaryToString(entry.bin)]; });
    };
    /**
     * Add or replace the resource entry with UTF-8 string data.
     * This method is a wrapper of {@link NtExecutableResource.replaceResourceEntry}.
     */
    NtExecutableResource.prototype.replaceResourceEntryFromString = function (type, id, lang, value) {
        var entry = {
            type: type,
            id: id,
            lang: lang,
            codepage: 1200,
            bin: stringToBinary(value),
        };
        this.replaceResourceEntry(entry);
    };
    /**
     * Removes resource entries which has specified type and id.
     */
    NtExecutableResource.prototype.removeResourceEntry = function (type, id, lang) {
        this.entries = this.entries.filter(function (entry) {
            return !(entry.type === type &&
                entry.id === id &&
                (typeof lang === 'undefined' || entry.lang === lang));
        });
    };
    /**
     * Generates resource data binary for NtExecutable (not for .res file)
     * @param virtualAddress The virtual address for the section
     * @param alignment File alignment value of executable
     * @param noGrow Set true to disallow growing resource section (throw errors if data exceeds)
     * @param allowShrink Set true to allow shrinking resource section (if the data size is less than original)
     */
    NtExecutableResource.prototype.generateResourceData = function (virtualAddress, alignment, noGrow, allowShrink) {
        if (noGrow === void 0) { noGrow = false; }
        if (allowShrink === void 0) { allowShrink = false; }
        // estimate data size and divide to output table
        var r = {
            s: [],
            n: [],
        };
        var strings = [];
        var size = divideEntriesImplByType(r, strings, this.entries);
        strings = removeDuplicates(strings);
        var stringsOffset = size;
        size += strings.reduce(function (prev, cur) {
            return prev + 2 + calculateStringLengthForWrite(cur) * 2;
        }, 0);
        size = roundUp$1(size, 8);
        var descOffset = size;
        size = this.entries.reduce(function (p, e) {
            e.offset = p;
            return p + 16;
        }, descOffset);
        var dataOffset = size;
        size = this.entries.reduce(function (p, e) {
            return roundUp$1(p, 8) + e.bin.byteLength;
        }, dataOffset);
        var alignedSize = roundUp$1(size, alignment);
        var originalAlignedSize = roundUp$1(this.originalSize, alignment);
        if (noGrow) {
            if (alignedSize > originalAlignedSize) {
                throw new Error('New resource data is larger than original');
            }
        }
        if (!allowShrink) {
            if (alignedSize < originalAlignedSize) {
                alignedSize = originalAlignedSize;
            }
        }
        // generate binary
        var bin = new ArrayBuffer(alignedSize);
        var view = new DataView(bin);
        var o = descOffset;
        var va = virtualAddress + dataOffset;
        this.entries.forEach(function (e) {
            var len = e.bin.byteLength;
            if (typeof e.rva !== 'undefined') {
                // RVA
                view.setUint32(o, e.rva, true);
            }
            else {
                va = roundUp$1(va, 8);
                // RVA
                view.setUint32(o, va, true);
                va += len;
            }
            // size
            view.setUint32(o + 4, len, true);
            // codepage
            view.setUint32(o + 8, e.codepage, true);
            // (zero)
            view.setUint32(o + 12, 0, true);
            o += 16;
        });
        o = dataOffset;
        this.entries.forEach(function (e) {
            var len = e.bin.byteLength;
            copyBuffer$1(bin, o, e.bin, 0, len);
            o += roundUp$1(len, 8);
        });
        var stringsData = [];
        o = stringsOffset;
        strings.forEach(function (s) {
            stringsData.push({
                offset: o,
                text: s,
            });
            o = writeString(view, o, s);
        });
        writeTypeTable(view, 0, stringsData, r);
        // fill with 'PADDINGX'
        if (alignedSize > size) {
            var pad = 'PADDINGX';
            for (var i = size, j = 0; i < alignedSize; ++i, ++j) {
                if (j === 8) {
                    j = 0;
                }
                view.setUint8(i, pad.charCodeAt(j));
            }
        }
        return {
            bin: bin,
            rawSize: size,
            dataOffset: dataOffset,
            descEntryOffset: descOffset,
            descEntryCount: this.entries.length,
        };
    };
    /**
     * Writes holding resource data to specified NtExecutable instance.
     * @param exeDest An NtExecutable instance to write resource section to
     * @param noGrow Set true to disallow growing resource section (throw errors if data exceeds)
     * @param allowShrink Set true to allow shrinking resource section (if the data size is less than original)
     */
    NtExecutableResource.prototype.outputResource = function (exeDest, noGrow, allowShrink) {
        if (noGrow === void 0) { noGrow = false; }
        if (allowShrink === void 0) { allowShrink = false; }
        // make section data
        var fileAlign = exeDest.getFileAlignment();
        var sectionData;
        if (this.sectionDataHeader) {
            sectionData = {
                data: null,
                info: cloneObject$1(this.sectionDataHeader),
            };
        }
        else {
            sectionData = {
                data: null,
                info: {
                    name: '.rsrc',
                    virtualSize: 0,
                    virtualAddress: 0,
                    sizeOfRawData: 0,
                    pointerToRawData: 0,
                    pointerToRelocations: 0,
                    pointerToLineNumbers: 0,
                    numberOfRelocations: 0,
                    numberOfLineNumbers: 0,
                    characteristics: 0x40000040, // read access and initialized data
                },
            };
        }
        // first, set virtualAddress to 0 because
        // the virtual address is not determined now
        var data = this.generateResourceData(0, fileAlign, noGrow, allowShrink);
        sectionData.data = data.bin;
        sectionData.info.sizeOfRawData = data.bin.byteLength;
        sectionData.info.virtualSize = data.rawSize;
        // write as section
        exeDest.setSectionByEntry(ImageDirectoryEntry$1.Resource, sectionData);
        // rewrite section raw-data
        var generatedSection = exeDest.getSectionByEntry(ImageDirectoryEntry$1.Resource);
        var view = new DataView(generatedSection.data);
        // set RVA
        var o = data.descEntryOffset;
        var va = generatedSection.info.virtualAddress + data.dataOffset;
        for (var i = 0; i < data.descEntryCount; ++i) {
            var len = view.getUint32(o + 4, true);
            va = roundUp$1(va, 8);
            // RVA
            view.setUint32(o, va, true);
            va += len;
            o += 16;
        }
    };
    return NtExecutableResource;
}());

var version$1 = '1.0.0';

function getImageDosHeader(bin) {
    return ImageDosHeader.from(bin);
}
function getImageNtHeadersByDosHeader(bin, dosHeader) {
    return ImageNtHeaders.from(bin, dosHeader.newHeaderAddress);
}
function getImageSectionHeadersByNtHeaders(bin, dosHeader, ntHeaders) {
    return ImageSectionHeaderArray.from(bin, ntHeaders.fileHeader.numberOfSections, dosHeader.newHeaderAddress + ntHeaders.byteLength);
}
function findImageSectionBlockByDirectoryEntry(bin, dosHeader, ntHeaders, entryType) {
    var arr = ImageSectionHeaderArray.from(bin, ntHeaders.fileHeader.numberOfSections, dosHeader.newHeaderAddress + ntHeaders.byteLength);
    var len = arr.length;
    var rva = ntHeaders.optionalHeaderDataDirectory.get(entryType).virtualAddress;
    for (var i = 0; i < len; ++i) {
        var sec = arr.get(i);
        var vaEnd = sec.virtualAddress + sec.virtualSize;
        if (rva >= sec.virtualAddress && rva < vaEnd) {
            var ptr = sec.pointerToRawData;
            if (!ptr) {
                return null;
            }
            return bin.slice(ptr, ptr + sec.sizeOfRawData);
        }
        if (rva < sec.virtualAddress) {
            return null;
        }
    }
    return null;
}

var index$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ArrayFormatBase: ArrayFormatBase,
    FormatBase: FormatBase,
    ImageDataDirectoryArray: ImageDataDirectoryArray,
    ImageDirectoryEntry: ImageDirectoryEntry$1,
    ImageDosHeader: ImageDosHeader,
    ImageFileHeader: ImageFileHeader,
    ImageNtHeaders: ImageNtHeaders,
    ImageOptionalHeader: ImageOptionalHeader,
    ImageOptionalHeader64: ImageOptionalHeader64,
    ImageSectionHeaderArray: ImageSectionHeaderArray,
    findImageSectionBlockByDirectoryEntry: findImageSectionBlockByDirectoryEntry,
    getImageDosHeader: getImageDosHeader,
    getImageNtHeadersByDosHeader: getImageNtHeadersByDosHeader,
    getImageSectionHeadersByNtHeaders: getImageSectionHeadersByNtHeaders
});

var version = '2.0.0';

// eslint-disable-next-line @typescript-eslint/triple-slash-reference
/// <reference lib='dom' />
function cloneObject(object) {
    var r = {};
    Object.keys(object).forEach(function (key) {
        r[key] = object[key];
    });
    return r;
}
/* eslint-enable @typescript-eslint/ban-types */
function createDataView(bin, byteOffset, byteLength) {
    if ('buffer' in bin) {
        var newOffset = bin.byteOffset;
        var newLength = bin.byteLength;
        if (typeof byteOffset !== 'undefined') {
            newOffset += byteOffset;
            newLength -= byteOffset;
        }
        if (typeof byteLength !== 'undefined') {
            newLength = byteLength;
        }
        return new DataView(bin.buffer, newOffset, newLength);
    }
    else {
        return new DataView(bin, byteOffset, byteLength);
    }
}
function roundUp(val, align) {
    return Math.floor((val + align - 1) / align) * align;
}
function copyBuffer(dest, destOffset, src, srcOffset, length) {
    var ua8Dest = 'buffer' in dest
        ? new Uint8Array(dest.buffer, dest.byteOffset + (destOffset || 0), length)
        : new Uint8Array(dest, destOffset, length);
    var ua8Src = 'buffer' in src
        ? new Uint8Array(src.buffer, src.byteOffset + (srcOffset || 0), length)
        : new Uint8Array(src, srcOffset, length);
    ua8Dest.set(ua8Src);
}
function allocatePartialBinary(binBase, offset, length) {
    var b = new ArrayBuffer(length);
    copyBuffer(b, 0, binBase, offset, length);
    return b;
}
function cloneToArrayBuffer(binBase) {
    if ('buffer' in binBase) {
        var b = new ArrayBuffer(binBase.byteLength);
        new Uint8Array(b).set(new Uint8Array(binBase.buffer, binBase.byteOffset, binBase.byteLength));
        return b;
    }
    else {
        var b = new ArrayBuffer(binBase.byteLength);
        new Uint8Array(b).set(new Uint8Array(binBase));
        return b;
    }
}
function readInt32WithLastOffset(view, offset, last) {
    return offset + 4 <= last ? view.getInt32(offset, true) : 0;
}
function readUint8WithLastOffset(view, offset, last) {
    return offset < last ? view.getUint8(offset) : 0;
}
function readUint16WithLastOffset(view, offset, last) {
    return offset + 2 <= last ? view.getUint16(offset, true) : 0;
}
function readUint32WithLastOffset(view, offset, last) {
    return offset + 4 <= last ? view.getUint32(offset, true) : 0;
}

function calcMaskSize(width, height) {
    // round up to 4 bytes (32 bit)
    // (mask pixels is 1-bit bitmap)
    var actualWidthBytes = roundUp(Math.abs(width), 32) / 8;
    return actualWidthBytes * Math.abs(height);
}
var IconItem = /** @class */ (function () {
    function IconItem(width, height, bin, byteOffset, byteLength) {
        var view = createDataView(bin, byteOffset, byteLength);
        var totalSize = view.byteLength;
        var headerSize = view.getUint32(0, true);
        if (headerSize > totalSize) {
            headerSize = totalSize;
        }
        var sizeImage = readUint32WithLastOffset(view, 20, headerSize);
        var bi = {
            width: readInt32WithLastOffset(view, 4, headerSize),
            height: readInt32WithLastOffset(view, 8, headerSize),
            planes: readUint16WithLastOffset(view, 12, headerSize),
            bitCount: readUint16WithLastOffset(view, 14, headerSize),
            compression: readUint32WithLastOffset(view, 16, headerSize),
            sizeImage: sizeImage,
            xPelsPerMeter: readInt32WithLastOffset(view, 24, headerSize),
            yPelsPerMeter: readInt32WithLastOffset(view, 28, headerSize),
            colorUsed: readUint32WithLastOffset(view, 32, headerSize),
            colorImportant: readUint32WithLastOffset(view, 36, headerSize),
            colors: [],
        };
        var offset = 40;
        var colors = bi.colorUsed;
        if (!colors) {
            switch (bi.bitCount) {
                case 1:
                    colors = 2;
                    break;
                case 4:
                    colors = 16;
                    break;
                case 8:
                    colors = 256;
                    break;
            }
        }
        for (var i = 0; i < colors; ++i) {
            bi.colors.push({
                b: readUint8WithLastOffset(view, offset, totalSize),
                g: readUint8WithLastOffset(view, offset + 1, totalSize),
                r: readUint8WithLastOffset(view, offset + 2, totalSize),
            });
            offset += 4;
        }
        this.width = width;
        this.height = height;
        this.bitmapInfo = bi;
        // round up to 4 bytes (32 bit)
        var widthBytes = roundUp(bi.bitCount * Math.abs(bi.width), 32) / 8;
        var absActualHeight = Math.abs(bi.height) / 2;
        var size = sizeImage || widthBytes * absActualHeight;
        this._pixels = allocatePartialBinary(view, offset, size);
        offset += size;
        var maskSize = calcMaskSize(bi.width, absActualHeight);
        if (maskSize + offset <= totalSize) {
            this.masks = allocatePartialBinary(view, offset, maskSize);
        }
        else {
            // create a zero buffer (no mask is not allowed)
            this.masks = new ArrayBuffer(maskSize);
        }
    }
    Object.defineProperty(IconItem.prototype, "pixels", {
        /**
         * Bitmap pixel data.
         * @note
         * On set, if `bitmapInfo.sizeImage` is non-zero, `bitmapInfo.sizeImage` will be updated.
         */
        get: function () {
            return this._pixels;
        },
        /**
         * Bitmap pixel data.
         * @note
         * On set, if `bitmapInfo.sizeImage` is non-zero, `bitmapInfo.sizeImage` will be updated.
         */
        set: function (newValue) {
            this._pixels = newValue;
            if (this.bitmapInfo.sizeImage !== 0) {
                this.bitmapInfo.sizeImage = newValue.byteLength;
            }
        },
        enumerable: false,
        configurable: true
    });
    IconItem.from = function (arg1, arg2, arg3, byteOffset, byteLength) {
        var width;
        var height;
        var bin;
        if (typeof arg3 === 'object') {
            // second overload
            width = arg1;
            height = arg2;
            bin = arg3;
        }
        else {
            // first overload
            width = null;
            height = null;
            bin = arg1;
            byteOffset = arg2;
            byteLength = arg3;
        }
        return new IconItem(width, height, bin, byteOffset, byteLength);
    };
    IconItem.prototype.isIcon = function () {
        return true;
    };
    IconItem.prototype.isRaw = function () {
        return false;
    };
    IconItem.prototype.generate = function () {
        var bi = this.bitmapInfo;
        var absWidth = Math.abs(bi.width);
        // round up to 4 bytes (32 bit)
        var absWidthBytes = roundUp(bi.bitCount * absWidth, 32) / 8;
        var absActualHeight = Math.abs(bi.height) / 2;
        var actualSizeImage = absWidthBytes * absActualHeight;
        var sizeMask = calcMaskSize(bi.width, absActualHeight);
        var colorCount = bi.colors.length;
        var totalSize = 40 + 4 * colorCount + actualSizeImage + sizeMask;
        var bin = new ArrayBuffer(totalSize);
        var view = new DataView(bin);
        view.setUint32(0, 40, true);
        view.setInt32(4, bi.width, true);
        view.setInt32(8, bi.height, true);
        view.setUint16(12, bi.planes, true);
        view.setUint16(14, bi.bitCount, true);
        view.setUint32(16, bi.compression, true);
        // image size
        view.setUint32(20, bi.sizeImage, true);
        view.setInt32(24, bi.xPelsPerMeter, true);
        view.setInt32(28, bi.yPelsPerMeter, true);
        view.setUint32(32, bi.colorUsed, true);
        view.setUint32(36, bi.colorImportant > colorCount ? colorCount : bi.colorImportant, true);
        var offset = 40;
        bi.colors.forEach(function (c) {
            view.setUint8(offset, c.b);
            view.setUint8(offset + 1, c.g);
            view.setUint8(offset + 2, c.r);
            offset += 4;
        });
        copyBuffer(bin, offset, this.pixels, 0, actualSizeImage);
        copyBuffer(bin, offset + actualSizeImage, this.masks, 0, sizeMask);
        return bin;
    };
    return IconItem;
}());

/**
 * Represents the raw-graphic icon item, such as PNG data.
 */
var RawIconItem = /** @class */ (function () {
    function RawIconItem(bin, width, height, bitCount, byteOffset, byteLength) {
        this.width = width;
        this.height = height;
        this.bitCount = bitCount;
        if (typeof byteOffset !== 'number') {
            byteOffset = 0;
            byteLength = bin.byteLength;
        }
        else if (typeof byteLength !== 'number') {
            byteLength = bin.byteLength - byteOffset;
        }
        this.bin = allocatePartialBinary(bin, byteOffset, byteLength);
    }
    RawIconItem.from = function (bin, width, height, bitCount, byteOffset, byteLength) {
        return new RawIconItem(bin, width, height, bitCount, byteOffset, byteLength);
    };
    RawIconItem.prototype.isIcon = function () {
        return false;
    };
    RawIconItem.prototype.isRaw = function () {
        return true;
    };
    return RawIconItem;
}());

function generateEntryBinary$1(icons) {
    var count = icons.length;
    /* istanbul ignore if */
    if (count > 65535) {
        count = 65535;
    }
    var tmpIcons = icons.map(function (item) {
        if (item.data.isIcon()) {
            return {
                item: item,
                bin: item.data.generate(),
                offset: 0,
            };
        }
        else {
            return {
                item: item,
                bin: item.data.bin,
                offset: 0,
            };
        }
    });
    var size = tmpIcons.reduce(function (p, icon) {
        icon.offset = p;
        return p + icon.bin.byteLength;
    }, 6 + 16 * count);
    var bin = new ArrayBuffer(size);
    var view = new DataView(bin);
    view.setUint16(0, 0, true); // reserved
    view.setUint16(2, 1, true); // icon type
    view.setUint16(4, count, true);
    var offset = 6;
    tmpIcons.forEach(function (icon) {
        var item = icon.item;
        var width;
        var height;
        var colors;
        var planes;
        var bitCount;
        if (item.data.isIcon()) {
            var bi = item.data.bitmapInfo;
            width =
                typeof item.width !== 'undefined'
                    ? item.width
                    : Math.abs(bi.width);
            height =
                typeof item.height !== 'undefined'
                    ? item.height
                    : Math.abs(bi.height / 2);
            colors =
                typeof item.colors !== 'undefined'
                    ? item.colors
                    : bi.colorUsed || bi.colors.length;
            planes =
                typeof item.planes !== 'undefined' ? item.planes : bi.planes;
            bitCount =
                typeof item.bitCount !== 'undefined'
                    ? item.bitCount
                    : bi.bitCount;
        }
        else {
            width =
                typeof item.width !== 'undefined'
                    ? item.width
                    : Math.abs(item.data.width);
            height =
                typeof item.height !== 'undefined'
                    ? item.height
                    : Math.abs(item.data.height);
            colors = typeof item.colors !== 'undefined' ? item.colors : 0;
            planes = typeof item.planes !== 'undefined' ? item.planes : 1;
            bitCount =
                typeof item.bitCount !== 'undefined'
                    ? item.bitCount
                    : item.data.bitCount;
        }
        var dataSize = icon.bin.byteLength;
        view.setUint8(offset, width >= 256 ? 0 : width);
        view.setUint8(offset + 1, height >= 256 ? 0 : height);
        view.setUint8(offset + 2, colors >= 256 ? 0 : colors);
        view.setUint8(offset + 3, 0);
        view.setUint16(offset + 4, planes, true);
        view.setUint16(offset + 6, bitCount, true);
        view.setUint32(offset + 8, dataSize, true);
        view.setUint32(offset + 12, icon.offset, true);
        offset += 16;
        copyBuffer(bin, icon.offset, icon.bin, 0, dataSize);
    });
    return bin;
}
var IconFile = /** @class */ (function () {
    function IconFile(bin) {
        if (!bin) {
            this.icons = [];
            return;
        }
        var view = createDataView(bin);
        var totalSize = view.byteLength;
        var icons = [];
        /* istanbul ignore else */
        if (view.getUint16(2, true) === 1) {
            var count = view.getUint16(4, true);
            var offset = 6;
            for (var i = 0; i < count; ++i) {
                var dataSize = readUint32WithLastOffset(view, offset + 8, totalSize);
                var dataOffset = readUint32WithLastOffset(view, offset + 12, totalSize);
                var width = readUint8WithLastOffset(view, offset, totalSize);
                var height = readUint8WithLastOffset(view, offset + 1, totalSize);
                var bitCount = readUint8WithLastOffset(view, offset + 6, totalSize);
                var data = void 0;
                if (view.getUint32(dataOffset, true) === 0x28) {
                    data = IconItem.from(width, height, bin, dataOffset, dataSize);
                }
                else {
                    data = RawIconItem.from(bin, width || 256, height || 256, bitCount, dataOffset, dataSize);
                }
                icons.push({
                    width: width,
                    height: height,
                    colors: readUint8WithLastOffset(view, offset + 2, totalSize),
                    planes: readUint16WithLastOffset(view, offset + 4, totalSize),
                    bitCount: bitCount,
                    data: data,
                });
                offset += 16;
            }
        }
        this.icons = icons;
    }
    IconFile.from = function (bin) {
        return new IconFile(bin);
    };
    IconFile.prototype.generate = function () {
        return generateEntryBinary$1(this.icons);
    };
    return IconFile;
}());

var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    IconFile: IconFile,
    IconItem: IconItem,
    RawIconItem: RawIconItem
});

function generateEntryBinary(icons) {
    var count = icons.length;
    if (count > 65535) {
        count = 65535;
    }
    var size = 6 + 14 * icons.length;
    var bin = new ArrayBuffer(size);
    var view = new DataView(bin);
    view.setUint16(0, 0, true); // reserved
    view.setUint16(2, 1, true); // icon type
    view.setUint16(4, count, true);
    var offset = 6;
    icons.forEach(function (icon) {
        view.setUint8(offset, icon.width >= 256 ? 0 : icon.width);
        view.setUint8(offset + 1, icon.height >= 256 ? 0 : icon.height);
        view.setUint8(offset + 2, icon.colors >= 256 ? 0 : icon.colors);
        view.setUint8(offset + 3, 0);
        view.setUint16(offset + 4, icon.planes, true);
        view.setUint16(offset + 6, icon.bitCount, true);
        view.setUint32(offset + 8, icon.dataSize, true);
        view.setUint16(offset + 12, icon.iconID, true);
        offset += 14;
    });
    return bin;
}
function findUnusedIconID(entries, lang, isCursor) {
    var type = isCursor ? 1 : 3;
    // (ignore string id)
    var filteredIDs = entries
        .filter(function (e) { return e.type === type && e.lang === lang && typeof e.id === 'number'; })
        .map(function (e) { return e.id; })
        .sort(function (a, b) { return a - b; });
    var idCurrent = 1;
    for (var i = 0; i < filteredIDs.length; ++i) {
        var id = filteredIDs[i];
        if (idCurrent < id) {
            return {
                id: idCurrent,
                last: false,
            };
        }
        else if (idCurrent === id) {
            ++idCurrent;
        }
    }
    return {
        id: idCurrent,
        last: true,
    };
}
/**
 * A class that treats icon-group resource data (`RT_ICON_GROUP`).
 * Note that this class does not treat `RT_ICON` data.
 *
 * - To pick all icons, use `IconGroupEntry.fromEntries`
 *   and `IconGroupEntry.prototype.getIconItemsFromEntries`.
 * - The easiest way to add/replace icons is using `IconGroupEntry.replaceIconsForResource`,
 *   which treats both `RT_ICON_GROUP` and `RT_ICON` entries.
 */
var IconGroupEntry = /** @class */ (function () {
    function IconGroupEntry(groupEntry) {
        var view = new DataView(groupEntry.bin);
        var totalSize = view.byteLength;
        var icons = [];
        if (view.getUint16(2, true) === 1) {
            var count = view.getUint16(4, true);
            var offset = 6;
            for (var i = 0; i < count; ++i) {
                icons.push({
                    width: readUint8WithLastOffset(view, offset, totalSize),
                    height: readUint8WithLastOffset(view, offset + 1, totalSize),
                    colors: readUint8WithLastOffset(view, offset + 2, totalSize),
                    planes: readUint16WithLastOffset(view, offset + 4, totalSize),
                    bitCount: readUint16WithLastOffset(view, offset + 6, totalSize),
                    dataSize: readUint32WithLastOffset(view, offset + 8, totalSize),
                    iconID: readUint16WithLastOffset(view, offset + 12, totalSize),
                });
                offset += 14; // 16 for .ico file, but 14 for resource data
            }
        }
        this.id = groupEntry.id;
        this.lang = groupEntry.lang;
        this.icons = icons;
    }
    IconGroupEntry.fromEntries = function (entries) {
        return entries
            .filter(function (e) { return e.type === 14; })
            .map(function (e) { return new IconGroupEntry(e); });
    };
    IconGroupEntry.prototype.generateEntry = function () {
        var bin = generateEntryBinary(this.icons);
        return {
            type: 14,
            id: this.id,
            lang: this.lang,
            codepage: 0,
            bin: bin,
        };
    };
    /**
     * Return an array of `IconItem` / `RawIconItem`, which are in the group of this `IconGroupEntry` instance,
     * from specified resource entries.
     */
    IconGroupEntry.prototype.getIconItemsFromEntries = function (entries) {
        var _this = this;
        return entries
            .map(function (e) {
            if (e.type !== 3 || e.lang !== _this.lang) {
                return null;
            }
            var c = _this.icons
                .filter(function (icon) { return e.id === icon.iconID; })
                .shift();
            if (!c) {
                return null;
            }
            return {
                entry: e,
                icon: c,
            };
        })
            .filter(function (item) { return !!item; })
            .map(function (item) {
            var bin = item.entry.bin;
            var view = new DataView(bin);
            if (view.getUint32(0, true) === 0x28) {
                return IconItem.from(bin);
            }
            else {
                var c = item.icon;
                return RawIconItem.from(bin, c.width, c.height, c.bitCount);
            }
        });
    };
    /**
     * Add or replace icon resource entries with specified icon data.
     * The IDs of individual icon resources (`RT_ICON`) are calculated automatically.
     * @param destEntries base (destination) resource entries.
     * @param iconGroupID the icon ID for the new resource data.
     *     If the icon-group resource of the ID and 'lang' value already exists,
     *     the resource data is replaced; otherwise the resource data is appended.
     * @param lang the language for specified icons (0 for neutral, 0x409 for en-US)
     * @param icons the icons to replace
     */
    IconGroupEntry.replaceIconsForResource = function (destEntries, iconGroupID, lang, icons) {
        // find existing entry
        var entry = destEntries
            .filter(function (e) { return e.type === 14 && e.id === iconGroupID && e.lang === lang; })
            .shift();
        var tmpIconArray = icons.map(function (icon) {
            if (icon.isIcon()) {
                var width = icon.width, height = icon.height;
                if (width === null) {
                    width = icon.bitmapInfo.width;
                }
                if (height === null) {
                    height = icon.bitmapInfo.height;
                    // if mask is specified, the icon height must be the half of bitmap height
                    if (icon.masks !== null) {
                        height = Math.floor(height / 2);
                    }
                }
                return {
                    base: icon,
                    bm: {
                        width: width,
                        height: height,
                        planes: icon.bitmapInfo.planes,
                        bitCount: icon.bitmapInfo.bitCount,
                    },
                    bin: icon.generate(),
                    id: 0,
                };
            }
            else {
                return {
                    base: icon,
                    bm: {
                        width: icon.width,
                        height: icon.height,
                        planes: 1,
                        bitCount: icon.bitCount,
                    },
                    bin: icon.bin,
                    id: 0,
                };
            }
        });
        if (entry) {
            // remove unused icon data
            for (var i = destEntries.length - 1; i >= 0; --i) {
                var e = destEntries[i];
                if (e.type === 3) {
                    // RT_ICON
                    if (!isIconUsed(e, destEntries, entry)) {
                        destEntries.splice(i, 1);
                    }
                }
            }
        }
        else {
            // create new entry
            entry = {
                type: 14,
                id: iconGroupID,
                lang: lang,
                codepage: 0,
                // set later
                bin: null,
            };
            destEntries.push(entry);
        }
        // append icons
        var idInfo;
        tmpIconArray.forEach(function (icon) {
            if (!(idInfo === null || idInfo === void 0 ? void 0 : idInfo.last)) {
                idInfo = findUnusedIconID(destEntries, lang, false);
            }
            else {
                ++idInfo.id;
            }
            destEntries.push({
                type: 3,
                id: idInfo.id,
                lang: lang,
                codepage: 0,
                bin: icon.bin,
            });
            // set 'id' field to use in generateEntryBinary
            icon.id = idInfo.id;
        });
        var binEntry = generateEntryBinary(tmpIconArray.map(function (icon) {
            var width = Math.abs(icon.bm.width);
            if (width >= 256) {
                width = 0;
            }
            var height = Math.abs(icon.bm.height);
            if (height >= 256) {
                height = 0;
            }
            var colors = 0;
            if (icon.base.isIcon()) {
                var bmBase = icon.base.bitmapInfo;
                colors = bmBase.colorUsed || bmBase.colors.length;
                if (!colors) {
                    switch (bmBase.bitCount) {
                        case 1:
                            colors = 2;
                            break;
                        case 4:
                            colors = 16;
                            break;
                        // case 8:
                        // 	colors = 256;
                        // 	break;
                    }
                }
                if (colors >= 256) {
                    colors = 0;
                }
            }
            return {
                width: width,
                height: height,
                colors: colors,
                planes: icon.bm.planes,
                bitCount: icon.bm.bitCount,
                dataSize: icon.bin.byteLength,
                iconID: icon.id,
            };
        }));
        // rewrite entry
        entry.bin = binEntry;
        function isIconUsed(icon, allEntries, excludeGroup) {
            return allEntries.some(function (e) {
                if (e.type !== 14 ||
                    (e.id === excludeGroup.id && e.lang === excludeGroup.lang)) {
                    return false;
                }
                var g = new IconGroupEntry(e);
                return g.icons.some(function (c) {
                    return c.iconID === icon.id;
                });
            });
        }
    };
    return IconGroupEntry;
}());

// StringTable entry:
//   16-times of {<WORD length> [<UTF-16 string>]}
var StringTableItem = /** @class */ (function () {
    function StringTableItem() {
        this.length = 16;
        this._a = [];
        this._a.length = 16;
        for (var i = 0; i < 16; ++i) {
            this._a[i] = '';
        }
    }
    StringTableItem.fromEntry = function (bin, offset, byteLength) {
        var view = new DataView(bin, offset, byteLength);
        var ret = new StringTableItem();
        var o = 0;
        for (var i = 0; i < 16; ++i) {
            var len = view.getUint16(o, true);
            o += 2;
            var s = '';
            for (var j = 0; j < len; ++j) {
                s += String.fromCharCode(view.getUint16(o, true));
                o += 2;
            }
            ret._a[i] = s;
        }
        return ret;
    };
    StringTableItem.prototype.get = function (index) {
        return this._a[index] || null;
    };
    StringTableItem.prototype.getAll = function () {
        return this._a.map(function (s) { return s || null; });
    };
    StringTableItem.prototype.set = function (index, val) {
        this._a[index] = "".concat(val !== null && val !== void 0 ? val : '').substr(0, 4097); // length must be no longer than 4097
    };
    StringTableItem.prototype.calcByteLength = function () {
        var len = 0;
        for (var i = 0; i < 16; ++i) {
            len += 2;
            len += 2 * this._a[i].length; // UTF-16 length
        }
        // 16 alignment
        return Math.floor((len + 15) / 16) * 16;
    };
    StringTableItem.prototype.generate = function (bin, offset) {
        var out = new DataView(bin, offset);
        var len = 0;
        for (var i = 0; i < 16; ++i) {
            var s = this._a[i];
            var l = s.length > 4097 ? 4097 : s.length;
            out.setUint16(len, l, true);
            len += 2;
            for (var j = 0; j < l; ++j) {
                // output as UTF-16
                out.setUint16(len, s.charCodeAt(j), true);
                len += 2;
            }
        }
        // 16 alignment
        return Math.floor((len + 15) / 16) * 16;
    };
    return StringTableItem;
}());

/** Utility class to create / parse String Table resource */
var StringTable = /** @class */ (function () {
    function StringTable() {
        this.lang = 0;
        this.items = [];
    }
    /** Create StringTable instance from resource entries, with specified language. */
    StringTable.fromEntries = function (lang, entries) {
        var r = new StringTable();
        entries.forEach(function (e) {
            // 6: RT_STRING
            if (e.type !== 6 ||
                e.lang !== lang ||
                typeof e.id !== 'number' ||
                e.id <= 0) {
                return;
            }
            r.items[e.id - 1] = StringTableItem.fromEntry(e.bin, 0, e.bin.byteLength);
        });
        r.lang = lang;
        return r;
    };
    /** Return all string entries. */
    StringTable.prototype.getAllStrings = function () {
        return this.items
            .map(function (e, i) {
            return e
                .getAll()
                .map(function (x, j) {
                return x !== null && x !== ''
                    ? { id: (i << 4) + j, text: x }
                    : null;
            })
                .filter(function (x) { return !!x; });
        })
            .reduce(function (p, c) { return p.concat(c); }, []);
    };
    /** Return the string data for ID value, which can be used for Win32API LoadString. */
    StringTable.prototype.getById = function (id) {
        var _a;
        if (id < 0) {
            return null;
        }
        var entryIndex = id >> 4;
        var entryPos = id & 15;
        var e = this.items[entryIndex];
        return (_a = e === null || e === void 0 ? void 0 : e.get(entryPos)) !== null && _a !== void 0 ? _a : null;
    };
    /**
     * Set/overwide the string data for ID value, which can be used for Win32API LoadString.
     * @param id data ID
     * @param text string data (entry will be removed if null or empty string is specified)
     */
    StringTable.prototype.setById = function (id, text) {
        if (id < 0) {
            return;
        }
        var entryIndex = id >> 4;
        var entryPos = id & 15;
        var e = this.items[entryIndex];
        if (!e) {
            this.items[entryIndex] = e = new StringTableItem();
        }
        e.set(entryPos, text);
    };
    /** Generates an array of Entry for resource processings */
    StringTable.prototype.generateEntries = function () {
        var _this = this;
        return this.items
            .map(function (e, i) {
            var len = e.calcByteLength();
            var bin = new ArrayBuffer(len);
            e.generate(bin, 0);
            return {
                type: 6,
                id: i + 1,
                lang: _this.lang,
                codepage: 1200,
                bin: bin,
            };
        })
            .filter(function (e) { return !!e; });
    };
    /**
     * Replace all string entries for NtExecutableResource with containing resource data.
     * The only entries of same language are replaced.
     */
    StringTable.prototype.replaceStringEntriesForExecutable = function (res) {
        var entries = this.generateEntries();
        var dest = res.entries;
        // first try -- replace same type and same language
        for (var i = 0; i < dest.length; ++i) {
            var e = dest[i];
            if (e.type === 6 && e.lang === this.lang) {
                for (var j = dest.length - 1; j >= i; --j) {
                    var e2 = dest[j];
                    if (e2.type === 6 && e2.lang === this.lang) {
                        dest.splice(j, 1);
                    }
                }
                var f = dest.splice.bind(dest, i, 0);
                f.apply(void 0, entries);
                return;
            }
        }
        // second try -- add entries next to previous language
        for (var i = 0; i < dest.length; ++i) {
            var e = dest[i];
            if (e.type === 6 && e.lang < this.lang) {
                var f = dest.splice.bind(dest, i + 1, 0);
                f.apply(void 0, entries);
                return;
            }
        }
        // third try -- add entries next to the last 'String' entry
        for (var i = dest.length - 1; i >= 0; --i) {
            var e = dest[i];
            if (e.type === 6) {
                var f = dest.splice.bind(dest, i + 1, 0);
                f.apply(void 0, entries);
                return;
            }
        }
        // otherwise -- add entries to the last
        dest.push.apply(dest, entries);
    };
    return StringTable;
}());

/**
 * Flag values used by VersionEntry.fixedInfo field.
 * Zero or more enum values are stored (with OR operator).
 */
var VersionFileFlags;
(function (VersionFileFlags) {
    VersionFileFlags[VersionFileFlags["Debug"] = 1] = "Debug";
    VersionFileFlags[VersionFileFlags["Prerelease"] = 2] = "Prerelease";
    VersionFileFlags[VersionFileFlags["Patched"] = 4] = "Patched";
    VersionFileFlags[VersionFileFlags["PrivateBuild"] = 8] = "PrivateBuild";
    VersionFileFlags[VersionFileFlags["InfoInferred"] = 16] = "InfoInferred";
    VersionFileFlags[VersionFileFlags["SpecialBuild"] = 32] = "SpecialBuild";
})(VersionFileFlags || (VersionFileFlags = {}));
var VersionFileFlags$1 = VersionFileFlags;

/**
 * OS values used by VersionEntry.fixedInfo field.
 */
var VersionFileOS;
(function (VersionFileOS) {
    VersionFileOS[VersionFileOS["Unknown"] = 0] = "Unknown";
    VersionFileOS[VersionFileOS["_Windows16"] = 1] = "_Windows16";
    VersionFileOS[VersionFileOS["_PM16"] = 2] = "_PM16";
    VersionFileOS[VersionFileOS["_PM32"] = 3] = "_PM32";
    VersionFileOS[VersionFileOS["_Windows32"] = 4] = "_Windows32";
    VersionFileOS[VersionFileOS["DOS"] = 65536] = "DOS";
    VersionFileOS[VersionFileOS["OS2_16"] = 131072] = "OS2_16";
    VersionFileOS[VersionFileOS["OS2_32"] = 196608] = "OS2_32";
    VersionFileOS[VersionFileOS["NT"] = 262144] = "NT";
    VersionFileOS[VersionFileOS["DOS_Windows16"] = 65537] = "DOS_Windows16";
    VersionFileOS[VersionFileOS["DOS_Windows32"] = 65540] = "DOS_Windows32";
    VersionFileOS[VersionFileOS["NT_Windows32"] = 262148] = "NT_Windows32";
    VersionFileOS[VersionFileOS["OS2_16_PM16"] = 131074] = "OS2_16_PM16";
    VersionFileOS[VersionFileOS["OS2_32_PM32"] = 196611] = "OS2_32_PM32";
})(VersionFileOS || (VersionFileOS = {}));
var VersionFileOS$1 = VersionFileOS;

var VersionFileDriverSubtype;
(function (VersionFileDriverSubtype) {
    VersionFileDriverSubtype[VersionFileDriverSubtype["Unknown"] = 0] = "Unknown";
    VersionFileDriverSubtype[VersionFileDriverSubtype["Printer"] = 1] = "Printer";
    VersionFileDriverSubtype[VersionFileDriverSubtype["Keyboard"] = 2] = "Keyboard";
    VersionFileDriverSubtype[VersionFileDriverSubtype["Language"] = 3] = "Language";
    VersionFileDriverSubtype[VersionFileDriverSubtype["Display"] = 4] = "Display";
    VersionFileDriverSubtype[VersionFileDriverSubtype["Mouse"] = 5] = "Mouse";
    VersionFileDriverSubtype[VersionFileDriverSubtype["Network"] = 6] = "Network";
    VersionFileDriverSubtype[VersionFileDriverSubtype["System"] = 7] = "System";
    VersionFileDriverSubtype[VersionFileDriverSubtype["Installable"] = 8] = "Installable";
    VersionFileDriverSubtype[VersionFileDriverSubtype["Sound"] = 9] = "Sound";
    VersionFileDriverSubtype[VersionFileDriverSubtype["Comm"] = 10] = "Comm";
    VersionFileDriverSubtype[VersionFileDriverSubtype["VersionedPrinter"] = 12] = "VersionedPrinter";
})(VersionFileDriverSubtype || (VersionFileDriverSubtype = {}));
var VersionFileFontSubtype;
(function (VersionFileFontSubtype) {
    VersionFileFontSubtype[VersionFileFontSubtype["Unknown"] = 0] = "Unknown";
    VersionFileFontSubtype[VersionFileFontSubtype["Raster"] = 1] = "Raster";
    VersionFileFontSubtype[VersionFileFontSubtype["Vector"] = 2] = "Vector";
    VersionFileFontSubtype[VersionFileFontSubtype["TrueType"] = 3] = "TrueType";
})(VersionFileFontSubtype || (VersionFileFontSubtype = {}));

/**
 * File type values used by VersionEntry.fixedInfo field.
 */
var VersionFileType;
(function (VersionFileType) {
    VersionFileType[VersionFileType["Unknown"] = 0] = "Unknown";
    VersionFileType[VersionFileType["App"] = 1] = "App";
    VersionFileType[VersionFileType["DLL"] = 2] = "DLL";
    VersionFileType[VersionFileType["Driver"] = 3] = "Driver";
    VersionFileType[VersionFileType["Font"] = 4] = "Font";
    VersionFileType[VersionFileType["VxD"] = 5] = "VxD";
    VersionFileType[VersionFileType["StaticLibrary"] = 7] = "StaticLibrary";
})(VersionFileType || (VersionFileType = {}));
var VersionFileType$1 = VersionFileType;

function readStringToNullChar(view, offset, last) {
    var r = '';
    while (offset + 2 <= last) {
        var c = view.getUint16(offset, true);
        if (!c) {
            break;
        }
        r += String.fromCharCode(c);
        offset += 2;
    }
    return r;
}
function writeStringWithNullChar(view, offset, value) {
    for (var i = 0; i < value.length; ++i) {
        view.setUint16(offset, value.charCodeAt(i), true);
        offset += 2;
    }
    view.setUint16(offset, 0, true);
    return offset + 2;
}
function createFixedInfo() {
    return {
        fileVersionMS: 0,
        fileVersionLS: 0,
        productVersionMS: 0,
        productVersionLS: 0,
        fileFlagsMask: 0,
        fileFlags: 0,
        fileOS: 0,
        fileType: 0,
        fileSubtype: 0,
        fileDateMS: 0,
        fileDateLS: 0,
    };
}
////////////////////////////////////////////////////////////////////////////////
// parsings
// returns offset and structure
function parseStringTable(view, offset, last) {
    var tableLen = view.getUint16(offset, true);
    var valueLen = view.getUint16(offset + 2, true);
    if (offset + tableLen < last) {
        last = offset + tableLen;
    }
    // value type check is not needed; because no value is needed
    var tableName = readStringToNullChar(view, offset + 6, last);
    offset += roundUp(6 + 2 * (tableName.length + 1), 4);
    var langAndCp = parseInt(tableName, 16);
    if (isNaN(langAndCp)) {
        throw new Error('Invalid StringTable data format');
    }
    // this should be zero
    offset += roundUp(valueLen, 4);
    var r = {
        lang: Math.floor(langAndCp / 0x10000),
        codepage: langAndCp & 0xffff,
        values: {},
    };
    while (offset < last) {
        // String structure
        var childDataLen = view.getUint16(offset, true);
        var childValueLen = view.getUint16(offset + 2, true);
        // value type must be string; if not, skip it
        if (view.getUint16(offset + 4, true) !== 1) {
            offset += childDataLen;
            continue;
        }
        var childDataLast = offset + childDataLen;
        if (childDataLast > last) {
            childDataLast = last;
        }
        var name_1 = readStringToNullChar(view, offset + 6, childDataLast);
        offset = roundUp(offset + 6 + 2 * (name_1.length + 1), 4);
        var childValueLast = offset + childValueLen * 2;
        if (childValueLast > childDataLast) {
            childValueLast = childDataLast;
        }
        var value = readStringToNullChar(view, offset, childValueLast);
        offset = roundUp(childValueLast, 4);
        r.values[name_1] = value;
    }
    // return 'last' instead of 'offset'
    return [last, r];
}
function parseStringFileInfo(view, offset, last) {
    var valueLen = view.getUint16(offset + 2, true);
    // value type check is not needed; because no value is needed
    offset += 36; // roundUp(6 + ByteLenWithNull(L'StringFileInfo'), 4)
    // this should be zero
    offset += roundUp(valueLen, 4);
    var r = [];
    var _loop_1 = function () {
        // StringTable structure
        var childData = parseStringTable(view, offset, last);
        var table = childData[1];
        var a = r.filter(function (e) { return e.lang === table.lang && e.codepage === table.codepage; });
        if (a.length === 0) {
            r.push(table);
        }
        else {
            // merge values
            for (var key in table.values) {
                a[0].values[key] = table.values[key];
            }
        }
        offset = roundUp(childData[0], 4);
    };
    while (offset < last) {
        _loop_1();
    }
    return r;
}
function parseVarFileInfo(view, offset, last) {
    var valueLen = view.getUint16(offset + 2, true);
    // value type check is not needed; because no value is needed
    offset += 32; // roundUp(6 + ByteLenWithNull(L'VarFileInfo'), 4)
    // this should be zero
    offset += roundUp(valueLen, 4);
    var r = [];
    while (offset < last) {
        // Var structure
        var childDataLen = view.getUint16(offset, true);
        var childValueLen = view.getUint16(offset + 2, true);
        // value type must be binary; if not, skip it
        if (view.getUint16(offset + 4, true) !== 0) {
            offset += roundUp(childDataLen, 4);
            continue;
        }
        var childDataLast = offset + childDataLen;
        if (childDataLast > last) {
            childDataLast = last;
        }
        var name_2 = readStringToNullChar(view, offset + 6, childDataLast);
        offset = roundUp(offset + 6 + 2 * (name_2.length + 1), 4);
        if (name_2 !== 'Translation' || childValueLen % 4 !== 0) {
            // unknown entry
            offset = roundUp(childDataLast, 4);
            continue;
        }
        var _loop_2 = function (child) {
            if (offset + 4 > childDataLast) {
                return "break";
            }
            var lang = view.getUint16(offset, true);
            var codepage = view.getUint16(offset + 2, true);
            offset += 4;
            if (r.filter(function (e) { return e.lang === lang && e.codepage === codepage; })
                .length === 0) {
                r.push({ lang: lang, codepage: codepage });
            }
        };
        for (var child = 0; child < childValueLen; child += 4) {
            var state_1 = _loop_2(child);
            if (state_1 === "break")
                break;
        }
        offset = roundUp(childDataLast, 4);
    }
    return r;
}
function parseVersionEntry(view, entry) {
    var totalLen = view.getUint16(0, true);
    var dataLen = view.getUint16(2, true);
    // value type must be binary
    if (view.getUint16(4, true) !== 0) {
        throw new Error('Invalid version data format');
    }
    // 40 === roundUp(6 + ByteLenWithNull(L'VS_VERSION_INFO'), 4)
    if (totalLen < dataLen + 40) {
        throw new Error('Invalid version data format');
    }
    if (readStringToNullChar(view, 6, totalLen) !== 'VS_VERSION_INFO') {
        throw new Error('Invalid version data format');
    }
    var d = {
        lang: entry.lang,
        fixedInfo: createFixedInfo(),
        strings: [],
        translations: [],
        unknowns: [],
    };
    var offset = 38; // without padding
    if (dataLen) {
        dataLen += 40; // with padding
        var sig = readUint32WithLastOffset(view, 40, dataLen);
        var sVer = readUint32WithLastOffset(view, 44, dataLen);
        // check signature
        if (sig === 0xfeef04bd && sVer <= 0x10000) {
            d.fixedInfo = {
                fileVersionMS: readUint32WithLastOffset(view, 48, dataLen),
                fileVersionLS: readUint32WithLastOffset(view, 52, dataLen),
                productVersionMS: readUint32WithLastOffset(view, 56, dataLen),
                productVersionLS: readUint32WithLastOffset(view, 60, dataLen),
                fileFlagsMask: readUint32WithLastOffset(view, 64, dataLen),
                fileFlags: readUint32WithLastOffset(view, 68, dataLen),
                fileOS: readUint32WithLastOffset(view, 72, dataLen),
                fileType: readUint32WithLastOffset(view, 76, dataLen),
                fileSubtype: readUint32WithLastOffset(view, 80, dataLen),
                fileDateMS: readUint32WithLastOffset(view, 84, dataLen),
                fileDateLS: readUint32WithLastOffset(view, 88, dataLen),
            };
        }
        offset = dataLen;
    }
    offset = roundUp(offset, 4);
    // parse children
    while (offset < totalLen) {
        var childLen = view.getUint16(offset, true);
        var childLast = offset + childLen;
        // failsafe
        if (childLast > totalLen) {
            childLast = totalLen;
        }
        var name_3 = readStringToNullChar(view, offset + 6, childLast);
        switch (name_3) {
            case 'StringFileInfo':
                d.strings = d.strings.concat(parseStringFileInfo(view, offset, childLast));
                break;
            case 'VarFileInfo':
                d.translations = d.translations.concat(parseVarFileInfo(view, offset, childLast));
                break;
            default:
                // unknown or unsupported type
                d.unknowns.push({
                    name: name_3,
                    entireBin: allocatePartialBinary(view, offset, childLen),
                });
                break;
        }
        offset += roundUp(childLen, 4);
    }
    return d;
}
////////////////////////////////////////////////////////////////////////////////
// serializings
function generateStringTable(table) {
    // estimate size
    var size = 24; // roundUp(6 + ByteLenWithNull(L'xxxxxxxx'), 4)
    var keys = Object.keys(table.values);
    size = keys.reduce(function (prev, key) {
        var value = table.values[key];
        var childHeaderSize = roundUp(6 + 2 * (key.length + 1), 4);
        var newSize = roundUp(prev + childHeaderSize + 2 * (value.length + 1), 4);
        // limit to 65532 because the table size is restricted to 16-bit value
        return newSize > 65532 ? prev : newSize;
    }, size);
    // generate binary
    var bin = new ArrayBuffer(size);
    var view = new DataView(bin);
    view.setUint16(0, size, true);
    view.setUint16(2, 0, true); // no value length
    view.setUint16(4, 1, true);
    var langAndCp = ((table.lang & 0xffff) * 0x10000 +
        (table.codepage & 0xffff))
        .toString(16)
        .toLowerCase();
    // fixed length
    if (langAndCp.length < 8) {
        var l = 8 - langAndCp.length;
        langAndCp = '00000000'.substr(0, l) + langAndCp;
    }
    var offset = roundUp(writeStringWithNullChar(view, 6, langAndCp), 4);
    keys.forEach(function (key) {
        var value = table.values[key];
        var childHeaderSize = roundUp(6 + 2 * (key.length + 1), 4);
        var newSize = roundUp(childHeaderSize + 2 * (value.length + 1), 4);
        if (offset + newSize <= 65532) {
            view.setUint16(offset, newSize, true);
            view.setUint16(offset + 2, value.length + 1, true); // value length is in character count
            view.setUint16(offset + 4, 1, true);
            offset = roundUp(writeStringWithNullChar(view, offset + 6, key), 4);
            offset = roundUp(writeStringWithNullChar(view, offset, value), 4);
        }
    });
    return bin;
}
function generateStringTableInfo(tables) {
    // estimate size
    var size = 36; // roundUp(6 + ByteLenWithNull(L'StringFileInfo'), 4)
    var tableBins = tables.map(function (table) { return generateStringTable(table); });
    // (all table sizes are rounded up)
    size += tableBins.reduce(function (p, c) { return p + c.byteLength; }, 0);
    var bin = new ArrayBuffer(size);
    var view = new DataView(bin);
    view.setUint16(0, size, true);
    view.setUint16(2, 0, true); // no value length
    view.setUint16(4, 1, true);
    var offset = roundUp(writeStringWithNullChar(view, 6, 'StringFileInfo'), 4);
    tableBins.forEach(function (table) {
        var len = table.byteLength;
        copyBuffer(bin, offset, table, 0, len);
        offset += len;
    });
    return bin;
}
function generateVarFileInfo(translations) {
    // estimate size
    var size = 32; // roundUp(6 + ByteLenWithNull(L'VarFileInfo'), 4)
    // (translation data is fixed length)
    var translationsValueSize = translations.length * 4;
    size += 32 + translationsValueSize;
    var bin = new ArrayBuffer(size);
    var view = new DataView(bin);
    view.setUint16(0, size, true);
    view.setUint16(2, 0, true); // no value length
    view.setUint16(4, 1, true);
    var offset = roundUp(writeStringWithNullChar(view, 6, 'VarFileInfo'), 4);
    view.setUint16(offset, 32 + translationsValueSize, true);
    view.setUint16(offset + 2, translationsValueSize, true);
    view.setUint16(offset + 4, 0, true);
    offset = roundUp(writeStringWithNullChar(view, offset + 6, 'Translation'), 4);
    translations.forEach(function (translation) {
        view.setUint16(offset, translation.lang, true);
        view.setUint16(offset + 2, translation.codepage, true);
        offset += 4;
    });
    return bin;
}
function generateVersionEntryBinary(entry) {
    var size = 92; // roundUp(6 + ByteLenWithNull(L'VS_VERSION_INFO'), 4) + 52 (sizeof VS_FIXEDFILEINFO)
    var stringTableInfoBin = generateStringTableInfo(entry.strings);
    var stringTableInfoLen = stringTableInfoBin.byteLength;
    size += stringTableInfoLen;
    var varFileInfoBin = generateVarFileInfo(entry.translations);
    var varFileInfoLen = varFileInfoBin.byteLength;
    size += varFileInfoLen;
    size = entry.unknowns.reduce(function (p, data) { return p + roundUp(data.entireBin.byteLength, 4); }, size);
    var bin = new ArrayBuffer(size);
    var view = new DataView(bin);
    view.setUint16(0, size, true);
    view.setUint16(2, 52, true);
    view.setUint16(4, 0, true); // value is binary
    var offset = roundUp(writeStringWithNullChar(view, 6, 'VS_VERSION_INFO'), 4);
    view.setUint32(offset, 0xfeef04bd, true); // signature
    view.setUint32(offset + 4, 0x10000, true); // structure version
    view.setUint32(offset + 8, entry.fixedInfo.fileVersionMS, true);
    view.setUint32(offset + 12, entry.fixedInfo.fileVersionLS, true);
    view.setUint32(offset + 16, entry.fixedInfo.productVersionMS, true);
    view.setUint32(offset + 20, entry.fixedInfo.productVersionLS, true);
    view.setUint32(offset + 24, entry.fixedInfo.fileFlagsMask, true);
    view.setUint32(offset + 28, entry.fixedInfo.fileFlags, true);
    view.setUint32(offset + 32, entry.fixedInfo.fileOS, true);
    view.setUint32(offset + 36, entry.fixedInfo.fileType, true);
    view.setUint32(offset + 40, entry.fixedInfo.fileSubtype, true);
    view.setUint32(offset + 44, entry.fixedInfo.fileDateMS, true);
    view.setUint32(offset + 48, entry.fixedInfo.fileDateLS, true);
    offset += 52;
    copyBuffer(bin, offset, stringTableInfoBin, 0, stringTableInfoLen);
    offset += stringTableInfoLen;
    copyBuffer(bin, offset, varFileInfoBin, 0, varFileInfoLen);
    offset += varFileInfoLen;
    entry.unknowns.forEach(function (e) {
        var len = e.entireBin.byteLength;
        copyBuffer(bin, offset, e.entireBin, 0, len);
        offset += roundUp(len, 4);
    });
    return bin;
}
////////////////////////////////////////////////////////////////////////////////
function clampInt(val, min, max) {
    if (isNaN(val) || val < min) {
        return min;
    }
    else if (val >= max) {
        return max;
    }
    return Math.floor(val);
}
function parseVersionArguments(arg1, arg2, arg3, arg4, arg5) {
    var _a;
    var major;
    var minor;
    var micro;
    var revision;
    var lang;
    if (typeof arg1 === 'string' &&
        (typeof arg2 === 'undefined' || typeof arg2 === 'number') &&
        typeof arg3 === 'undefined') {
        _a = arg1
            .split('.')
            .map(function (token) { return clampInt(Number(token), 0, 65535); })
            // add zeros for missing fields
            .concat(0, 0, 0), major = _a[0], minor = _a[1], micro = _a[2], revision = _a[3];
        lang = arg2;
    }
    else {
        major = clampInt(Number(arg1), 0, 65535);
        minor = clampInt(Number(arg2), 0, 65535);
        micro = clampInt(typeof arg3 === 'undefined' ? 0 : Number(arg3), 0, 65535);
        revision = clampInt(typeof arg4 === 'undefined' ? 0 : Number(arg4), 0, 65535);
        lang = arg5;
    }
    return [major, minor, micro, revision, lang];
}
////////////////////////////////////////////////////////////////////////////////
/**
 * Treats 'Version information' (`VS_VERSIONINFO`) resource data.
 */
var VersionInfo = /** @class */ (function () {
    function VersionInfo(entry) {
        if (!entry) {
            this.data = {
                lang: 0,
                fixedInfo: createFixedInfo(),
                strings: [],
                translations: [],
                unknowns: [],
            };
        }
        else {
            var view = new DataView(entry.bin);
            this.data = parseVersionEntry(view, entry);
        }
    }
    /** Returns new `VersionInfo` instance with empty data. */
    VersionInfo.createEmpty = function () {
        return new VersionInfo();
    };
    VersionInfo.create = function (arg1, fixedInfo, strings) {
        var lang;
        if (typeof arg1 === 'object') {
            lang = arg1.lang;
            fixedInfo = arg1.fixedInfo;
            strings = arg1.strings;
        }
        else {
            lang = arg1;
        }
        var vi = new VersionInfo();
        vi.data.lang = lang;
        // copy all specified values
        // (if unspecified, use default value set by `createFixedInfo`)
        for (var fixedInfoKey in fixedInfo) {
            if (fixedInfoKey in fixedInfo) {
                vi.data.fixedInfo[fixedInfoKey] = fixedInfo[fixedInfoKey];
            }
        }
        vi.data.strings = strings.map(function (_a) {
            var lang = _a.lang, codepage = _a.codepage, values = _a.values;
            return ({
                lang: lang,
                codepage: codepage,
                values: cloneObject(values),
            });
        });
        vi.data.translations = strings.map(function (_a) {
            var lang = _a.lang, codepage = _a.codepage;
            return ({ lang: lang, codepage: codepage });
        });
        return vi;
    };
    /** Pick up all version-info entries */
    VersionInfo.fromEntries = function (entries) {
        return entries
            .filter(function (e) { return e.type === 16; })
            .map(function (e) { return new VersionInfo(e); });
    };
    Object.defineProperty(VersionInfo.prototype, "lang", {
        /** A language value for this resource entry. */
        get: function () {
            return this.data.lang;
        },
        set: function (value) {
            this.data.lang = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VersionInfo.prototype, "fixedInfo", {
        /**
         * The property of fixed version info, containing file version, product version, etc.
         * (data: `VS_FIXEDFILEINFO`)
         *
         * Although this property is read-only, you can rewrite
         * each child fields directly to apply data.
         */
        get: function () {
            return this.data.fixedInfo;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns all languages that the executable supports. (data: `VarFileInfo`)
     *
     * Usually the returned array is equal to the one returned by `getAllLanguagesForStringValues`,
     * but some resource-generating tools doesn't generate same values.
     */
    VersionInfo.prototype.getAvailableLanguages = function () {
        return this.data.translations.slice(0);
    };
    /**
     * Replaces all languages that the executable supports.
     */
    VersionInfo.prototype.replaceAvailableLanguages = function (languages) {
        this.data.translations = languages.slice(0);
    };
    /**
     * Returns all string values for the specified language. (data: values in lang-charset block of `StringFileInfo`)
     */
    VersionInfo.prototype.getStringValues = function (language) {
        var a = this.data.strings
            .filter(function (e) {
            return e.lang === language.lang && e.codepage === language.codepage;
        })
            .map(function (e) { return e.values; });
        return a.length > 0 ? a[0] : {};
    };
    /**
     * Returns all languages used by string values. (data: lang-charset name of `StringFileInfo`)
     *
     * Usually the returned array is equal to the one returned by `getAvailableLanguages`,
     * but some resource-generating tools doesn't generate same values.
     */
    VersionInfo.prototype.getAllLanguagesForStringValues = function () {
        return this.data.strings.map(function (_a) {
            var codepage = _a.codepage, lang = _a.lang;
            return ({ codepage: codepage, lang: lang });
        });
    };
    /**
     * Add or replace the string values.
     * @param language language info
     * @param values string values (key-value pairs)
     * @param addToAvailableLanguage set `true` to add `language` into available languages
     *     if not existing in `getAvailableLanguages()` (default: `true`)
     */
    VersionInfo.prototype.setStringValues = function (language, values, addToAvailableLanguage) {
        if (addToAvailableLanguage === void 0) { addToAvailableLanguage = true; }
        var a = this.data.strings.filter(function (e) { return e.lang === language.lang && e.codepage === language.codepage; });
        var table;
        if (a.length === 0) {
            table = {
                lang: language.lang,
                codepage: language.codepage,
                values: {},
            };
            this.data.strings.push(table);
        }
        else {
            table = a[0];
        }
        for (var key in values) {
            table.values[key] = values[key];
        }
        if (addToAvailableLanguage) {
            // if no translation is available, then add it
            var t = this.data.translations.filter(function (e) {
                return e.lang === language.lang && e.codepage === language.codepage;
            });
            if (t.length === 0) {
                this.data.translations.push({
                    lang: language.lang,
                    codepage: language.codepage,
                });
            }
        }
    };
    /**
     * Add or replace the string value.
     * @param language language info
     * @param key the key name of string value
     * @param value the string value
     * @param addToAvailableLanguage set `true` to add `language` into available languages
     *     if not existing in `getAvailableLanguages()` (default: `true`)
     */
    VersionInfo.prototype.setStringValue = function (language, key, value, addToAvailableLanguage) {
        var _a;
        if (addToAvailableLanguage === void 0) { addToAvailableLanguage = true; }
        this.setStringValues(language, (_a = {}, _a[key] = value, _a), addToAvailableLanguage);
    };
    /**
     * Remove all string values for specified language.
     * @param language language info
     * @param removeFromAvailableLanguage set `true` to remove `language` from available languages
     *     if existing in `getAvailableLanguages()` (default: `true`)
     */
    VersionInfo.prototype.removeAllStringValues = function (language, removeFromAvailableLanguage) {
        if (removeFromAvailableLanguage === void 0) { removeFromAvailableLanguage = true; }
        var strings = this.data.strings;
        var len = strings.length;
        for (var i = 0; i < len; ++i) {
            var e = strings[i];
            if (e.lang === language.lang && e.codepage === language.codepage) {
                strings.splice(i, 1);
                if (removeFromAvailableLanguage) {
                    var translations = this.data.translations;
                    for (var j = 0; j < translations.length; j++) {
                        var t = translations[j];
                        if (t.lang === language.lang &&
                            t.codepage === language.codepage) {
                            translations.splice(j, 1);
                            break;
                        }
                    }
                }
                break;
            }
        }
    };
    /**
     * Remove specified string value for specified language.
     * @param language language info
     * @param key the key name of string value to be removed
     * @param removeFromAvailableLanguage set `true` to remove `language` from available languages
     *     if no more string values exist for `language` (default: `true`)
     */
    VersionInfo.prototype.removeStringValue = function (language, key, removeFromAvailableLanguage) {
        if (removeFromAvailableLanguage === void 0) { removeFromAvailableLanguage = true; }
        var strings = this.data.strings;
        var len = strings.length;
        for (var i = 0; i < len; ++i) {
            var e = strings[i];
            if (e.lang === language.lang && e.codepage === language.codepage) {
                try {
                    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                    delete e.values[key];
                }
                catch (_ex) { }
                if (removeFromAvailableLanguage &&
                    Object.keys(e.values).length === 0) {
                    // if no entries are left, remove table and translations
                    strings.splice(i, 1);
                    var translations = this.data.translations;
                    for (var j = 0; j < translations.length; j++) {
                        var t = translations[j];
                        if (t.lang === language.lang &&
                            t.codepage === language.codepage) {
                            translations.splice(j, 1);
                            break;
                        }
                    }
                }
                break;
            }
        }
    };
    /**
     * Creates `Type.ResourceEntry` object for this instance.
     * Usually `outputToResourceEntries` is suitable for generating resource data
     * into executables, but you can use this method if necessary.
     */
    VersionInfo.prototype.generateResource = function () {
        var bin = generateVersionEntryBinary(this.data);
        return {
            type: 16,
            id: 1,
            lang: this.lang,
            codepage: 1200,
            bin: bin,
        };
    };
    /**
     * Generates version info resource data (using `generateResource()`) and emits into `entries` array.
     * If version info resource already exists in `entries`, this method replaces it with the new one.
     * @param entries resource entry array for output
     */
    VersionInfo.prototype.outputToResourceEntries = function (entries) {
        var res = this.generateResource();
        var len = entries.length;
        for (var i = 0; i < len; ++i) {
            var e = entries[i];
            if (e.type === 16 && e.id === res.id && e.lang === res.lang) {
                entries[i] = res;
                return;
            }
        }
        entries.push(res);
    };
    // utility methods
    VersionInfo.prototype.getDefaultVersionLang = function (propName) {
        // first, use `this.lang` if it is a numeric value
        var num = Number(this.lang);
        if (this.lang !== '' && !isNaN(num)) {
            return num;
        }
        // second, use lang value for propName if there is only one language
        var a = this.data.strings
            .filter(function (e) { return propName in e.values; })
            .map(function (e) { return e.lang; });
        if (a.length === 1) {
            return a[0];
        }
        // use English language
        return 1033;
    };
    VersionInfo.prototype.setFileVersion = function (arg1, arg2, arg3, arg4, arg5) {
        this.setFileVersionImpl.apply(this, parseVersionArguments(arg1, arg2, arg3, arg4, arg5));
    };
    VersionInfo.prototype.setFileVersionImpl = function (major, minor, micro, revision, lang) {
        lang =
            typeof lang !== 'undefined'
                ? lang
                : this.getDefaultVersionLang('FileVersion');
        this.fixedInfo.fileVersionMS = (major << 16) | minor;
        this.fixedInfo.fileVersionLS = (micro << 16) | revision;
        this.setStringValue({ lang: lang, codepage: 1200 }, 'FileVersion', "".concat(major, ".").concat(minor, ".").concat(micro, ".").concat(revision), true);
    };
    VersionInfo.prototype.setProductVersion = function (arg1, arg2, arg3, arg4, arg5) {
        this.setProductVersionImpl.apply(this, parseVersionArguments(arg1, arg2, arg3, arg4, arg5));
    };
    VersionInfo.prototype.setProductVersionImpl = function (major, minor, micro, revision, lang) {
        lang =
            typeof lang !== 'undefined'
                ? lang
                : this.getDefaultVersionLang('ProductVersion');
        this.fixedInfo.productVersionMS = (major << 16) | minor;
        this.fixedInfo.productVersionLS = (micro << 16) | revision;
        this.setStringValue({ lang: lang, codepage: 1200 }, 'ProductVersion', "".concat(major, ".").concat(minor, ".").concat(micro, ".").concat(revision), true);
    };
    return VersionInfo;
}());

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    IconGroupEntry: IconGroupEntry,
    StringTable: StringTable,
    get VersionFileDriverSubtype () { return VersionFileDriverSubtype; },
    VersionFileFlags: VersionFileFlags$1,
    get VersionFileFontSubtype () { return VersionFileFontSubtype; },
    VersionFileOS: VersionFileOS$1,
    VersionFileType: VersionFileType$1,
    VersionInfo: VersionInfo
});

var RawDERObject = /** @class */ (function () {
    function RawDERObject(data) {
        this.data = data;
    }
    RawDERObject.prototype.toDER = function () {
        return [].slice.call(this.data);
    };
    return RawDERObject;
}());

function makeDERLength(length) {
    if (length < 0x80) {
        return [length];
    }
    var r = [];
    while (true) {
        r.push(length & 0xff);
        if (length < 0x100) {
            break;
        }
        length >>= 8;
    }
    r.push(0x80 + r.length);
    return r.reverse();
}
function makeDERIA5String(text) {
    // convert to char-code array and filter to [0-127]
    var r = [].map
        .call(text, function (c) { return c.charCodeAt(0); })
        .filter(function (n) { return n < 128; });
    return [0x16].concat(makeDERLength(r.length)).concat(r);
}
function makeDERBMPString(text) {
    // convert to char-code array
    // NOTE: In ECMAScript `charCodeAt` returns surrogate pair for >=0x10000 codes,
    //   and surrogate pair is valid for BMPString data
    var r = [].map.call(text, function (c) { return c.charCodeAt(0); });
    var ua = new Uint8Array(r.length * 2);
    var dv = new DataView(ua.buffer);
    // store codes as big-endian
    r.forEach(function (v, i) {
        dv.setUint16(i * 2, v, false);
    });
    return [0x1e].concat(makeDERLength(ua.length)).concat(
    // convert Uint8Array to number[] (not using spread operator)
    [].slice.call(ua));
}
function makeDEROctetString(bin) {
    if (!(bin instanceof Array)) {
        // convert Uint8Array to number[] (not using spread operator)
        bin = [].slice.call(bin);
    }
    return [0x04].concat(makeDERLength(bin.length)).concat(bin);
}
function makeDERTaggedData(tag, body) {
    return [0xa0 + tag].concat(makeDERLength(body.length)).concat(body);
}
function makeDERSequence(body) {
    return [0x30].concat(makeDERLength(body.length)).concat(body);
}
function arrayToDERSet(items) {
    var r = items.reduce(function (prev, item) {
        return prev.concat(item instanceof Array ? item : item.toDER());
    }, []);
    return [0x31].concat(makeDERLength(r.length)).concat(r);
}

var ObjectIdentifier = /** @class */ (function () {
    function ObjectIdentifier(value) {
        if (typeof value === 'string') {
            this.value = value.split(/\./g).map(function (s) { return Number(s); });
        }
        else {
            this.value = value;
        }
    }
    ObjectIdentifier.prototype.toDER = function () {
        var id = this.value;
        var r = [];
        // first byte will be (x * 40 + y) for 'x.y.****'
        r.push(id[0] * 40 + id[1]);
        for (var i = 2; i < id.length; ++i) {
            // store as variable-length value
            var val = id[i];
            var isFirst = true;
            var insertPos = r.length;
            while (true) {
                var v = val & 0x7f;
                if (!isFirst) {
                    v += 0x80;
                }
                r.splice(insertPos, 0, v);
                if (val < 0x80) {
                    break;
                }
                isFirst = false;
                val = Math.floor(val / 0x80);
            }
        }
        return [0x06].concat(makeDERLength(r.length)).concat(r);
    };
    return ObjectIdentifier;
}());

// 1.3.14.3.2.26
// prettier-ignore
var OID_SHA1_NO_SIGN = new ObjectIdentifier([1, 3, 14, 3, 2, 26]);
// 2.16.840.1.101.3.4.2.1
// prettier-ignore
var OID_SHA256_NO_SIGN = new ObjectIdentifier([2, 16, 840, 1, 101, 3, 4, 2, 1]);
// 2.16.840.1.101.3.4.2.2
// prettier-ignore
var OID_SHA384_NO_SIGN = new ObjectIdentifier([2, 16, 840, 1, 101, 3, 4, 2, 2]);
// 2.16.840.1.101.3.4.2.3
// prettier-ignore
var OID_SHA512_NO_SIGN = new ObjectIdentifier([2, 16, 840, 1, 101, 3, 4, 2, 3]);
// 2.16.840.1.101.3.4.2.4
// prettier-ignore
var OID_SHA224_NO_SIGN = new ObjectIdentifier([2, 16, 840, 1, 101, 3, 4, 2, 4]);
// 2.16.840.1.101.3.4.2.5
// prettier-ignore
var OID_SHA512_224_NO_SIGN = new ObjectIdentifier([2, 16, 840, 1, 101, 3, 4, 2, 5]);
// 2.16.840.1.101.3.4.2.6
// prettier-ignore
var OID_SHA512_256_NO_SIGN = new ObjectIdentifier([2, 16, 840, 1, 101, 3, 4, 2, 6]);
// 2.16.840.1.101.3.4.2.7
// prettier-ignore
var OID_SHA3_224_NO_SIGN = new ObjectIdentifier([2, 16, 840, 1, 101, 3, 4, 2, 7]);
// 2.16.840.1.101.3.4.2.8
// prettier-ignore
var OID_SHA3_256_NO_SIGN = new ObjectIdentifier([2, 16, 840, 1, 101, 3, 4, 2, 8]);
// 2.16.840.1.101.3.4.2.9
// prettier-ignore
var OID_SHA3_384_NO_SIGN = new ObjectIdentifier([2, 16, 840, 1, 101, 3, 4, 2, 9]);
// 2.16.840.1.101.3.4.2.10
// prettier-ignore
var OID_SHA3_512_NO_SIGN = new ObjectIdentifier([2, 16, 840, 1, 101, 3, 4, 2, 10]);
// 2.16.840.1.101.3.4.2.11
// prettier-ignore
var OID_SHAKE128_NO_SIGN = new ObjectIdentifier([2, 16, 840, 1, 101, 3, 4, 2, 11]);
// 2.16.840.1.101.3.4.2.12
// prettier-ignore
var OID_SHAKE256_NO_SIGN = new ObjectIdentifier([2, 16, 840, 1, 101, 3, 4, 2, 12]);
// 1.2.840.113549.1.1.1
// prettier-ignore
var OID_RSA = new ObjectIdentifier([1, 2, 840, 113549, 1, 1, 1]);
// 1.2.840.10040.4.1
// prettier-ignore
var OID_DSA = new ObjectIdentifier([1, 2, 840, 10040, 4, 1]);
// 1.2.840.113549.1.7.2
// prettier-ignore
var OID_SIGNED_DATA = new ObjectIdentifier([1, 2, 840, 113549, 1, 7, 2]);
// 1.2.840.113549.1.9.3
// prettier-ignore
var OID_CONTENT_TYPE = new ObjectIdentifier([1, 2, 840, 113549, 1, 9, 3]);
// 1.2.840.113549.1.9.4
// prettier-ignore
var OID_MESSAGE_DIGEST = new ObjectIdentifier([1, 2, 840, 113549, 1, 9, 4]);
// 1.3.6.1.4.1.311.2.1.11
// prettier-ignore
var OID_SPC_STATEMENT_TYPE_OBJID = new ObjectIdentifier([1, 3, 6, 1, 4, 1, 311, 2, 1, 11]);
// 1.3.6.1.4.1.311.2.1.12
// prettier-ignore
var OID_SPC_SP_OPUS_INFO_OBJID = new ObjectIdentifier([1, 3, 6, 1, 4, 1, 311, 2, 1, 12]);
// 1.3.6.1.4.1.311.2.1.21
// prettier-ignore
var OID_SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID = new ObjectIdentifier([1, 3, 6, 1, 4, 1, 311, 2, 1, 21]);
// 1.3.6.1.4.1.311.3.3.1
// prettier-ignore
var OID_RFC3161_COUNTER_SIGNATURE = new ObjectIdentifier([1, 3, 6, 1, 4, 1, 311, 3, 3, 1]);

function toUint8Array(bin) {
    if ('buffer' in bin) {
        return new Uint8Array(bin.buffer, bin.byteOffset, bin.byteLength);
    }
    else {
        return new Uint8Array(bin);
    }
}
/** @return [length, afterOffset] */
function calculateDERLength(data, offset) {
    var actualLength = 0;
    if (data[offset] < 0x80) {
        actualLength = data[offset];
        ++offset;
    }
    else if (data[offset] === 0x80) {
        throw new Error('Not supported certificate data (variable length)');
    }
    else {
        var c = data[offset] & 0x7f;
        ++offset;
        while (c--) {
            if (offset >= data.length) {
                throw new Error('Invalid certificate data (invalid sequence length)');
            }
            actualLength <<= 8;
            actualLength |= data[offset];
            ++offset;
        }
    }
    return [actualLength, offset];
}
function skipField(data, offsetOfDataHead) {
    var _a = calculateDERLength(data, offsetOfDataHead + 1), len = _a[0], off = _a[1];
    return off + len;
}
function pickCertificatesIfDERHasSignedData(ub, offset) {
    var _a, _b, _c, _d, _e;
    if (ub.length < offset + 2) {
        return null;
    }
    if (ub[offset] !== 0x30) {
        return null;
    }
    var tempLength;
    _a = calculateDERLength(ub, offset + 1), tempLength = _a[0], offset = _a[1];
    if (tempLength > ub.length - offset) {
        throw new Error('Invalid certificate data (insufficient data length)');
    }
    // if the first item is not contentType, then return
    if (ub[offset] !== 0x6) {
        return null;
    }
    var signedDataOid = OID_SIGNED_DATA.toDER();
    for (var i = 0; i < signedDataOid.length; ++i) {
        if (ub[offset + i] !== signedDataOid[i]) {
            return null;
        }
    }
    // if contentType is OID_SIGNED_DATA, then check sequence format
    // ContentInfo.content
    offset += signedDataOid.length;
    // [0] IMPLICIT
    if (ub[offset] !== 0xa0) {
        throw new Error('Invalid certificate data (no content in contentInfo)');
    }
    _b = calculateDERLength(ub, offset + 1), tempLength = _b[0], offset = _b[1];
    if (offset + tempLength > ub.length) {
        throw new Error('Invalid certificate data (invalid length for content)');
    }
    // sequence
    if (ub[offset] !== 0x30) {
        throw new Error('Invalid certificate data (unexpected signedData)');
    }
    _c = calculateDERLength(ub, offset + 1), tempLength = _c[0], offset = _c[1];
    if (offset + tempLength > ub.length) {
        throw new Error('Invalid certificate data (invalid length for signedData)');
    }
    // version
    if (ub[offset] !== 0x2 ||
        ub[offset + 1] !== 0x1 ||
        ub[offset + 2] !== 0x1) {
        throw new Error('Invalid certificate data (unexpected signedData.version)');
    }
    offset += 3;
    // digestAlgorithms (skip)
    if (ub[offset] !== 0x31) {
        throw new Error('Invalid certificate data (no signedData.digestAlgorithms)');
    }
    _d = calculateDERLength(ub, offset + 1), tempLength = _d[0], offset = _d[1];
    if (offset + tempLength > ub.length) {
        throw new Error('Invalid certificate data (invalid length for signedData.digestAlgorithms)');
    }
    offset += tempLength;
    // contentInfo (skip)
    if (ub[offset] !== 0x30) {
        throw new Error('Invalid certificate data (no signedData.contentInfo)');
    }
    _e = calculateDERLength(ub, offset + 1), tempLength = _e[0], offset = _e[1];
    if (offset + tempLength > ub.length) {
        throw new Error('Invalid certificate data (invalid length for signedData.contentInfo)');
    }
    offset += tempLength;
    // certificates
    if (ub[offset] !== 0xa0) {
        throw new Error('Invalid certificate data (no signedData.certificates)');
    }
    var _f = calculateDERLength(ub, offset + 1), certsLength = _f[0], newOffset = _f[1];
    if (newOffset + certsLength > ub.length) {
        throw new Error('Invalid certificate data (invalid length for signedData.certificates)');
    }
    return ub.subarray(offset, newOffset + certsLength);
}
/** @return [issuer, serialNumber] */
function pickIssuerAndSerialNumberDERFromCert(bin) {
    var _a, _b;
    if (Array.isArray(bin)) {
        // use first one and call again
        if (bin.length === 0) {
            throw new Error('No data is specified.');
        }
        return pickIssuerAndSerialNumberDERFromCert(bin[0]);
    }
    var ub = toUint8Array(bin);
    if (ub.length < 2) {
        throw new Error('Invalid certificate data');
    }
    if (ub[0] !== 0x30) {
        throw new Error('Not supported certificate data (non-`Certificate`-format data)');
    }
    var certsBin = pickCertificatesIfDERHasSignedData(ub, 0);
    if (certsBin) {
        // certificates
        var _c = calculateDERLength(certsBin, 1), tempLength_1 = _c[0], eaten_1 = _c[1];
        if (eaten_1 + tempLength_1 > certsBin.length) {
            throw new Error('Invalid certificate data (invalid length for signedData.certificates)');
        }
        // pick first certificate and call again
        if (certsBin[eaten_1] !== 0x30) {
            throw new Error('Invalid certificate data (no signedData.certificates[0])');
        }
        var _d = calculateDERLength(certsBin, eaten_1 + 1), certLength = _d[0], tempOffset = _d[1];
        if (tempOffset + certLength > certsBin.length) {
            throw new Error('Invalid certificate data (invalid length for signedData.certificates[0])');
        }
        return pickIssuerAndSerialNumberDERFromCert(certsBin.subarray(eaten_1, tempOffset + certLength));
    }
    var tempLength;
    var eaten;
    _a = calculateDERLength(ub, 1), tempLength = _a[0], eaten = _a[1];
    if (tempLength > ub.length - eaten) {
        throw new Error('Invalid certificate data (insufficient data length)');
    }
    if (ub[eaten] !== 0x30) {
        throw new Error('Invalid certificate data (missing tbsCertificate)');
    }
    // Certificate
    var tbsCertificateLen;
    _b = calculateDERLength(ub, eaten + 1), tbsCertificateLen = _b[0], eaten = _b[1];
    if (tbsCertificateLen > ub.length - eaten) {
        throw new Error('Invalid certificate data (invalid tbsCertificate length)');
    }
    var tbsOffsetLast = eaten + tbsCertificateLen;
    // TBSCertificate
    // :skip version
    if (ub[eaten] === 0xa0) {
        eaten = skipField(ub, eaten);
        if (eaten >= tbsOffsetLast) {
            throw new Error('Invalid certificate data (insufficient tbsCertificate data: after version)');
        }
    }
    // pick serialNumber
    if (ub[eaten] !== 2) {
        throw new Error('Invalid certificate data (invalid serialNumber)');
    }
    var offsetAfterSerialNumber = skipField(ub, eaten);
    if (eaten >= tbsOffsetLast) {
        throw new Error('Invalid certificate data (insufficient tbsCertificate data: after serialNumber)');
    }
    var serialNumberDER = [].slice.call(ub, eaten, offsetAfterSerialNumber);
    eaten = offsetAfterSerialNumber;
    // :skip algorithmIdentifier
    if (ub[eaten] !== 0x30) {
        throw new Error('Invalid certificate data (invalid algorithmIdentifier)');
    }
    eaten = skipField(ub, eaten);
    if (eaten >= tbsOffsetLast) {
        throw new Error('Invalid certificate data (insufficient tbsCertificate data: after serialNumber)');
    }
    // pick issuer
    // Name ::= CHOICE { RDNSequence }
    // RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
    if (ub[eaten] !== 0x30) {
        throw new Error('Invalid certificate data (invalid issuer)');
    }
    var offsetAfterIssuer = skipField(ub, eaten);
    if (offsetAfterIssuer > tbsOffsetLast) {
        throw new Error('Invalid certificate data (insufficient tbsCertificate data: issuer)');
    }
    return [
        // return entire issuer sequence
        [].slice.call(ub, eaten, offsetAfterIssuer),
        serialNumberDER,
    ];
}
function certBinToCertificatesDER(bin) {
    if (Array.isArray(bin)) {
        // use all items, map with `certBinToCertificatesDER`, and concat all
        return bin
            .map(certBinToCertificatesDER)
            .reduce(function (prev, cur) { return prev.concat(cur); }, []);
    }
    var ub = toUint8Array(bin);
    var certsBin = pickCertificatesIfDERHasSignedData(ub, 0);
    if (certsBin) {
        // certificates
        var _a = calculateDERLength(certsBin, 1), tempLength = _a[0], eaten = _a[1];
        if (eaten + tempLength > certsBin.length) {
            throw new Error('Invalid certificate data (invalid length for signedData.certificates)');
        }
        var offsetLast = eaten + tempLength;
        var rawData = [];
        for (var offset = eaten; offset < offsetLast;) {
            // pick certificates
            if (certsBin[offset] !== 0x30) {
                throw new Error('Invalid certificate data (no signedData.certificates[*])');
            }
            var _b = calculateDERLength(certsBin, offset + 1), certLength = _b[0], tempOffset = _b[1];
            if (tempOffset + certLength > certsBin.length) {
                throw new Error('Invalid certificate data (invalid length for signedData.certificates[*])');
            }
            rawData.push(new RawDERObject(certsBin.subarray(offset, tempOffset + certLength)));
            offset = tempOffset + certLength;
        }
        return rawData;
    }
    else {
        return [new RawDERObject(ub)];
    }
}

var AlgorithmIdentifier = /** @class */ (function () {
    function AlgorithmIdentifier(algorithm) {
        this.algorithm = algorithm;
    }
    AlgorithmIdentifier.prototype.toDER = function () {
        var r = this.algorithm.toDER();
        return makeDERSequence(r.concat(
        // parameters is not used now
        [0x05, 0x00]));
    };
    return AlgorithmIdentifier;
}());

// abstract
var ContentInfo = /** @class */ (function () {
    function ContentInfo(contentType, content) {
        this.contentType = contentType;
        this.content = content;
    }
    ContentInfo.prototype.toDER = function () {
        return makeDERSequence(this.contentType
            .toDER()
            .concat(makeDERTaggedData(0, this.content.toDER())));
    };
    return ContentInfo;
}());

var __extends$3 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var CertificateDataRoot = /** @class */ (function (_super) {
    __extends$3(CertificateDataRoot, _super);
    function CertificateDataRoot() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CertificateDataRoot;
}(ContentInfo));

var DigestInfo = /** @class */ (function () {
    function DigestInfo(digestAlgorithm, digest) {
        this.digestAlgorithm = digestAlgorithm;
        this.digest = digest;
    }
    DigestInfo.prototype.toDER = function () {
        var digest = this.digest;
        var digestArray;
        if ('buffer' in digest) {
            digestArray = new Uint8Array(digest.buffer, digest.byteOffset, digest.byteLength);
        }
        else {
            digestArray = new Uint8Array(digest);
        }
        var derData = this.digestAlgorithm
            .toDER()
            .concat(makeDEROctetString(digestArray));
        return makeDERSequence(derData);
    };
    return DigestInfo;
}());

var IssuerAndSerialNumber = /** @class */ (function () {
    function IssuerAndSerialNumber(issuer, serialNumber) {
        this.issuer = issuer;
        this.serialNumber = serialNumber;
    }
    IssuerAndSerialNumber.prototype.toDER = function () {
        return makeDERSequence(this.issuer.toDER().concat(this.serialNumber.toDER()));
    };
    return IssuerAndSerialNumber;
}());

var SignedData = /** @class */ (function () {
    function SignedData(version, digestAlgorithms, contentInfo, signerInfos, certificates, crls) {
        this.version = version;
        this.digestAlgorithms = digestAlgorithms;
        this.contentInfo = contentInfo;
        this.signerInfos = signerInfos;
        this.certificates = certificates;
        this.crls = crls;
    }
    SignedData.prototype.toDER = function () {
        var r = [0x02, 0x01, this.version & 0xff]
            .concat(arrayToDERSet(this.digestAlgorithms))
            .concat(this.contentInfo.toDER());
        if (this.certificates && this.certificates.length > 0) {
            var allCertsDER = arrayToDERSet(this.certificates);
            // IMPLICIT SET
            allCertsDER[0] = 0xa0;
            r = r.concat(allCertsDER);
        }
        if (this.crls) {
            r = r.concat(makeDERTaggedData(1, arrayToDERSet(this.crls)));
        }
        r = r.concat(arrayToDERSet(this.signerInfos));
        return makeDERSequence(r);
    };
    return SignedData;
}());

var SignerInfo = /** @class */ (function () {
    function SignerInfo(version, issuerAndSerialNumber, digestAlgorithm, digestEncryptionAlgorithm, encryptedDigest, authenticatedAttributes, unauthenticatedAttributes) {
        this.version = version;
        this.issuerAndSerialNumber = issuerAndSerialNumber;
        this.digestAlgorithm = digestAlgorithm;
        this.digestEncryptionAlgorithm = digestEncryptionAlgorithm;
        this.encryptedDigest = encryptedDigest;
        this.authenticatedAttributes = authenticatedAttributes;
        this.unauthenticatedAttributes = unauthenticatedAttributes;
    }
    SignerInfo.prototype.toDER = function () {
        var r = [0x02, 0x01, this.version & 0xff]
            .concat(this.issuerAndSerialNumber.toDER())
            .concat(this.digestAlgorithm.toDER());
        if (this.authenticatedAttributes &&
            this.authenticatedAttributes.length > 0) {
            var a = arrayToDERSet(this.authenticatedAttributes);
            // [0] IMPLICIT
            a[0] = 0xa0;
            r = r.concat(a);
        }
        r = r
            .concat(this.digestEncryptionAlgorithm.toDER())
            .concat(makeDEROctetString(this.encryptedDigest));
        if (this.unauthenticatedAttributes &&
            this.unauthenticatedAttributes.length > 0) {
            var u = arrayToDERSet(this.unauthenticatedAttributes);
            // [1] IMPLICIT
            u[0] = 0xa1;
            r = r.concat(u);
        }
        return makeDERSequence(r);
    };
    return SignerInfo;
}());

var __extends$2 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// prettier-ignore
var SPC_INDIRECT_DATA_OBJID = new ObjectIdentifier([1, 3, 6, 1, 4, 1, 311, 2, 1, 4]);
var SpcAttributeTypeAndOptionalValue = /** @class */ (function () {
    function SpcAttributeTypeAndOptionalValue(type, value) {
        this.type = type;
        this.value = value;
    }
    SpcAttributeTypeAndOptionalValue.prototype.toDER = function () {
        return makeDERSequence(this.type.toDER().concat(this.value.toDER()));
    };
    return SpcAttributeTypeAndOptionalValue;
}());
var SpcIndirectDataContent = /** @class */ (function () {
    function SpcIndirectDataContent(data, messageDigest) {
        this.data = data;
        this.messageDigest = messageDigest;
    }
    SpcIndirectDataContent.prototype.toDER = function () {
        return makeDERSequence(this.toDERWithoutHeader());
    };
    // this is used for calculating 'messageDigest'
    SpcIndirectDataContent.prototype.toDERWithoutHeader = function () {
        return this.data.toDER().concat(this.messageDigest.toDER());
    };
    return SpcIndirectDataContent;
}());
var SpcIndirectDataContentInfo = /** @class */ (function (_super) {
    __extends$2(SpcIndirectDataContentInfo, _super);
    function SpcIndirectDataContentInfo(content) {
        return _super.call(this, SPC_INDIRECT_DATA_OBJID, content) || this;
    }
    return SpcIndirectDataContentInfo;
}(ContentInfo));

var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// prettier-ignore
var SPC_PE_IMAGE_DATA_OBJID = new ObjectIdentifier([1, 3, 6, 1, 4, 1, 311, 2, 1, 15]);
var SpcPeImageData = /** @class */ (function () {
    function SpcPeImageData(flags, file) {
        this.flags = flags;
        this.file = file;
    }
    SpcPeImageData.prototype.toDER = function () {
        return makeDERSequence([0x03, 0x01, this.flags & 0xff].concat(
        // undocumented -- SpcLink must be tagged
        makeDERTaggedData(0, this.file.toDER())));
    };
    return SpcPeImageData;
}());
var SpcPeImageAttributeTypeAndOptionalValue = /** @class */ (function (_super) {
    __extends$1(SpcPeImageAttributeTypeAndOptionalValue, _super);
    function SpcPeImageAttributeTypeAndOptionalValue(value) {
        return _super.call(this, SPC_PE_IMAGE_DATA_OBJID, value) || this;
    }
    return SpcPeImageAttributeTypeAndOptionalValue;
}(SpcAttributeTypeAndOptionalValue));

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Abstract data SpcLink. Must use either `SpcLinkUrl` or `SpcLinkFile` instead.
 */
var SpcLink = /** @class */ (function () {
    function SpcLink(tag, value) {
        this.tag = tag;
        this.value = value;
    }
    SpcLink.prototype.toDER = function () {
        var v = this.value.toDER();
        if (this.tag === 2) {
            // EXPLICIT
            return makeDERTaggedData(this.tag, v);
        }
        else {
            // IMPLICIT
            v[0] = 0x80 + this.tag;
            return v;
        }
    };
    return SpcLink;
}());
/** @class */ ((function (_super) {
    __extends(SpcLinkUrl, _super);
    function SpcLinkUrl(url) {
        return _super.call(this, 0, new RawDERObject(makeDERIA5String(url))) || this;
    }
    return SpcLinkUrl;
})(SpcLink));
// moniker is not supported now (currently unused)
var SpcLinkFile = /** @class */ (function (_super) {
    __extends(SpcLinkFile, _super);
    function SpcLinkFile(file) {
        var v = makeDERBMPString(file);
        // [0] IMPLICIT BMPSTRING
        v[0] = 0x80;
        return _super.call(this, 2, new RawDERObject(v)) || this;
    }
    return SpcLinkFile;
}(SpcLink));

var Attribute = /** @class */ (function () {
    function Attribute(attrType, attrValues) {
        this.attrType = attrType;
        this.attrValues = attrValues;
    }
    Attribute.prototype.toDER = function () {
        return makeDERSequence(this.attrType.toDER().concat(arrayToDERSet(this.attrValues)));
    };
    return Attribute;
}());

function createTimestampRequest(data, algorithmIdentifier) {
    return new Uint8Array(makeDERSequence(
    // version
    [0x2, 0x1, 0x1]
        // messageImprint
        .concat(makeDERSequence(algorithmIdentifier
        .toDER()
        .concat(makeDEROctetString(toUint8Array(data)))))
        // certReq
        .concat([0x01, 0x01, 0xff]))).buffer;
}
function pickSignedDataFromTimestampResponse(data) {
    var _a, _b, _c, _d, _e, _f;
    var ub = toUint8Array(data);
    if (ub.length < 2 || ub[0] !== 0x30) {
        throw new Error('Invalid or unexpected timestamp response');
    }
    var len;
    var offset;
    _a = calculateDERLength(ub, 1), len = _a[0], offset = _a[1];
    if (len > ub.length - offset) {
        throw new Error('Invalid or unexpected timestamp response (insufficient buffer)');
    }
    var dataLast = offset + len;
    // status PKIStatusInfo
    if (ub[offset] !== 0x30) {
        throw new Error('Invalid or unexpected timestamp response (no PKIStatusInfo)');
    }
    _b = calculateDERLength(ub, offset + 1), len = _b[0], offset = _b[1];
    if (offset >= dataLast) {
        throw new Error('Invalid or unexpected timestamp response (invalid length for PKIStatusInfo)');
    }
    var timeStampTokenOffset = offset + len;
    // PKIStatusInfo.status
    if (ub[offset] !== 0x2 || ub[offset + 1] !== 0x1) {
        throw new Error('Invalid or unexpected timestamp response (invalid PKIStatusInfo.status)');
    }
    switch (ub[offset + 2]) {
        case 0: // granted
        case 1: // grantedWithMods
            break;
        case 2: // rejection
        case 3: // waiting
        case 4: // revocationWarning
        case 5: /* revocationNotification */ {
            var msg = "Timestamp response has error status ".concat(ub[offset + 2]);
            // PKIStatusInfo.statusString
            if (offset + 3 < timeStampTokenOffset && ub[offset + 3] === 0x30) {
                _c = calculateDERLength(ub, offset + 4), len = _c[0], offset = _c[1];
                if (offset + len <= timeStampTokenOffset &&
                    ub[offset] === 0xc) {
                    _d = calculateDERLength(ub, offset + 1), len = _d[0], offset = _d[1];
                    if (offset + len <= timeStampTokenOffset) {
                        var statusString = 
                        // pick UTF8String body
                        [].slice
                            .call(ub, offset, offset + len)
                            // map 0x20<=x<=0x7e values to chars, and other values to '%xx' to be parsed by decodeURIComponent
                            .map(function (val) {
                            if (val >= 0x20 && val <= 0x7e) {
                                return String.fromCharCode(val);
                            }
                            else {
                                var s = val.toString(16);
                                if (s.length === 1) {
                                    s = '0' + s;
                                }
                                return '%' + s;
                            }
                        })
                            .join('');
                        msg += ', text = ' + decodeURIComponent(statusString);
                    }
                }
            }
            throw new Error(msg);
        }
        default:
            throw new Error("Unexpected PKIStatusInfo.status: ".concat(ub[offset + 2]));
    }
    // TimeStampToken ::= ContentInfo
    if (timeStampTokenOffset + 1 >= dataLast ||
        ub[timeStampTokenOffset] !== 0x30) {
        throw new Error('Invalid or unexpected timestamp response (no TimeStampToken)');
    }
    _e = calculateDERLength(ub, timeStampTokenOffset + 1), len = _e[0], offset = _e[1];
    if (offset + len > dataLast) {
        throw new Error('Invalid or unexpected timestamp response (insufficient data for TimeStampToken)');
    }
    // ContentInfo.contentType
    var signedDataOid = OID_SIGNED_DATA.toDER();
    if (ub[offset] !== 0x6) {
        throw new Error('Invalid or unexpected timestamp response (no contentType in TimeStampToken)');
    }
    for (var i = 0; i < signedDataOid.length; ++i) {
        if (ub[offset + i] !== signedDataOid[i]) {
            throw new Error('Invalid or unexpected timestamp response (unexpected TimeStampToken.contentType octet)');
        }
    }
    // ContentInfo.content
    offset += signedDataOid.length;
    // [0] IMPLICIT
    if (ub[offset] !== 0xa0) {
        throw new Error('Invalid or unexpected timestamp response (no content in TimeStampToken)');
    }
    _f = calculateDERLength(ub, offset + 1), len = _f[0], offset = _f[1];
    if (offset + len > dataLast) {
        throw new Error('Invalid or unexpected timestamp response (invalid length for TimeStampToken.content)');
    }
    // return content data (=== SignedData)
    return allocatePartialBinary(ub, offset, len);
}

// refs.
// - Windows Authenticode Portable Executable Signature Format
//   https://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/authenticode_pe.docx
// - RFC 2315 - PKCS #7: Cryptographic Message Syntax Version 1.5
//   https://tools.ietf.org/html/rfc2315
// - RFC 3280 - Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile
//   https://tools.ietf.org/html/rfc3280
// - Object IDs associated with Microsoft cryptography
//   https://support.microsoft.com/en-us/help/287547/object-ids-associated-with-microsoft-cryptography
// - OID repository
//   http://oid-info.com/
// - RFC 3161 - Internet X.509 Public Key Infrastructure Time-Stamp Protocol (TSP)
//   https://tools.ietf.org/html/rfc3161
// - mono/AuthenticodeDeformatter.cs
//   https://github.com/mono/mono/blob/master/mcs/class/Mono.Security/Mono.Security.Authenticode/AuthenticodeDeformatter.cs
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
function makeSimpleIterator(data) {
    var done = false;
    return {
        next: function () {
            if (done) {
                return {
                    done: true,
                    value: undefined,
                };
            }
            else {
                done = true;
                return {
                    done: false,
                    value: data,
                };
            }
        },
    };
}
function validateSignerObject(signer) {
    if (!signer.encryptData && !signer.signData) {
        throw new Error('Signer object must implement either `encryptData` or `signData`.');
    }
}
function calculateExecutableDigest(executable, signer, alignment) {
    function inner() {
        var checkSumOffset, certificateTableOffset, rawHeader, targetSections, sectionCount, sectionStartOffset, sectionEndOffset, sectionHeadersSize, secHeader, secArray_1, off, _i, targetSections_1, section, exData, alignedLength, diff;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    checkSumOffset = executable.dosHeader.newHeaderAddress + 88;
                    certificateTableOffset = executable.dosHeader.newHeaderAddress +
                        executable.newHeader.getDataDirectoryOffset() +
                        ImageDataDirectoryArray.itemSize *
                            ImageDirectoryEntry$1.Certificate;
                    rawHeader = executable.getRawHeader();
                    targetSections = executable.getAllSections();
                    sectionCount = targetSections.length;
                    sectionStartOffset = rawHeader.byteLength;
                    sectionEndOffset = roundUp(sectionStartOffset +
                        sectionCount * ImageSectionHeaderArray.itemSize, executable.getFileAlignment());
                    sectionHeadersSize = sectionEndOffset - sectionStartOffset;
                    secHeader = new ArrayBuffer(sectionHeadersSize);
                    {
                        secArray_1 = ImageSectionHeaderArray.from(secHeader, sectionCount);
                        targetSections.forEach(function (sec, i) {
                            secArray_1.set(i, sec.info);
                        });
                    }
                    // pick from head to immediately before checksum
                    return [4 /*yield*/, allocatePartialBinary(rawHeader, 0, checkSumOffset)];
                case 1:
                    // pick from head to immediately before checksum
                    _a.sent();
                    // pick from the end of checksum to immediately before 'Certificate Table' header
                    return [4 /*yield*/, allocatePartialBinary(rawHeader, checkSumOffset + 4, certificateTableOffset - (checkSumOffset + 4))];
                case 2:
                    // pick from the end of checksum to immediately before 'Certificate Table' header
                    _a.sent();
                    off = certificateTableOffset +
                        ImageDataDirectoryArray.itemSize;
                    return [4 /*yield*/, allocatePartialBinary(executable.getRawHeader(), off, executable.getTotalHeaderSize() - off)];
                case 3:
                    _a.sent();
                    // pick section header
                    return [4 /*yield*/, secHeader];
                case 4:
                    // pick section header
                    _a.sent();
                    _i = 0, targetSections_1 = targetSections;
                    _a.label = 5;
                case 5:
                    if (!(_i < targetSections_1.length)) return [3 /*break*/, 8];
                    section = targetSections_1[_i];
                    if (!section.data) return [3 /*break*/, 7];
                    return [4 /*yield*/, section.data];
                case 6:
                    _a.sent();
                    _a.label = 7;
                case 7:
                    _i++;
                    return [3 /*break*/, 5];
                case 8:
                    exData = executable.getExtraData();
                    if (!(exData !== null)) return [3 /*break*/, 11];
                    return [4 /*yield*/, exData];
                case 9:
                    _a.sent();
                    alignedLength = roundUp(exData.byteLength, alignment);
                    diff = alignedLength - exData.byteLength;
                    if (!(diff !== 0)) return [3 /*break*/, 11];
                    return [4 /*yield*/, new Uint8Array(diff).buffer];
                case 10:
                    _a.sent();
                    _a.label = 11;
                case 11: return [2 /*return*/];
            }
        });
    }
    return signer.digestData(inner());
}
function getAlgorithmIdentifierObject(type) {
    if (typeof type !== 'string') {
        return new AlgorithmIdentifier(new ObjectIdentifier(type));
    }
    switch (type) {
        case 'sha1':
        case 'SHA1':
            return new AlgorithmIdentifier(OID_SHA1_NO_SIGN);
        case 'sha256':
        case 'SHA256':
            return new AlgorithmIdentifier(OID_SHA256_NO_SIGN);
        case 'sha384':
        case 'SHA384':
            return new AlgorithmIdentifier(OID_SHA384_NO_SIGN);
        case 'sha512':
        case 'SHA512':
            return new AlgorithmIdentifier(OID_SHA512_NO_SIGN);
        case 'sha224':
        case 'SHA224':
            return new AlgorithmIdentifier(OID_SHA224_NO_SIGN);
        case 'sha512-224':
        case 'SHA512-224':
            return new AlgorithmIdentifier(OID_SHA512_224_NO_SIGN);
        case 'sha512-256':
        case 'SHA512-256':
            return new AlgorithmIdentifier(OID_SHA512_256_NO_SIGN);
        case 'sha3-224':
        case 'SHA3-224':
            return new AlgorithmIdentifier(OID_SHA3_224_NO_SIGN);
        case 'sha3-256':
        case 'SHA3-256':
            return new AlgorithmIdentifier(OID_SHA3_256_NO_SIGN);
        case 'sha3-384':
        case 'SHA3-384':
            return new AlgorithmIdentifier(OID_SHA3_384_NO_SIGN);
        case 'sha3-512':
        case 'SHA3-512':
            return new AlgorithmIdentifier(OID_SHA3_512_NO_SIGN);
        case 'shake128':
        case 'SHAKE128':
            return new AlgorithmIdentifier(OID_SHAKE128_NO_SIGN);
        case 'shake256':
        case 'SHAKE256':
            return new AlgorithmIdentifier(OID_SHAKE256_NO_SIGN);
        default:
            throw new Error('Invalid or unsupported digest algorithm');
    }
}
function doSign(signer, digestAlgorithm, dataIterator) {
    if (signer.signData) {
        return signer.signData(dataIterator);
    }
    else {
        return signer.digestData(dataIterator).then(function (digestAttributes) {
            // encrypting DigestInfo with digest of 'attributes' set
            var digestInfoBin = new Uint8Array(new DigestInfo(digestAlgorithm, digestAttributes).toDER()).buffer;
            // (eencryptData should be defined here)
            return signer.encryptData(makeSimpleIterator(digestInfoBin));
        });
    }
}
/**
 * Generates the executable binary data with signed info.
 * This function is like an extension of `generate` method of `NtExecutable`.
 * @param executable a valid instance of `NtExecutable`
 * @param signer user-defined `SignerObject` instance for signing
 * @param alignment alignment value for placing certificate data
 *     (using `executable.getFileAlignment()` if omitted)
 * @return Promise-like (Thenable) object which will resolve with generated executable binary
 */
function generateExecutableWithSign(executable, signer, alignment) {
    validateSignerObject(signer);
    var certAlignment;
    if (typeof alignment === 'number') {
        if (alignment <= 0) {
            throw new Error('Invalid alignment value');
        }
        certAlignment = alignment;
    }
    else {
        certAlignment = executable.getFileAlignment();
    }
    var digestAlgorithm = getAlgorithmIdentifierObject(signer.getDigestAlgorithm());
    var digestEncryptionAlgorithm;
    var a = signer.getEncryptionAlgorithm();
    if (typeof a !== 'string') {
        digestEncryptionAlgorithm = new AlgorithmIdentifier(new ObjectIdentifier(a));
    }
    else {
        switch (a) {
            case 'rsa':
            case 'RSA':
                digestEncryptionAlgorithm = new AlgorithmIdentifier(OID_RSA);
                break;
            case 'dsa':
            case 'DSA':
                digestEncryptionAlgorithm = new AlgorithmIdentifier(OID_DSA);
                break;
            default:
                throw new Error('Invalid or unsupported digest encryption algorithm');
        }
    }
    // (for compatibility)
    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    var cert = signer.getCertificateData
        ? signer.getCertificateData()
        : signer.getPublicKeyData();
    var _a = pickIssuerAndSerialNumberDERFromCert(cert), issuer = _a[0], serialNumber = _a[1];
    return (
    // calculate digest
    calculateExecutableDigest(executable, signer, certAlignment)
        // make content, content's digest, and sign
        .then(function (digest) {
        var content = new SpcIndirectDataContent(new SpcPeImageAttributeTypeAndOptionalValue(new SpcPeImageData(0 /* SpcPeImageFlags.IncludeResources */, new SpcLinkFile(''))), new DigestInfo(digestAlgorithm, digest));
        return (signer
            .digestData(makeSimpleIterator(new Uint8Array(content.toDERWithoutHeader())
            .buffer))
            // make sign
            .then(function (contentDigest) {
            var attributes = [
                new Attribute(OID_SPC_SP_OPUS_INFO_OBJID, 
                // (SpcSpOpusInfo) null sequence
                [new RawDERObject([0x30, 0x00])]),
                new Attribute(OID_CONTENT_TYPE, [
                    SPC_INDIRECT_DATA_OBJID,
                ]),
                new Attribute(OID_SPC_STATEMENT_TYPE_OBJID, [
                    new RawDERObject(makeDERSequence(OID_SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID.toDER())),
                ]),
                new Attribute(OID_MESSAGE_DIGEST, [
                    new RawDERObject(makeDEROctetString(toUint8Array(contentDigest))),
                ]),
            ];
            // get digest of 'attributes' set
            var attrBin = new Uint8Array(arrayToDERSet(attributes)).buffer;
            return doSign(signer, digestAlgorithm, makeSimpleIterator(attrBin)).then(function (signed) {
                return [content, attributes, signed];
            });
        }));
    })
        // make cert bin
        .then(function (_a) {
        var content = _a[0], attributes = _a[1], signed = _a[2];
        var signerInfo = new SignerInfo(
        // version
        1, 
        // issuerAndSerialNumber
        new IssuerAndSerialNumber(new RawDERObject(issuer), new RawDERObject(serialNumber)), 
        // digestAlgorithm
        digestAlgorithm, 
        // digestEncryptionAlgorithm
        digestEncryptionAlgorithm, 
        // encryptedDigest
        toUint8Array(signed), 
        // authenticatedAttributes
        attributes);
        if (!signer.timestampData) {
            return [content, signerInfo];
        }
        // timestamp
        return (signer
            // make digest of encrypted data for make timestamp
            .digestData(makeSimpleIterator(cloneToArrayBuffer(signed)))
            .then(function (digestEncryptedBase) {
            var digestEncrypted = createTimestampRequest(digestEncryptedBase, digestAlgorithm);
            // request timestamp
            return signer.timestampData(digestEncrypted).then(function (timestamp) {
                // pick up signedData
                var timestampSignedData = pickSignedDataFromTimestampResponse(timestamp);
                // add timestamp to 'unauthenticatedAttributes'
                signerInfo.unauthenticatedAttributes = [
                    new Attribute(OID_RFC3161_COUNTER_SIGNATURE, [
                        new ContentInfo(OID_SIGNED_DATA, new RawDERObject(toUint8Array(timestampSignedData))),
                    ]),
                ];
                return [content, signerInfo];
            });
        }));
    })
        .then(function (_a) {
        var content = _a[0], signerInfo = _a[1];
        // make certificate data
        var root = new CertificateDataRoot(OID_SIGNED_DATA, new SignedData(
        // version
        1, 
        // digestAlgorithms
        [digestAlgorithm], 
        // contentInfo
        new SpcIndirectDataContentInfo(content), 
        // signerInfos
        [signerInfo], 
        // certificates
        certBinToCertificatesDER(cert)));
        var certBin = new Uint8Array(root.toDER());
        var resultBin = new ArrayBuffer(8 + certBin.length);
        // make WIN_CERTIFICATE
        var resultView = new DataView(resultBin);
        // dwLength
        resultView.setUint32(0, certBin.length + 8, true);
        // wRevision : 0x0200 (revision 2)
        resultView.setUint16(4, 0x200, true);
        // wCertificateType : 0x0002
        resultView.setUint16(6, 0x2, true);
        copyBuffer(resultBin, 8, certBin, 0, certBin.byteLength);
        return resultBin;
    })
        .then(function (certBin) {
        var alignedSize = roundUp(certBin.byteLength, certAlignment);
        // NOTE: The certificate data must follow the extra data.
        // To achieve this, the another size between them must be added to the padding size.
        // (The extra data may not be aligned, but the certificate data should be aligned.)
        var paddingSize = alignedSize;
        var exData = executable.getExtraData();
        if (exData !== null) {
            var diffSize = roundUp(exData.byteLength, certAlignment) -
                exData.byteLength;
            paddingSize += diffSize;
        }
        var newBin = executable.generate(paddingSize);
        var certOffset = newBin.byteLength - alignedSize;
        var dirArray = ImageDataDirectoryArray.from(newBin, executable.dosHeader.newHeaderAddress +
            executable.newHeader.getDataDirectoryOffset());
        dirArray.set(ImageDirectoryEntry$1.Certificate, {
            size: alignedSize,
            virtualAddress: certOffset,
        });
        // recalculate checksum
        calculateCheckSumForPE(newBin, true);
        // write Certificate section data
        copyBuffer(newBin, certOffset, certBin, 0, certBin.byteLength);
        return newBin;
    }));
}

export { index$1 as Data, index$2 as Format, NtExecutable, NtExecutableResource, index as Resource, calculateCheckSumForPE, generateExecutableWithSign, version$1 as peLibraryVersion, version as reseditVersion, version };
