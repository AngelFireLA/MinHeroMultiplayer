declare enum ImageDirectoryEntry {
    Export = 0,
    Import = 1,
    Resource = 2,
    Exception = 3,
    Certificate = 4,
    Security = 4,
    BaseRelocation = 5,
    Debug = 6,
    Architecture = 7,
    GlobalPointer = 8,
    Tls = 9,
    TLS = 9,
    LoadConfig = 10,
    BoundImport = 11,
    Iat = 12,
    IAT = 12,
    DelayImport = 13,
    ComDescriptor = 14,
    COMDescriptor = 14
}

declare abstract class FormatBase {
    protected readonly view: DataView;
    protected constructor(view: DataView);
    copyTo(bin: ArrayBuffer, offset: number): void;
    get byteLength(): number;
}

declare class ImageDosHeader extends FormatBase {
    static readonly size = 64;
    static readonly DEFAULT_MAGIC = 23117;
    private constructor();
    static from(bin: ArrayBuffer | ArrayBufferView, offset?: number): ImageDosHeader;
    isValid(): boolean;
    get magic(): number;
    set magic(val: number);
    get lastPageSize(): number;
    set lastPageSize(val: number);
    get pages(): number;
    set pages(val: number);
    get relocations(): number;
    set relocations(val: number);
    get headerSizeInParagraph(): number;
    set headerSizeInParagraph(val: number);
    get minAllocParagraphs(): number;
    set minAllocParagraphs(val: number);
    get maxAllocParagraphs(): number;
    set maxAllocParagraphs(val: number);
    get initialSS(): number;
    set initialSS(val: number);
    get initialSP(): number;
    set initialSP(val: number);
    get checkSum(): number;
    set checkSum(val: number);
    get initialIP(): number;
    set initialIP(val: number);
    get initialCS(): number;
    set initialCS(val: number);
    get relocationTableAddress(): number;
    set relocationTableAddress(val: number);
    get overlayNum(): number;
    set overlayNum(val: number);
    get oemId(): number;
    set oemId(val: number);
    get oemInfo(): number;
    set oemInfo(val: number);
    get newHeaderAddress(): number;
    set newHeaderAddress(val: number);
}

declare class ImageFileHeader extends FormatBase {
    static readonly size = 20;
    private constructor();
    static from(bin: ArrayBuffer, offset?: number): ImageFileHeader;
    get machine(): number;
    set machine(val: number);
    get numberOfSections(): number;
    set numberOfSections(val: number);
    get timeDateStamp(): number;
    set timeDateStamp(val: number);
    get pointerToSymbolTable(): number;
    set pointerToSymbolTable(val: number);
    get numberOfSymbols(): number;
    set numberOfSymbols(val: number);
    get sizeOfOptionalHeader(): number;
    set sizeOfOptionalHeader(val: number);
    get characteristics(): number;
    set characteristics(val: number);
}

declare class ImageOptionalHeader extends FormatBase {
    static readonly size = 96;
    static readonly DEFAULT_MAGIC = 267;
    private constructor();
    static from(bin: ArrayBuffer, offset?: number): ImageOptionalHeader;
    get magic(): number;
    set magic(val: number);
    get majorLinkerVersion(): number;
    set majorLinkerVersion(val: number);
    get minorLinkerVersion(): number;
    set minorLinkerVersion(val: number);
    get sizeOfCode(): number;
    set sizeOfCode(val: number);
    get sizeOfInitializedData(): number;
    set sizeOfInitializedData(val: number);
    get sizeOfUninitializedData(): number;
    set sizeOfUninitializedData(val: number);
    get addressOfEntryPoint(): number;
    set addressOfEntryPoint(val: number);
    get baseOfCode(): number;
    set baseOfCode(val: number);
    get baseOfData(): number;
    set baseOfData(val: number);
    get imageBase(): number;
    set imageBase(val: number);
    get sectionAlignment(): number;
    set sectionAlignment(val: number);
    get fileAlignment(): number;
    set fileAlignment(val: number);
    get majorOperatingSystemVersion(): number;
    set majorOperatingSystemVersion(val: number);
    get minorOperatingSystemVersion(): number;
    set minorOperatingSystemVersion(val: number);
    get majorImageVersion(): number;
    set majorImageVersion(val: number);
    get minorImageVersion(): number;
    set minorImageVersion(val: number);
    get majorSubsystemVersion(): number;
    set majorSubsystemVersion(val: number);
    get minorSubsystemVersion(): number;
    set minorSubsystemVersion(val: number);
    get win32VersionValue(): number;
    set win32VersionValue(val: number);
    get sizeOfImage(): number;
    set sizeOfImage(val: number);
    get sizeOfHeaders(): number;
    set sizeOfHeaders(val: number);
    get checkSum(): number;
    set checkSum(val: number);
    get subsystem(): number;
    set subsystem(val: number);
    get dllCharacteristics(): number;
    set dllCharacteristics(val: number);
    get sizeOfStackReserve(): number;
    set sizeOfStackReserve(val: number);
    get sizeOfStackCommit(): number;
    set sizeOfStackCommit(val: number);
    get sizeOfHeapReserve(): number;
    set sizeOfHeapReserve(val: number);
    get sizeOfHeapCommit(): number;
    set sizeOfHeapCommit(val: number);
    get loaderFlags(): number;
    set loaderFlags(val: number);
    get numberOfRvaAndSizes(): number;
    set numberOfRvaAndSizes(val: number);
}

declare class ImageOptionalHeader64 extends FormatBase {
    static readonly size = 112;
    static readonly DEFAULT_MAGIC = 523;
    private constructor();
    static from(bin: ArrayBuffer, offset?: number): ImageOptionalHeader64;
    get magic(): number;
    set magic(val: number);
    get majorLinkerVersion(): number;
    set majorLinkerVersion(val: number);
    get minorLinkerVersion(): number;
    set minorLinkerVersion(val: number);
    get sizeOfCode(): number;
    set sizeOfCode(val: number);
    get sizeOfInitializedData(): number;
    set sizeOfInitializedData(val: number);
    get sizeOfUninitializedData(): number;
    set sizeOfUninitializedData(val: number);
    get addressOfEntryPoint(): number;
    set addressOfEntryPoint(val: number);
    get baseOfCode(): number;
    set baseOfCode(val: number);
    get imageBase(): number;
    set imageBase(val: number);
    get imageBaseBigInt(): bigint;
    set imageBaseBigInt(val: bigint);
    get sectionAlignment(): number;
    set sectionAlignment(val: number);
    get fileAlignment(): number;
    set fileAlignment(val: number);
    get majorOperatingSystemVersion(): number;
    set majorOperatingSystemVersion(val: number);
    get minorOperatingSystemVersion(): number;
    set minorOperatingSystemVersion(val: number);
    get majorImageVersion(): number;
    set majorImageVersion(val: number);
    get minorImageVersion(): number;
    set minorImageVersion(val: number);
    get majorSubsystemVersion(): number;
    set majorSubsystemVersion(val: number);
    get minorSubsystemVersion(): number;
    set minorSubsystemVersion(val: number);
    get win32VersionValue(): number;
    set win32VersionValue(val: number);
    get sizeOfImage(): number;
    set sizeOfImage(val: number);
    get sizeOfHeaders(): number;
    set sizeOfHeaders(val: number);
    get checkSum(): number;
    set checkSum(val: number);
    get subsystem(): number;
    set subsystem(val: number);
    get dllCharacteristics(): number;
    set dllCharacteristics(val: number);
    get sizeOfStackReserve(): number;
    set sizeOfStackReserve(val: number);
    get sizeOfStackReserveBigInt(): bigint;
    set sizeOfStackReserveBigInt(val: bigint);
    get sizeOfStackCommit(): number;
    set sizeOfStackCommit(val: number);
    get sizeOfStackCommitBigInt(): bigint;
    set sizeOfStackCommitBigInt(val: bigint);
    get sizeOfHeapReserve(): number;
    set sizeOfHeapReserve(val: number);
    get sizeOfHeapReserveBigInt(): bigint;
    set sizeOfHeapReserveBigInt(val: bigint);
    get sizeOfHeapCommit(): number;
    set sizeOfHeapCommit(val: number);
    get sizeOfHeapCommitBigInt(): bigint;
    set sizeOfHeapCommitBigInt(val: bigint);
    get loaderFlags(): number;
    set loaderFlags(val: number);
    get numberOfRvaAndSizes(): number;
    set numberOfRvaAndSizes(val: number);
}

/** abstract class that support array-like methods and 'for...of' operation */
declare abstract class ArrayFormatBase<T> extends FormatBase {
    protected constructor(view: DataView);
    abstract readonly length: number;
    abstract get(index: number): Readonly<T>;
    abstract set(index: number, data: T): void;
    forEach(callback: (value: T, index: number, base: this) => void): void;
    _iterator(): Iterator<Readonly<T>>;
}
interface ArrayFormatBase<T> {
    [Symbol.iterator]: () => Iterator<Readonly<T>>;
}

interface ImageDataDirectory {
    virtualAddress: number;
    size: number;
}
declare class ImageDataDirectoryArray extends ArrayFormatBase<ImageDataDirectory> {
    static readonly size = 128;
    static readonly itemSize = 8;
    readonly length = 16;
    private constructor();
    /** @note This does not clone binary data; the changes to the array will modify the specified buffer `bin` */
    static from(bin: ArrayBuffer, offset?: number): ImageDataDirectoryArray;
    get(index: number): Readonly<ImageDataDirectory>;
    set(index: number, data: ImageDataDirectory): void;
    findIndexByVirtualAddress(virtualAddress: number): number | null;
}

declare class ImageNtHeaders extends FormatBase {
    static readonly DEFAULT_SIGNATURE = 17744;
    private constructor();
    static from(bin: ArrayBuffer | ArrayBufferView, offset?: number): ImageNtHeaders;
    isValid(): boolean;
    is32bit(): boolean;
    get signature(): number;
    set signature(val: number);
    get fileHeader(): ImageFileHeader;
    get optionalHeader(): ImageOptionalHeader | ImageOptionalHeader64;
    get optionalHeaderDataDirectory(): ImageDataDirectoryArray;
    getDataDirectoryOffset(): number;
    getSectionHeaderOffset(): number;
}

interface ImageSectionHeader {
    name: string;
    virtualSize: number;
    virtualAddress: number;
    sizeOfRawData: number;
    pointerToRawData: number;
    pointerToRelocations: number;
    pointerToLineNumbers: number;
    numberOfRelocations: number;
    numberOfLineNumbers: number;
    characteristics: number;
}
declare class ImageSectionHeaderArray extends ArrayFormatBase<ImageSectionHeader> {
    readonly length: number;
    static readonly itemSize = 40;
    private constructor();
    static from(bin: ArrayBuffer, length: number, offset?: number): ImageSectionHeaderArray;
    get(index: number): Readonly<ImageSectionHeader>;
    set(index: number, data: ImageSectionHeader): void;
}

interface NtExecutableFromOptions {
    /** true to parse binary even if the binary contains Certificate data (i.e. 'signed') */
    ignoreCert?: boolean;
}
interface NtExecutableSection {
    info: ImageSectionHeader;
    data: ArrayBuffer | null;
}
declare class NtExecutable {
    private readonly _headers;
    private readonly _sections;
    private _ex;
    private readonly _dh;
    private readonly _nh;
    private readonly _dda;
    private constructor();
    /**
     * Creates an NtExecutable instance with an 'empty' executable binary.
     * @param is32Bit set true if the binary is for 32-bit (default: false)
     * @param isDLL set true if the binary is DLL (default: true)
     * @return NtExecutable instance
     */
    static createEmpty(is32Bit?: boolean, isDLL?: boolean): NtExecutable;
    /**
     * Parse the binary and create NtExecutable instance.
     * An error will be thrown if the binary data is invalid
     * @param bin binary data
     * @param options additional option for parsing
     * @return NtExecutable instance
     */
    static from(bin: ArrayBuffer | ArrayBufferView, options?: NtExecutableFromOptions): NtExecutable;
    /**
     * Returns whether the executable is for 32-bit architecture
     */
    is32bit(): boolean;
    getTotalHeaderSize(): number;
    get dosHeader(): ImageDosHeader;
    get newHeader(): ImageNtHeaders;
    getRawHeader(): ArrayBuffer;
    getImageBase(): number;
    getFileAlignment(): number;
    getSectionAlignment(): number;
    /**
     * Return all sections. The returned array is sorted by raw address.
     */
    getAllSections(): readonly NtExecutableSection[];
    /**
     * Return the section data from ImageDirectoryEntry enum value.
     */
    getSectionByEntry(entry: ImageDirectoryEntry): Readonly<NtExecutableSection> | null;
    /**
     * Set the section data from ImageDirectoryEntry enum value.
     * If entry is found, then replaces the secion data. If not found, then adds the section data.
     *
     * NOTE: 'virtualAddress' and 'pointerToRawData' of section object is ignored
     * and calculated automatically. 'virtualSize' and 'sizeOfRawData' are used, but
     * if the 'section.data.byteLength' is larger than 'sizeOfRawData', then
     * these members are replaced.
     *
     * @param entry ImageDirectoryEntry enum value for the section
     * @param section the section data, or null to remove the section
     */
    setSectionByEntry(entry: ImageDirectoryEntry, section: Readonly<NtExecutableSection> | null): void;
    /**
     * Returns the extra data in the executable, or `null` if nothing.
     * You can rewrite the returned buffer without using `setExtraData` if
     * the size of the new data is equal to the old data.
     */
    getExtraData(): ArrayBuffer | null;
    /**
     * Specifies the new extra data in the executable.
     * The specified buffer will be cloned and you can release it after calling this method.
     * @param bin buffer containing the new data
     * @note
     * The extra data will not be aligned by `NtExecutable`.
     */
    setExtraData(bin: ArrayBuffer | ArrayBufferView | null): void;
    /**
     * Generates the executable binary data.
     */
    generate(paddingSize?: number): ArrayBuffer;
    private rearrangeSections;
    private replaceSectionImpl;
}

interface ResourceEntryBaseType$1<TType extends string | number, TID extends string | number, TLang extends string | number> {
    /**
     * The resource type name or numeric value.
     * For well-known type (such as `RT_ICON`), this value must be the predefined numeric value.
     */
    type: TType;
    /** The ID of resource data. */
    id: TID;
    /**
     * The language value of resource data.
     * According to specification, this value can be string, but
     * typically this value would be LANGID (numeric) value.
     */
    lang: TLang;
    /**
     * The code page value for strings within the resource data.
     * Typically this value would be the Unicode code page '1200'.
     */
    codepage: number;
    /** The actual resource data. If the data cannot be read, this field will be an empty binary. */
    bin: ArrayBuffer;
    /** RVA data for resource data. This field is available only when actual data (`bin` field) cannot be read. */
    rva?: number;
    /** (used by output) */
    offset?: number;
}
/** Raw resource entry data */
type ResourceEntry$1 = ResourceEntryBaseType$1<string | number, string | number, string | number>;

/** Manages resource data for NtExecutable */
declare class NtExecutableResource {
    /** The timestamp for resource */
    dateTime: number;
    /** The major version data for resource */
    majorVersion: number;
    /** The minor version data for resource */
    minorVersion: number;
    /** Resource entries */
    entries: ResourceEntry$1[];
    /**
     * The section data header of resource data (used by outputResource method).
     * This instance will be null if the base executable does not contain resource data.
     * You can override this field before calling outputResource method.
     * (Note that the addresses and sizes are ignored for output)
     */
    sectionDataHeader: ImageSectionHeader | null;
    private originalSize;
    private constructor();
    private parse;
    /**
     * Parses resource data for `NtExecutable`.
     * This function returns valid instance even if
     * the executable does not have resource data.
     * @param exe `NtExecutable` instance
     * @param ignoreUnparsableData (default: false) specify true if skipping 'unparsable' (e.g. unusual format) data.
     *   When true, the resource data may break on write operation.
     */
    static from(exe: NtExecutable, ignoreUnparsableData?: boolean): NtExecutableResource;
    /**
     * Add or replace the resource entry.
     * This method replaces the entry only if there is an entry with `type`, `id` and `lang` equal.
     */
    replaceResourceEntry(entry: ResourceEntry$1): void;
    /**
     * Returns all resource entries, which has specified type and id, as UTF-8 string data.
     * @param type Resource type
     * @param id Resource id
     * @returns an array of lang and value pair (tuple)
     */
    getResourceEntriesAsString(type: string | number, id: string | number): Array<[lang: string | number, value: string]>;
    /**
     * Add or replace the resource entry with UTF-8 string data.
     * This method is a wrapper of {@link NtExecutableResource.replaceResourceEntry}.
     */
    replaceResourceEntryFromString(type: string | number, id: string | number, lang: string | number, value: string): void;
    /**
     * Removes resource entries which has specified type and id.
     */
    removeResourceEntry(type: string | number, id: string | number, lang?: string | number): void;
    /**
     * Generates resource data binary for NtExecutable (not for .res file)
     * @param virtualAddress The virtual address for the section
     * @param alignment File alignment value of executable
     * @param noGrow Set true to disallow growing resource section (throw errors if data exceeds)
     * @param allowShrink Set true to allow shrinking resource section (if the data size is less than original)
     */
    generateResourceData(virtualAddress: number, alignment: number, noGrow?: boolean, allowShrink?: boolean): {
        bin: ArrayBuffer;
        rawSize: number;
        dataOffset: number;
        descEntryOffset: number;
        descEntryCount: number;
    };
    /**
     * Writes holding resource data to specified NtExecutable instance.
     * @param exeDest An NtExecutable instance to write resource section to
     * @param noGrow Set true to disallow growing resource section (throw errors if data exceeds)
     * @param allowShrink Set true to allow shrinking resource section (if the data size is less than original)
     */
    outputResource(exeDest: NtExecutable, noGrow?: boolean, allowShrink?: boolean): void;
}

declare function getImageDosHeader(bin: ArrayBuffer): ImageDosHeader;
declare function getImageNtHeadersByDosHeader(bin: ArrayBuffer, dosHeader: ImageDosHeader): ImageNtHeaders;
declare function getImageSectionHeadersByNtHeaders(bin: ArrayBuffer, dosHeader: ImageDosHeader, ntHeaders: ImageNtHeaders): ImageSectionHeaderArray;
declare function findImageSectionBlockByDirectoryEntry(bin: ArrayBuffer, dosHeader: ImageDosHeader, ntHeaders: ImageNtHeaders, entryType: ImageDirectoryEntry): ArrayBuffer | null;

type index_d$2_ArrayFormatBase<T> = ArrayFormatBase<T>;
type index_d$2_FormatBase = FormatBase;
declare const index_d$2_FormatBase: typeof FormatBase;
type index_d$2_ImageDataDirectory = ImageDataDirectory;
type index_d$2_ImageDataDirectoryArray = ImageDataDirectoryArray;
declare const index_d$2_ImageDataDirectoryArray: typeof ImageDataDirectoryArray;
type index_d$2_ImageDirectoryEntry = ImageDirectoryEntry;
declare const index_d$2_ImageDirectoryEntry: typeof ImageDirectoryEntry;
type index_d$2_ImageDosHeader = ImageDosHeader;
declare const index_d$2_ImageDosHeader: typeof ImageDosHeader;
type index_d$2_ImageFileHeader = ImageFileHeader;
declare const index_d$2_ImageFileHeader: typeof ImageFileHeader;
type index_d$2_ImageNtHeaders = ImageNtHeaders;
declare const index_d$2_ImageNtHeaders: typeof ImageNtHeaders;
type index_d$2_ImageOptionalHeader = ImageOptionalHeader;
declare const index_d$2_ImageOptionalHeader: typeof ImageOptionalHeader;
type index_d$2_ImageOptionalHeader64 = ImageOptionalHeader64;
declare const index_d$2_ImageOptionalHeader64: typeof ImageOptionalHeader64;
type index_d$2_ImageSectionHeader = ImageSectionHeader;
type index_d$2_ImageSectionHeaderArray = ImageSectionHeaderArray;
declare const index_d$2_ImageSectionHeaderArray: typeof ImageSectionHeaderArray;
declare const index_d$2_findImageSectionBlockByDirectoryEntry: typeof findImageSectionBlockByDirectoryEntry;
declare const index_d$2_getImageDosHeader: typeof getImageDosHeader;
declare const index_d$2_getImageNtHeadersByDosHeader: typeof getImageNtHeadersByDosHeader;
declare const index_d$2_getImageSectionHeadersByNtHeaders: typeof getImageSectionHeadersByNtHeaders;
declare namespace index_d$2 {
  export { type index_d$2_ArrayFormatBase as ArrayFormatBase, index_d$2_FormatBase as FormatBase, type index_d$2_ImageDataDirectory as ImageDataDirectory, index_d$2_ImageDataDirectoryArray as ImageDataDirectoryArray, index_d$2_ImageDirectoryEntry as ImageDirectoryEntry, index_d$2_ImageDosHeader as ImageDosHeader, index_d$2_ImageFileHeader as ImageFileHeader, index_d$2_ImageNtHeaders as ImageNtHeaders, index_d$2_ImageOptionalHeader as ImageOptionalHeader, index_d$2_ImageOptionalHeader64 as ImageOptionalHeader64, type index_d$2_ImageSectionHeader as ImageSectionHeader, index_d$2_ImageSectionHeaderArray as ImageSectionHeaderArray, index_d$2_findImageSectionBlockByDirectoryEntry as findImageSectionBlockByDirectoryEntry, index_d$2_getImageDosHeader as getImageDosHeader, index_d$2_getImageNtHeadersByDosHeader as getImageNtHeadersByDosHeader, index_d$2_getImageSectionHeadersByNtHeaders as getImageSectionHeadersByNtHeaders };
}

declare const _default: "2.0.0";

interface BitmapInfo {
    width: number;
    height: number;
    planes: number;
    bitCount: number;
    compression: number;
    sizeImage: number;
    xPelsPerMeter: number;
    yPelsPerMeter: number;
    colorUsed: number;
    colorImportant: number;
    colors: Array<{
        r: number;
        g: number;
        b: number;
    }>;
}

declare class IconItem {
    /**
     * Bitmap header data (`BITMAPINFOHEADER`)
     */
    readonly bitmapInfo: BitmapInfo;
    /**
     * Horizontal size of the icon in pixel (overrides `bitmapInfo.width`).
     * If `null` is specified, `bitmapInfo.width` will be used.
     */
    width: number | null;
    /**
     * Vertical size of the icon in pixel (overrides `bitmapInfo.height`).
     * If `null` is specified, `bitmapInfo.height` will be used.
     */
    height: number | null;
    /**
     * Bitmap pixel data used for mask
     * (the data will be appended immediately after `pixels` when generating icon binary)
     */
    masks: ArrayBuffer;
    /**
     * Bitmap pixel data
     */
    private _pixels;
    private constructor();
    /**
     * Bitmap pixel data.
     * @note
     * On set, if `bitmapInfo.sizeImage` is non-zero, `bitmapInfo.sizeImage` will be updated.
     */
    get pixels(): ArrayBuffer;
    /**
     * Bitmap pixel data.
     * @note
     * On set, if `bitmapInfo.sizeImage` is non-zero, `bitmapInfo.sizeImage` will be updated.
     */
    set pixels(newValue: ArrayBuffer);
    /**
     * Generates `IconItem` instance from bitmap data binary.
     * @param bin binary data containing the bitmap data
     * @param byteOffset byte offset of `bin` referring the bitmap data
     * @param byteLength available byte length for `bin` (from the offset `byteOffset`)
     */
    static from(bin: ArrayBuffer | ArrayBufferView, byteOffset?: number, byteLength?: number): IconItem;
    /**
     * Generates `IconItem` instance from bitmap data binary width actual icon size (width and height).
     * @param width icon width
     * @param height icon height
     * @param bin binary data containing the bitmap data
     * @param byteOffset byte offset of `bin` referring the bitmap data
     * @param byteLength available byte length for `bin` (from the offset `byteOffset`)
     */
    static from(width: number, height: number, bin: ArrayBuffer | ArrayBufferView, byteOffset?: number, byteLength?: number): IconItem;
    isIcon(): this is IconItem;
    isRaw(): false;
    generate(): ArrayBuffer;
}

/**
 * Represents the raw-graphic icon item, such as PNG data.
 */
declare class RawIconItem {
    width: number;
    height: number;
    bitCount: number;
    bin: ArrayBuffer;
    constructor(bin: ArrayBuffer | ArrayBufferView, width: number, height: number, bitCount: number, byteOffset?: number, byteLength?: number);
    static from(bin: ArrayBuffer | ArrayBufferView, width: number, height: number, bitCount: number, byteOffset?: number, byteLength?: number): RawIconItem;
    isIcon(): false;
    isRaw(): this is RawIconItem;
}

/**
 * All fields except for 'data' is optional.
 * Missing fields are replaced by 'data' values when generating binary.
 */
interface IconFileItem {
    width?: number;
    height?: number;
    colors?: number;
    planes?: number;
    bitCount?: number;
    data: IconItem | RawIconItem;
}
declare class IconFile {
    /** Containing icons */
    icons: IconFileItem[];
    constructor();
    static from(bin: ArrayBuffer | ArrayBufferView): IconFile;
    generate(): ArrayBuffer;
}

type index_d$1_BitmapInfo = BitmapInfo;
type index_d$1_IconFile = IconFile;
declare const index_d$1_IconFile: typeof IconFile;
type index_d$1_IconFileItem = IconFileItem;
type index_d$1_IconItem = IconItem;
declare const index_d$1_IconItem: typeof IconItem;
type index_d$1_RawIconItem = RawIconItem;
declare const index_d$1_RawIconItem: typeof RawIconItem;
declare namespace index_d$1 {
  export { type index_d$1_BitmapInfo as BitmapInfo, index_d$1_IconFile as IconFile, type index_d$1_IconFileItem as IconFileItem, index_d$1_IconItem as IconItem, index_d$1_RawIconItem as RawIconItem };
}

interface IconGroupItem {
    width: number;
    height: number;
    colors: number;
    planes: number;
    bitCount: number;
    dataSize: number;
    iconID: number;
}
/**
 * A class that treats icon-group resource data (`RT_ICON_GROUP`).
 * Note that this class does not treat `RT_ICON` data.
 *
 * - To pick all icons, use `IconGroupEntry.fromEntries`
 *   and `IconGroupEntry.prototype.getIconItemsFromEntries`.
 * - The easiest way to add/replace icons is using `IconGroupEntry.replaceIconsForResource`,
 *   which treats both `RT_ICON_GROUP` and `RT_ICON` entries.
 */
declare class IconGroupEntry {
    id: string | number;
    lang: string | number;
    readonly icons: IconGroupItem[];
    private constructor();
    static fromEntries(entries: readonly ResourceEntry$1[]): IconGroupEntry[];
    generateEntry(): ResourceEntry$1;
    /**
     * Return an array of `IconItem` / `RawIconItem`, which are in the group of this `IconGroupEntry` instance,
     * from specified resource entries.
     */
    getIconItemsFromEntries(entries: readonly ResourceEntry$1[]): Array<IconItem | RawIconItem>;
    /**
     * Add or replace icon resource entries with specified icon data.
     * The IDs of individual icon resources (`RT_ICON`) are calculated automatically.
     * @param destEntries base (destination) resource entries.
     * @param iconGroupID the icon ID for the new resource data.
     *     If the icon-group resource of the ID and 'lang' value already exists,
     *     the resource data is replaced; otherwise the resource data is appended.
     * @param lang the language for specified icons (0 for neutral, 0x409 for en-US)
     * @param icons the icons to replace
     */
    static replaceIconsForResource(destEntries: ResourceEntry$1[], iconGroupID: string | number, lang: string | number, icons: Array<IconItem | RawIconItem>): void;
}

/** Utility class to create / parse String Table resource */
declare class StringTable {
    /** Language value */
    lang: string | number;
    private items;
    constructor();
    /** Create StringTable instance from resource entries, with specified language. */
    static fromEntries(lang: string | number, entries: readonly ResourceEntry$1[]): StringTable;
    /** Return all string entries. */
    getAllStrings(): Array<{
        id: number;
        text: string;
    }>;
    /** Return the string data for ID value, which can be used for Win32API LoadString. */
    getById(id: number): string | null;
    /**
     * Set/overwide the string data for ID value, which can be used for Win32API LoadString.
     * @param id data ID
     * @param text string data (entry will be removed if null or empty string is specified)
     */
    setById(id: number, text: string | null): void;
    /** Generates an array of Entry for resource processings */
    generateEntries(): ResourceEntry$1[];
    /**
     * Replace all string entries for NtExecutableResource with containing resource data.
     * The only entries of same language are replaced.
     */
    replaceStringEntriesForExecutable(res: NtExecutableResource): void;
}

/**
 * Flag values used by VersionEntry.fixedInfo field.
 * Zero or more enum values are stored (with OR operator).
 */
declare enum VersionFileFlags {
    Debug = 1,
    Prerelease = 2,
    Patched = 4,
    PrivateBuild = 8,
    InfoInferred = 16,
    SpecialBuild = 32
}

/**
 * OS values used by VersionEntry.fixedInfo field.
 */
declare enum VersionFileOS {
    Unknown = 0,
    _Windows16 = 1,
    _PM16 = 2,
    _PM32 = 3,
    _Windows32 = 4,
    DOS = 65536,
    OS2_16 = 131072,
    OS2_32 = 196608,
    NT = 262144,
    DOS_Windows16 = 65537,
    DOS_Windows32 = 65540,
    NT_Windows32 = 262148,
    OS2_16_PM16 = 131074,
    OS2_32_PM32 = 196611
}

declare enum VersionFileDriverSubtype {
    Unknown = 0,
    Printer = 1,
    Keyboard = 2,
    Language = 3,
    Display = 4,
    Mouse = 5,
    Network = 6,
    System = 7,
    Installable = 8,
    Sound = 9,
    Comm = 10,
    VersionedPrinter = 12
}
declare enum VersionFileFontSubtype {
    Unknown = 0,
    Raster = 1,
    Vector = 2,
    TrueType = 3
}

/**
 * File type values used by VersionEntry.fixedInfo field.
 */
declare enum VersionFileType {
    Unknown = 0,
    App = 1,
    DLL = 2,
    Driver = 3,
    Font = 4,
    VxD = 5,
    StaticLibrary = 7
}

/**
 * String values for the version information.
 * In most cases predefined names are used for the key names (such as 'FileDescription', 'FileVersion', etc.)
 * Note that the key names are case-sensitive; this library does not convert keys
 * (e.g. `'fileVersion'` --> `'FileVersion'`).
 */
type VersionStringValues = Record<string, string>;
/** Used by `VersionInfo.create` */
interface VersionStringTable {
    lang: number;
    codepage: number;
    /** Any string values */
    values: VersionStringValues;
}
/** Translation information, containing LANGID and codepage value. */
interface VersionTranslation {
    lang: number;
    /** Almost all cases are set to 1200 (Unicode) */
    codepage: number;
}
/** Fixed version info, containing file version, product version, etc. (`VS_FIXEDFILEINFO`) */
interface VersionFixedInfo {
    /** usually major version in HIWORD(fileVersionMS), minor version in LOWORD(fileVersionMS) */
    fileVersionMS: number;
    /** usually patch version in HIWORD(fileVersionLS), revision in LOWORD(fileVersionLS) */
    fileVersionLS: number;
    productVersionMS: number;
    productVersionLS: number;
    /** valid values of fileFlags */
    fileFlagsMask: number;
    /** zero or more VersionFileFlags values, masked by fileFlagsMask */
    fileFlags: number;
    /** VersionFileOS value */
    fileOS: number;
    /** VersionFileType value */
    fileType: number;
    /**
     * subtype values depended on fileType, such as
     * `VersionFileDriverSubtype` or `VersionFileFontSubtype`.
     * (if no suitable value, zero is stored)
     */
    fileSubtype: number;
    fileDateMS: number;
    fileDateLS: number;
}
interface VersionInfoCreateParam {
    lang: string | number;
    /** This field can be as a partial object; default values (zero) are used for all unspecified field. */
    fixedInfo: Partial<Readonly<VersionFixedInfo>>;
    strings: readonly VersionStringTable[];
}
/**
 * Treats 'Version information' (`VS_VERSIONINFO`) resource data.
 */
declare class VersionInfo {
    private readonly data;
    private constructor();
    /** Returns new `VersionInfo` instance with empty data. */
    static createEmpty(): VersionInfo;
    /**
     * Returns new `VersionInfo` instance with specified parameters.
     * `fixedInfo` can be specified as a partial object;
     * default values (zero) are used for all unspecified field.
     */
    static create(lang: string | number, fixedInfo: Partial<Readonly<VersionFixedInfo>>, strings: readonly VersionStringTable[]): VersionInfo;
    /** Returns new `VersionInfo` instance with specified parameters. */
    static create(param: Readonly<VersionInfoCreateParam>): VersionInfo;
    /** Pick up all version-info entries */
    static fromEntries(entries: readonly ResourceEntry$1[]): VersionInfo[];
    /** A language value for this resource entry. */
    get lang(): string | number;
    set lang(value: string | number);
    /**
     * The property of fixed version info, containing file version, product version, etc.
     * (data: `VS_FIXEDFILEINFO`)
     *
     * Although this property is read-only, you can rewrite
     * each child fields directly to apply data.
     */
    get fixedInfo(): VersionFixedInfo;
    /**
     * Returns all languages that the executable supports. (data: `VarFileInfo`)
     *
     * Usually the returned array is equal to the one returned by `getAllLanguagesForStringValues`,
     * but some resource-generating tools doesn't generate same values.
     */
    getAvailableLanguages(): VersionTranslation[];
    /**
     * Replaces all languages that the executable supports.
     */
    replaceAvailableLanguages(languages: readonly VersionTranslation[]): void;
    /**
     * Returns all string values for the specified language. (data: values in lang-charset block of `StringFileInfo`)
     */
    getStringValues(language: VersionTranslation): VersionStringValues;
    /**
     * Returns all languages used by string values. (data: lang-charset name of `StringFileInfo`)
     *
     * Usually the returned array is equal to the one returned by `getAvailableLanguages`,
     * but some resource-generating tools doesn't generate same values.
     */
    getAllLanguagesForStringValues(): VersionTranslation[];
    /**
     * Add or replace the string values.
     * @param language language info
     * @param values string values (key-value pairs)
     * @param addToAvailableLanguage set `true` to add `language` into available languages
     *     if not existing in `getAvailableLanguages()` (default: `true`)
     */
    setStringValues(language: VersionTranslation, values: VersionStringValues, addToAvailableLanguage?: boolean): void;
    /**
     * Add or replace the string value.
     * @param language language info
     * @param key the key name of string value
     * @param value the string value
     * @param addToAvailableLanguage set `true` to add `language` into available languages
     *     if not existing in `getAvailableLanguages()` (default: `true`)
     */
    setStringValue(language: VersionTranslation, key: string, value: string, addToAvailableLanguage?: boolean): void;
    /**
     * Remove all string values for specified language.
     * @param language language info
     * @param removeFromAvailableLanguage set `true` to remove `language` from available languages
     *     if existing in `getAvailableLanguages()` (default: `true`)
     */
    removeAllStringValues(language: VersionTranslation, removeFromAvailableLanguage?: boolean): void;
    /**
     * Remove specified string value for specified language.
     * @param language language info
     * @param key the key name of string value to be removed
     * @param removeFromAvailableLanguage set `true` to remove `language` from available languages
     *     if no more string values exist for `language` (default: `true`)
     */
    removeStringValue(language: VersionTranslation, key: string, removeFromAvailableLanguage?: boolean): void;
    /**
     * Creates `Type.ResourceEntry` object for this instance.
     * Usually `outputToResourceEntries` is suitable for generating resource data
     * into executables, but you can use this method if necessary.
     */
    generateResource(): ResourceEntry$1;
    /**
     * Generates version info resource data (using `generateResource()`) and emits into `entries` array.
     * If version info resource already exists in `entries`, this method replaces it with the new one.
     * @param entries resource entry array for output
     */
    outputToResourceEntries(entries: ResourceEntry$1[]): void;
    private getDefaultVersionLang;
    /**
     * Sets 'FileVersion' property with specified values.
     * This methods writes `fixedInfo.fileVersionMS` and `fixedInfo.fileVersionLS` fields,
     * and writes `FileVersion` string with the value `<major>.<minor>.<micro>.<revision>`.
     * @param major The major version (clamped between 0 and 65535)
     * @param minor The minor version (clamped between 0 and 65535)
     * @param micro The micro version (clamped between 0 and 65535; default is 0)
     * @param revision The revision value (clamped between 0 and 65535; default is 0)
     * @param lang The language (default: this.lang -> picked from existings -> 1033)
     * @note
     * If you want to use 'Neutral' language for the version string, specify `lang` parameter to 0 explicitly
     */
    setFileVersion(major: number, minor: number, micro?: number, revision?: number, lang?: number): void;
    /**
     * Sets 'FileVersion' property with specified values.
     * This methods writes `fixedInfo.fileVersionMS` and `fixedInfo.fileVersionLS` fields,
     * and writes `FileVersion` string with the value `<major>.<minor>.<micro>.<revision>`.
     * @param version The version string value (should be `x.x.x.x` format; each integer clamped between 0 and 65535)
     * @param lang The language (default: this.lang -> picked from existings -> 1033)
     * @note
     * If you want to use 'Neutral' language for the version string, specify `lang` parameter to 0 explicitly
     */
    setFileVersion(version: string, lang?: number): void;
    private setFileVersionImpl;
    /**
     * Sets 'ProductVersion' property with specified values.
     * This methods writes `fixedInfo.productVersionMS` and `fixedInfo.productVersionLS` fields,
     * and writes `ProductVersion` string with the value `<major>.<minor>.<micro>.<revision>`.
     * @param major The major version (clamped between 0 and 65535)
     * @param minor The minor version (clamped between 0 and 65535)
     * @param micro The micro version (clamped between 0 and 65535; default is 0)
     * @param revision The revision value (clamped between 0 and 65535; default is 0)
     * @param lang The language (default: this.lang -> picked from existings -> 1033)
     * @note
     * If you want to use 'Neutral' language for the version string, specify `lang` parameter to 0 explicitly
     */
    setProductVersion(major: number, minor: number, micro?: number, revision?: number, lang?: number): void;
    /**
     * Sets 'ProductVersion' property with specified values.
     * This methods writes `fixedInfo.productVersionMS` and `fixedInfo.productVersionLS` fields,
     * and writes `ProductVersion` string with the value `<major>.<minor>.<micro>.<revision>`.
     * @param version The version string value (should be `x.x.x.x` format; each integer clamped between 0 and 65535)
     * @param lang The language (default: this.lang -> picked from existings -> 1033)
     * @note
     * If you want to use 'Neutral' language for the version string, specify `lang` parameter to 0 explicitly
     */
    setProductVersion(version: string, lang?: number): void;
    private setProductVersionImpl;
}

type ResourceEntry = ResourceEntry$1;
type ResourceEntryBaseType<TType extends string | number, TID extends string | number, TLang extends string | number> = ResourceEntryBaseType$1<TType, TID, TLang>;

type index_d_IconGroupEntry = IconGroupEntry;
declare const index_d_IconGroupEntry: typeof IconGroupEntry;
type index_d_IconGroupItem = IconGroupItem;
type index_d_ResourceEntry = ResourceEntry;
type index_d_ResourceEntryBaseType<TType extends string | number, TID extends string | number, TLang extends string | number> = ResourceEntryBaseType<TType, TID, TLang>;
type index_d_StringTable = StringTable;
declare const index_d_StringTable: typeof StringTable;
type index_d_VersionFileDriverSubtype = VersionFileDriverSubtype;
declare const index_d_VersionFileDriverSubtype: typeof VersionFileDriverSubtype;
type index_d_VersionFileFlags = VersionFileFlags;
declare const index_d_VersionFileFlags: typeof VersionFileFlags;
type index_d_VersionFileFontSubtype = VersionFileFontSubtype;
declare const index_d_VersionFileFontSubtype: typeof VersionFileFontSubtype;
type index_d_VersionFileOS = VersionFileOS;
declare const index_d_VersionFileOS: typeof VersionFileOS;
type index_d_VersionFileType = VersionFileType;
declare const index_d_VersionFileType: typeof VersionFileType;
type index_d_VersionFixedInfo = VersionFixedInfo;
type index_d_VersionInfo = VersionInfo;
declare const index_d_VersionInfo: typeof VersionInfo;
type index_d_VersionInfoCreateParam = VersionInfoCreateParam;
type index_d_VersionStringTable = VersionStringTable;
type index_d_VersionStringValues = VersionStringValues;
type index_d_VersionTranslation = VersionTranslation;
declare namespace index_d {
  export { index_d_IconGroupEntry as IconGroupEntry, type index_d_IconGroupItem as IconGroupItem, type index_d_ResourceEntry as ResourceEntry, type index_d_ResourceEntryBaseType as ResourceEntryBaseType, index_d_StringTable as StringTable, index_d_VersionFileDriverSubtype as VersionFileDriverSubtype, index_d_VersionFileFlags as VersionFileFlags, index_d_VersionFileFontSubtype as VersionFileFontSubtype, index_d_VersionFileOS as VersionFileOS, index_d_VersionFileType as VersionFileType, type index_d_VersionFixedInfo as VersionFixedInfo, index_d_VersionInfo as VersionInfo, type index_d_VersionInfoCreateParam as VersionInfoCreateParam, type index_d_VersionStringTable as VersionStringTable, type index_d_VersionStringValues as VersionStringValues, type index_d_VersionTranslation as VersionTranslation };
}

/** Predefined algorithm types */
type DigestAlgorithmType = 'sha1' | 'sha224' | 'sha256' | 'sha384' | 'sha512' | 'sha512-224' | 'sha512-256' | 'sha3-224' | 'sha3-256' | 'sha3-384' | 'sha3-512' | 'shake128' | 'shake256' | 'SHA1' | 'SHA224' | 'SHA256' | 'SHA384' | 'SHA512' | 'SHA512-224' | 'SHA512-256' | 'SHA3-224' | 'SHA3-256' | 'SHA3-384' | 'SHA3-512' | 'SHAKE128' | 'SHAKE256';
type EncryptionAlgorithmType = 'rsa' | 'dsa' | 'RSA' | 'DSA';
interface SignerObject {
    /**
     * Returns the digest algorithm used in `digestData`.
     * To use the algorithm other than defined in `DigestAlgorithmType`,
     * return an integer array of values from OID string.
     * (e.g. [1,3,14,3,2,26] for 'sha1')
     *
     * @note
     * The newer digest algorithm (including SHA224, SHA512-256, SHA3 algorithms, etc.)
     * might not be supported by Windows.
     */
    getDigestAlgorithm(): DigestAlgorithmType | number[];
    /**
     * Returns the encryption algorithm used in `encryptData`.
     * To use the algorithm other than defined in `EncryptionAlgorithmType`,
     * return an integer array of values from OID string.
     * (e.g. [1,2,840,113549,1,1,1] for 'rsa')
     */
    getEncryptionAlgorithm(): EncryptionAlgorithmType | number[];
    /**
     * Returns the certificate data, which format is DER binary (X.509 certificate data
     * or '.p7b' file data which is based on DER and contains certificates).
     *
     * You can return an `Array` (not an `ArrayLike`), which contains one or more certificates in format above.
     * In this case, each certificates are stored to signed data in order.
     * Note that this library does not sort certificates, so the implementation should have responsible for the order of certificates.
     */
    getCertificateData(): ArrayBuffer | ArrayBufferView | Array<ArrayBuffer | ArrayBufferView>;
    /**
     * Returns the public key data, which format is DER binary (X.509 Public Key or '.p7b' file data which is based on DER).
     *
     * You can return an `Array` (not an `ArrayLike`), which contains one or more public keys in format above.
     * In this case, each public keys are stored to signed data in order.
     * Note that this library does not sort public keys, so the implementation should have responsible for the order of keys.
     *
     * @deprecated This method is renamed to {@link getCertificateData} due to the actual purpose of this method
     *   and `getPublicKeyData` will no longer be used in the future.
     */
    getPublicKeyData?(): ArrayBuffer | ArrayBufferView | Array<ArrayBuffer | ArrayBufferView>;
    /**
     * Digests specified data. The digest algorithm type must be same as the result of `getDigestAlgorithm`.
     * Must pick all data from `dataIterator` (until `dataIterator.next().done` is `true`).
     */
    digestData(dataIterator: Iterator<ArrayBuffer, void>): PromiseLike<ArrayBuffer | ArrayBufferView>;
    /**
     * Encrypts specified data with **private key** (i.e. can be verified with the public key from `getCertificateData`). The private key type (algorithm) must be same as the result of `getEncryptionAlgorithm`.
     * Must pick all data from `dataIterator` (until `dataIterator.next().done` is `true`).
     *
     * This method must be implemented if `signData` is not implemented.
     */
    encryptData?(dataIterator: Iterator<ArrayBuffer, void>): PromiseLike<ArrayBuffer | ArrayBufferView>;
    /**
     * Signs specified data with **private key** (i.e. can be verified with the public key from `getCertificateData`).
     * The private key type (algorithm) must be same as the result of `getEncryptionAlgorithm`, and the digest algorithm must be same as the result of `getDigestAlgorithm`.
     * Must pick all data from `dataIterator` (until `dataIterator.next().done` is `true`).
     *
     * This method must be implemented if `encryptData` is not implemented.
     *
     * Note that even if `signData` is implemented, `digestData` must be implemented.
     */
    signData?(dataIterator: Iterator<ArrayBuffer, void>): PromiseLike<ArrayBuffer | ArrayBufferView>;
    /**
     * Make 'timestamp' data, generated by TSA, from specified data (omit this method if not using timestamp).
     * Must return entire timestamp response data.
     * @param reqData timestamp request data (`TimeStampReq`) to send to TSA
     */
    timestampData?(reqData: ArrayBuffer): PromiseLike<ArrayBuffer | ArrayBufferView>;
}

/**
 * Generates the executable binary data with signed info.
 * This function is like an extension of `generate` method of `NtExecutable`.
 * @param executable a valid instance of `NtExecutable`
 * @param signer user-defined `SignerObject` instance for signing
 * @param alignment alignment value for placing certificate data
 *     (using `executable.getFileAlignment()` if omitted)
 * @return Promise-like (Thenable) object which will resolve with generated executable binary
 */
declare function generateExecutableWithSign(executable: NtExecutable, signer: SignerObject, alignment?: number): PromiseLike<ArrayBuffer>;

export { index_d$1 as Data, type DigestAlgorithmType, type EncryptionAlgorithmType, index_d$2 as Format, NtExecutable, NtExecutableResource, index_d as Resource, type SignerObject, generateExecutableWithSign, _default as version };
